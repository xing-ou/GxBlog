<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gouxin.fun/</id>
    <title>Gx'sBlog Blog</title>
    <updated>2021-11-09T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gouxin.fun/"/>
    <subtitle>Gx'sBlog Blog</subtitle>
    <icon>https://gouxin.fun/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[SwiftUI专辑006-自定义ViewModifier]]></title>
        <id>/2021/11/09/SwiftUI专辑-006-自定义ViewModifier</id>
        <link href="https://gouxin.fun/2021/11/09/SwiftUI专辑-006-自定义ViewModifier"/>
        <updated>2021-11-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerimg]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI为你提供了自定义modifiers的能力。
你可以使用自定义modifiers将多个modifiers合成一个。
本章我们将创建一个自定义modifier，他能够为TextView添加圆角和背景。</p><h2>Getting ready</h2><p>新建一个SwiftUI工程<strong>UsingViewModifiers</strong>。</p><h2>How to do it…</h2><ol><li>修改<strong>ContentView</strong>中的text为<strong>Perfect</strong>。</li></ol><pre><code class="language-swift">Text(&quot;Perfect&quot;)
</code></pre><ol start="2"><li>在<strong>ContentView.swift</strong>中，新建一个struct，遵循<strong>ViewModifier</strong>，接受一个参数<strong>Color</strong>。</li></ol><pre><code class="language-swift">struct BackgroundStyle: ViewModifier {
    var bgColor: Color
    func body(content: Content) -&gt; some View{
        content
        .frame(width:UIScreen.main.bounds.width * 0.3)
        .foregroundColor(Color.black)
        .padding()
        .background(bgColor)
        .cornerRadius(CGFloat(20))
    }
}
</code></pre><ol start="3"><li>为Text添加一个<strong>modifier</strong>。</li></ol><pre><code class="language-swift">Text(&quot;Perfect&quot;).modifier(BackgroundStyle(bgColor:.blue))
</code></pre><ol start="4"><li>当然，如果你不想用<strong>modifier</strong>, 可以添加一个extension。</li></ol><pre><code class="language-swift">extension View {
    func backgroundStyle(color: Color) -&gt; some View{
        self.modifier(BackgroundStyle(bgColor: color))
    }
}
</code></pre><ol start="5"><li>将我们的modifier修改为刚刚的extension</li></ol><pre><code class="language-swift">Text(&quot;Perfect&quot;).backgroundStyle(color: Color.red)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxo31sxp0vj30fg0v80t3.jpg" alt="image-20211223212239097"/></p><h2>How it works…</h2><p>一个 <strong>ViewModifier</strong>通过修改原来修饰的View来创建一个新的View  。</p><p>通过通过遵循ViewModifier协议来创建一个自定义modifier。</p><p>通过.modifier()来应用我们自定义的modifier。</p><p>通过extension来添加更方便的Api。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SwiftUI专辑005-各种pickers]]></title>
        <id>/2021/11/08/SwiftUI专辑-005-各种pickers</id>
        <link href="https://gouxin.fun/2021/11/08/SwiftUI专辑-005-各种pickers"/>
        <updated>2021-11-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerimg]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
pickers是用来提供给用户选择某个值的。
本文将介绍以下的pickers</p><ul><li><strong>Picker</strong></li><li><strong>Toggle</strong></li><li><strong>Slider</strong></li><li><strong>Stepper</strong></li><li><strong>DatePicker</strong></li><li><strong>ColorPicker</strong></li></ul><h2>Getting ready</h2><p>首先，新建一个SwiftUI工程，叫做<strong>PickersApp</strong>。</p><h2>How to do it…</h2><ol><li>在<strong>ContentView.swift</strong>创建好State，以绑定各个pickers的value。</li></ol><pre><code class="language-swift">@State var choice = 0
@State var showText = false
@State var transitModes = [&quot;Bike&quot;, &quot;Car&quot;, &quot;Bus&quot;]
@State var sliderVal: Float = 0
@State var stepVal = 0
@State var gameTime = Date()
</code></pre><ol start="2"><li>在Body中加入一个<code>Form</code>、<code>Section</code>、<code>Picker</code>。</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var choice = 0
    @State var showText = false
    @State var transitModes = [&quot;Bike&quot;, &quot;Car&quot;, &quot;Bus&quot;]
    @State var sliderVal: Float = 0
    @State var stepVal = 0
    @State var gameTime = Date()
    
    var body: some View {
        Form {
            Section {
                Picker(&quot;Transit Modes&quot;, selection: $choice) {
                    ForEach(0..&lt;transitModes.count) { index in
                        Text(&quot;\(self.transitModes[index])&quot;)
                    }
                }.pickerStyle(.segmented)
                Text(&quot;Current choice: \(self.transitModes[choice])&quot;)
            }
        }
    }
}
</code></pre><ol start="3"><li>再添加一个section，加入<code>Toggle</code></li></ol><pre><code class="language-swift">Section {
    Toggle(isOn: $showText) {
        Text(&quot;Show Text&quot;)
    }
    if showText {
        Text(&quot;The Text toggle is on&quot;)
    }
}
</code></pre><ol start="4"><li>再添加一个section，加入<code>Slider</code></li></ol><pre><code class="language-swift">Section {
    Slider(value: $sliderVal, in: 0...10, step: 0.001)
    Text(&quot;Slider current value\(sliderVal, specifier: &quot;%.1f&quot;)&quot;)
}
</code></pre><ol start="5"><li>再添加一个section，加入<code>Stepper</code></li></ol><pre><code class="language-swift">Section {
    Stepper(&quot;Stepper&quot;, value: $stepVal, in: 0...5)
    Text(&quot;Stepper current value\(stepVal)&quot;)
}
</code></pre><ol start="6"><li>再添加一个section，加入<code>DatePicker</code></li></ol><pre><code class="language-swift"> Section {
    DatePicker(&quot;Please select a date&quot;, selection: $gameTime)
}
</code></pre><ol start="7"><li>再添加一个section，加入<code>DatePicker</code>,再限制下时间范围</li></ol><pre><code class="language-swift">Section {
  DatePicker(&quot;select a date&quot;, selection: $gameTime, in: Date()...)
}
</code></pre><p>最终如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnlz3hh9zj30i80xuaba.jpg" alt="image-20211223113151810"/></p><h2>How it works…</h2><p><code>Picker</code>是用来从一组值中选择某一个的，设置style为Segmented就得到了一个UIKit的SegmentView。</p><p><code>Toggle</code>控制开和关，当前状态存储在binding的vlaue中。</p><p><code>Slider</code>需要3个参数: </p><ul><li><strong>value</strong>: 当前值</li><li><strong>in</strong>： slider的范围</li><li><strong>step</strong>： 步进的值</li></ul><p><code>Stepper</code>也同Slider一样需要那3个参数。</p><p>最后演示了一下DatePicker的使用，注意binding的类型是date。</p><blockquote><p>picker的style会根据他的容器不同而不同。比如在Form或者List中的picker会和在VStack中的不一样。</p><p>我们可以通过<code>.pickerStyle</code>来修改默认style。</p></blockquote><h2>Api详情</h2><h3>Picker</h3><h4>Creating a Picker</h4><pre><code class="language-swift">///SelectionValue遵循Hashable， Content和Label都遵循View
init(selection: Binding&lt;SelectionValue&gt;, content: () -&gt; Content, label: () -&gt; Label)
</code></pre><blockquote><p>注意Picker的每个选项都需要带上tag，而且tag的值和类型要和Binding的变量一样。</p></blockquote><pre><code class="language-swift">enum Flavor: String, CaseIterable {
    case chocolate
    case vanilla
    case strawberry
}
struct ContentView: View {
    @State var selectedFlavor: Flavor = .chocolate
    var body: some View {
        Form {
            Section {
                Picker(&quot;Flaver&quot;, selection: $selectedFlavor) {
                   //注意需要标上tag，而且类型需要和Binding的一样
                    Text(&quot;\(Flavor.chocolate.rawValue)&quot;).tag(Flavor.chocolate)
                    Text(&quot;\(Flavor.vanilla.rawValue)&quot;).tag(Flavor.vanilla)
                    Text(&quot;\(Flavor.strawberry.rawValue)&quot;).tag(Flavor.strawberry)
                }.pickerStyle(.segmented)
                Text(&quot;Current Flaver: \(selectedFlavor.rawValue)&quot;)
            }    
        }
    }
}
</code></pre><p>可能有人就有疑问了，为什么在<code>how to do</code>那里的Picker的例子就没有打tag呢？</p><p>因为ForEach会自动为你打tag，这个tag的值是遵循了<code>Identifiable</code>协议的对象的id字段。所以之前的那个例子不用显示的带上tag。如果我们要改写上面的例子用ForEach实现呢？</p><pre><code class="language-swift">///遵循Identifiable协议
enum Flavor: String, CaseIterable, Identifiable {
    case chocolate
    case vanilla
    case strawberry
    var id: Flavor { self }
}
struct ContentView: View {
    @State var selectedFlavor: Flavor = .chocolate
    var body: some View {
        Form {
            Section {
                Picker(&quot;Flaver&quot;, selection: $selectedFlavor) {
                    // 不用显示的打tag，默认用id作为tag，id和Binding都是Flavor类型的
                    // 当然，如果你愿意，也可以自己显示的指定tag
                                        ForEach(Flavor.allCases) { flavor in
                        Text(&quot;\(flavor.rawValue)&quot;)
                    }
                }.pickerStyle(.segmented)
                Text(&quot;Current Flaver: \(selectedFlavor.rawValue)&quot;)
            }    
        }
    }
}
</code></pre><h4>Styling Pickers</h4><pre><code class="language-swift">/// 设置picker的样式
func pickerStyle&lt;S&gt;(_ style: S) -&gt; some View where S : PickerStyle
</code></pre><pre><code class="language-swift">//segment样式
static var segmented: SegmentedPickerStyle { get }
</code></pre><pre><code class="language-swift">//类似于UIPicker的那种滚轮样式
static var wheel: WheelPickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnr4e090vj30ge0cowek.jpg" alt="image-20211223142959083"/></p><pre><code class="language-swift">//macOS上的勾选样式
static var radioGroup: RadioGroupPickerStyle { get }
</code></pre><pre><code class="language-swift">//菜单，类似于UIPopoverController，点了出现小弹窗，包含所有选项
static var menu: MenuPickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnr2qhu8rj30hs0am74h.jpg" alt="image-20211223142823304"/></p><pre><code class="language-swift">//所有选项都同时显示出来，
static var inline: InlinePickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnr1g1v55j30hi0aw74g.jpg" alt="image-20211223142709578"/></p><h3>Toggle</h3><h4>Creating a Toggle</h4><pre><code class="language-swift">init(isOn: Binding&lt;Bool&gt;, label: () -&gt; Label)
...
</code></pre><h4>Creating a Toggle from a Configuration</h4><pre><code class="language-swift">//通常用在自定义ToggleStyle中
init(_ configuration: ToggleStyleConfiguration)
</code></pre><p>举个例子</p><pre><code class="language-swift">struct RedBorderToggleStyle: ToggleStyle {
    func makeBody(configuration: Configuration) -&gt; some View {
        Toggle(configuration)//通过cinfiguration初始化
            .padding()
            .border(Color.red)
    }
}

Toggle(isOn: $showText) {
      Text(&quot;Show Text&quot;)
}.toggleStyle(RedBorderToggleStyle())
</code></pre><h4>Styling a Toggle</h4><pre><code class="language-swift">func toggleStyle&lt;S&gt;(_ style: S) -&gt; some View where S : ToggleStyle
</code></pre><p>下面是一些默认的style</p><pre><code class="language-swift">/// switch样式
static var `switch`: SwitchToggleStyle { get }
</code></pre><pre><code class="language-swift">/// label作为btn, on的时候，背景设为tintColor
static var button: ButtonToggleStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnrhzplnnj30ps0fcgm1.jpg" alt="image-20211223144303808"/></p><pre><code class="language-swift">/// 勾选框，只有macOS有
static var checkbox: CheckboxToggleStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnrj91cugj30ho04i749.jpg" alt="image-20211223144416027"/></p><h3>Slider</h3><pre><code class="language-swift">/**
value : binding的值
bounds: 值的范围
step: 步进的大小
label: 描述的view
minimumValueLabel
maximumValueLabel最大和最小端的view
*/
init&lt;V&gt;(value: Binding&lt;V&gt;, in bounds: ClosedRange&lt;V&gt;, step: V.Stride = 1, label: () -&gt; Label, minimumValueLabel: () -&gt; ValueLabel, maximumValueLabel: () -&gt; ValueLabel, onEditingChanged: @escaping (Bool) -&gt; Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint
</code></pre><h3>Stepper</h3><h4>Creating a Stepper</h4><pre><code class="language-swift">/**
value : binding的值
bounds: 值的范围
step: 步进的大小
label: 描述的view
*/
init&lt;V&gt;(value: Binding&lt;V&gt;, in bounds: ClosedRange&lt;V&gt;, step: V.Stride = 1, label: () -&gt; Label, onEditingChanged: @escaping (Bool) -&gt; Void = { _ in }) where V : Strideable
</code></pre><h4>Creating a Stepper with Specified Increment and Decrement Behavior</h4><pre><code class="language-swift">// 不在和某个value绑定，将两个按钮的事件暴露出来，提供给你自定义你的逻辑
init(label: () -&gt; Label, onIncrement: (() -&gt; Void)?, onDecrement: (() -&gt; Void)?, onEditingChanged: @escaping (Bool) -&gt; Void = { _ in })
</code></pre><h3>DatePicker</h3><h4>Creating a Date Picker</h4><pre><code class="language-swift">init(selection: Binding&lt;Date&gt;, displayedComponents: DatePicker&lt;Label&gt;.Components = [.hourAndMinute, .date], label: () -&gt; Label)
/// 可以指定range, start...end
init(selection: Binding&lt;Date&gt;, in range: ClosedRange&lt;Date&gt;, displayedComponents: DatePicker&lt;Label&gt;.Components = [.hourAndMinute, .date], label: () -&gt; Label)
/// 可以指定range, start...
init(selection: Binding&lt;Date&gt;, in range: PartialRangeFrom&lt;Date&gt;, displayedComponents: DatePicker&lt;Label&gt;.Components = [.hourAndMinute, .date], label: () -&gt; Label)
/// 可以指定range, ...end
init(selection: Binding&lt;Date&gt;, in range: PartialRangeThrough&lt;Date&gt;, displayedComponents: DatePicker&lt;Label&gt;.Components = [.hourAndMinute, .date], label: () -&gt; Label)
</code></pre><h4>Setting Date Picker Components</h4><pre><code class="language-swift">//设置显示的components
static let date: DatePickerComponents// 年月日
static let hourAndMinute: DatePickerComponents//小时，分钟
</code></pre><h4>Styling Date Pickers</h4><pre><code class="language-swift">///设置picker样式
func datePickerStyle&lt;S&gt;(_ style: S) -&gt; some View where S : DatePickerStyle
</code></pre><pre><code class="language-swift">static var wheel: WheelDatePickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnss4kk3mj30ga0ce74g.jpg" alt="image-20211223152724050"/></p><pre><code class="language-swift">/// macOS上特有的，类似于Stepper
static var stepperField: StepperFieldDatePickerStyle { get }
/// macOS上特有的
static var field: FieldDatePickerStyle { get }
</code></pre><pre><code class="language-swift">static var graphical: GraphicalDatePickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnstx1k4wj30h00hoaak.jpg" alt="image-20211223152907356"/></p><pre><code class="language-swift">///component以文本格式显示
static var compact: CompactDatePickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnsx112spj30gu04y3yg.jpg" alt="image-20211223153206130"/></p><h3>ColorPicker</h3><p>选择颜色</p><pre><code class="language-swift">///绑定Color
init(selection: Binding&lt;Color&gt;, supportsOpacity: Bool = true, label: () -&gt; Label)
///绑定CGColor
init(selection: Binding&lt;CGColor&gt;, supportsOpacity: Bool = true, label: () -&gt; Label)
</code></pre><pre><code class="language-swift">ColorPicker(selection: $color) {
    Text(&quot;选择颜色&quot;)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnt5817uvj30gm03cwec.jpg" alt="image-20211223153959117"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SwiftUI专辑004-Button以及跳转]]></title>
        <id>/2021/11/07/SwiftUI专辑-004-Button以及跳转</id>
        <link href="https://gouxin.fun/2021/11/07/SwiftUI专辑-004-Button以及跳转"/>
        <updated>2021-11-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerimg]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本章将介绍如何使用各种Button和如何跳转。</p><ul><li>Button</li><li>EditButton</li><li>PasteButton</li><li>NavigationView</li><li>NavigationLink</li></ul><h2>Getting ready</h2><p>首先，新建一个<strong>ButtonsApp</strong>的SwiftUI工程。</p><h2>How to do it…</h2><ol><li>新建文件</li><li>模板选择<strong>SwiftUI View</strong></li><li>输入名称<strong>ButtonView</strong></li><li>重复上面步骤，创建<strong>EditButtonView</strong></li><li>重复上面步骤，创建<strong>PasteButtonView</strong></li><li>重复上面步骤，创建<strong>MenuButtonView</strong>，(<strong>MenuButton</strong>已经弃用了，使用<strong>Menu</strong>)</li><li>打开<strong>ContentView.swift</strong>，在body中添加一个<strong>NavigationView</strong></li></ol><pre><code class="language-swift">NavigationView {
    VStack {
        NavigationLink(destination: ButtonView()) {
            Text(&quot;Buttons&quot;).padding()
        }
        NavigationLink(destination: EditButtonView()) {
            Text(&quot;EditButtons&quot;).padding()
        }
        NavigationLink(destination: MenuButtonView()) {
            Text(&quot;MenuButtons&quot;).padding()
        }
        NavigationLink(destination: PasteButtonView()) {
            Text(&quot;PasteButtons&quot;).padding()
        }
        NavigationLink(destination:
            Text(&quot;Very long text that should not be displayed in a single line because it is not good design&quot;)
                .padding()
                .navigationBarTitle(Text(&quot;Detail&quot;))
        ) {
            Text(&quot;details about text&quot;).padding()
        }
}.navigationBarTitle(Text(&quot;Main View&quot;), displayMode:.inline)

</code></pre><p>最终显示如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxmozc7y7pj30ci0oyjrs.jpg" alt="image-20211222163022220"/></p><ol start="8"><li>打开<strong>EditButtonView.swift</strong>，添加下面的代码，实现<strong>EditButton</strong>。</li></ol><pre><code class="language-swift">struct EditButtonView: View {
    @State private var animals = [&quot;Cats&quot;, &quot;Dogs&quot;, &quot;Goats&quot;]
    var body: some View {
        NavigationView {
            List {
                ForEach(animals, id: \.self) { animal in
                    Text(animal)
                }.onDelete(perform: removeAnimal)
            }
        }.navigationBarItems(trailing: EditButton())
        .navigationBarTitle(Text(&quot;EditButtonView&quot;), displayMode: .inline)
    }
    
    func removeAnimal(at offsets: IndexSet){
        animals.remove(atOffsets: offsets)
    }
}
</code></pre><p>最终得到，点击右上角的Edit按钮，List会进入编辑状态。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxmpcje8g3j305k0bedfr.jpg" alt="20211222164221"/></p><ol start="9"><li>打开<strong>MenuButtonView.swift</strong>， 添加以下代码</li></ol><pre><code class="language-swift">var body: some View {
    Text(&quot;MenuButtons are currently available on MacOS currently&quot;)
  .padding()
  .navigationBarTitle(&quot;MenuButtons&quot;, displayMode:.inline)

/*
MenuButton(&quot;country +&quot;) {
Button(&quot;USA&quot;) { print(&quot;Selected USA&quot;) }.background(Color.accentColor)
Button(&quot;India&quot;) { print(&quot;Selected India&quot;) }
}
*/
}

</code></pre><ol start="10"><li>打开<strong>PasteButtonView.swift</strong>，添加以下代码</li></ol><pre><code class="language-swift">struct PasteButtonView: View {
    var body: some View {
        VStack {
            Text(&quot;PasteButton controls how you paste in macOS but is not available in iOS. For more information, check the \&quot;See also\&quot; section of this recipe&quot;)
                .padding()
        }.navigationBarTitle(&quot;PasteButton&quot;, displayMode: .inline)
    }
}
</code></pre><h2>How it works…</h2><p><strong>NavigationLink</strong>必须放在<strong>NavigationView</strong>里使用。</p><p> <strong>NavigationLink</strong> 需要两个参数<strong>destination</strong> 和 <strong>label</strong>。<strong>destination</strong>代表点击后跳转的View。<strong>label</strong>代表显示的内容。</p><p><code>.navigationBarTitle</code>modifier给ContentView界面添加了个title。第一个参数指定title的内容，第二个参数指定title显示的模式。.inline代表在标准的navigationBar中显示。</p><p>其他几个界面也有指定<code>.navigationBarTitle</code>，但是在preview中不会显示，在运行时才会显示。</p><p><strong>EditButton</strong>和<strong>List</strong>一起使用，让List可编辑。我们之后再学习List。</p><p><strong>MenuButtons</strong>和<strong>PasteButtons</strong>只能在macOS中使用。MenuButtons已被弃用，可以不用看了。</p><p>PasteButton可参考官方文档中的例子。</p><h2>API详情</h2><h3>Button</h3><h4>Creating a Button</h4><pre><code class="language-swift">// action是点击时触发的方法， label控制显示内容
init(action: @escaping () -&gt; Void, label: () -&gt; Label)
init(_ titleKey: LocalizedStringKey, action: @escaping () -&gt; Void)
</code></pre><h4>Creating a Button with a Role</h4><pre><code class="language-swift">//多了个ButtonRole，用于描述Button语意，SwiftUI会根据语意添加样式，比如取消，是红色的。
init(role: ButtonRole?, action: @escaping () -&gt; Void, label: () -&gt; Label)
</code></pre><h4>Creating a Button from a Configuration</h4><pre><code class="language-swift">///通过config初始化
init(_ configuration: PrimitiveButtonStyleConfiguration)
</code></pre><h4>Setting a Border Shape</h4><pre><code class="language-swift">///设置border样式，
// capsule : 胶囊形状，  rounded rectangle： 圆角矩形，可自定义圆角大小
func buttonBorderShape(_ shape: ButtonBorderShape) -&gt; some View
</code></pre><h4>Styling Button Appearance</h4><pre><code class="language-swift">/// 设置样式，创建自定义样式
func buttonStyle&lt;S&gt;(_ style: S) -&gt; some View where S : ButtonStyle
</code></pre><p>举个例子</p><pre><code class="language-swift">struct RedborderStyle: PrimitiveButtonStyle {
    func makeBody(configuration: Configuration) -&gt; some View {
        configuration.label.padding().border(Color.red)
    }
}

struct ButtonView: View {
    var body: some View {
        Button(&quot;你好&quot;) {
            print(&quot;hello&quot;)
        }.buttonStyle(RedborderStyle())
    }
}
</code></pre><h3>NavigationView</h3><p>用于创建类似于UINavigationController的导航。</p><h4>Creating a Navigation View</h4><pre><code class="language-swift">init(content: () -&gt; Content)
</code></pre><h4>Styling Navigation Views</h4><pre><code class="language-swift">func navigationViewStyle&lt;S&gt;(_ style: S) -&gt; some View where S : NavigationViewStyle
</code></pre><h4>Adding Titles</h4><pre><code class="language-swift">//导航栏标题
func navigationTitle(_ titleKey: LocalizedStringKey) -&gt; some View
//subtitle，只有macOS才有
func navigationSubtitle&lt;S&gt;(_ subtitle: S) -&gt; some View where S : StringProtocol
...
</code></pre><h4>Managing Navigation Bars</h4><pre><code class="language-swift">//隐藏navigationbar
func navigationBarHidden(_ hidden: Bool) -&gt; some View
func navigationBarBackButtonHidden(_ hidesBackButton: Bool) -&gt; some View
///显示模式，inline: 正常大小导航栏居中， large：大的导航栏，居左
func navigationBarTitleDisplayMode(_ displayMode: NavigationBarItem.TitleDisplayMode) -&gt; some View
</code></pre><h3>NavigationLink</h3><p>控制navigation跳转的view。点击后会跳转到destination。当然除了，手动触发，也能够通过代码触发跳转。代码跳转有两种方式，一种是通过isActive，一种是通过tag+selection。</p><h4>Presenting a Destination View</h4><pre><code class="language-swift">init(destination: () -&gt; Destination, label: () -&gt; Label)
init&lt;S&gt;(_ title: S, destination: () -&gt; Destination) where S : StringProtocol
</code></pre><h4>Presenting a Destination View with Programmatic Activation</h4><pre><code class="language-swift">///提供isActive，这样可以通过代码来跳转
init&lt;S&gt;(_ title: S, isActive: Binding&lt;Bool&gt;, destination: () -&gt; Destination) where S : StringProtocol
...
</code></pre><p>举个例子, 下面的点击两个按钮都能跳转到对应View。</p><pre><code class="language-swift">struct ContentView: View {
    @State var showEditBtnScreen = false
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: EditButtonView(), isActive: $showEditBtnScreen) {
                    Text(&quot;EditButtons&quot;).padding()
                }
                Button(&quot;设置active跳转&quot;) {
                    showEditBtnScreen = true
                }
            }.navigationBarTitle(Text(&quot;Main View&quot;), displayMode: .inline)
        }
    }
}
</code></pre><h4>Presenting a Selectable Destination View</h4><pre><code class="language-swift">///通过给每个Link一个tag，然后通过设置selection为对应tag，控制跳转
init&lt;S, V&gt;(_ title: S, tag: V, selection: Binding&lt;V?&gt;, destination: () -&gt; Destination) where S : StringProtocol, V : Hashable
...
</code></pre><p>举个例子</p><pre><code class="language-swift">struct ContentView: View {
    enum Screens {
        case editButtonScreen
        case memuButtonScreen
    }    
    @State var currentScreen: Screens?
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: EditButtonView(), tag: Screens.editButtonScreen, selection: $currentScreen) {
                    Text(&quot;EditButtons&quot;).padding()
                }
                NavigationLink(destination: MenuButtonView(), tag: Screens.memuButtonScreen, selection: $currentScreen) {
                    Text(&quot;MenuButtons&quot;).padding()
                }
                Button(&quot;设置selection跳转&quot;) {
                    currentScreen = .memuButtonScreen
                }
            }.navigationBarTitle(Text(&quot;Main View&quot;), displayMode: .inline)
        }
    }
}
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SwiftUI专辑003-使用Image]]></title>
        <id>/2021/11/06/SwiftUI专辑-003-使用Image</id>
        <link href="https://gouxin.fun/2021/11/06/SwiftUI专辑-003-使用Image"/>
        <updated>2021-11-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerimg]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
这一章，我们将介绍如何添加Image到View中。</p><h2>Getting ready</h2><p>新建一个SwiftUI工程，叫做<strong>ImageApp</strong></p><h2>How to do it…</h2><p>首先让我们添加一些图片到Assert中，然后我们再介绍一些modifier来修改图片样式。</p><ol><li>替换Text为VStack</li><li>从<a href="https://github.com/PacktPublishing/SwiftUI-Cookbook-2nd-Edition/tree/main/Resources/Chapter01/recipe3%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87">https://github.com/PacktPublishing/SwiftUI-Cookbook-2nd-Edition/tree/main/Resources/Chapter01/recipe3下载图片</a></li><li>拖动图片到Asserts中</li><li>添加一个<code>Image</code>到<code>VStack中</code></li></ol><pre><code class="language-swift">Image(&quot;dogs1&quot;)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlubi8eadj30d40ou3zy.jpg" alt="image-20211221224926711"/></p><ol start="5"><li>添加一个<code>.resizable()</code>modifier, 他能让SwiftUI调整图片大小以适应可以用空间。</li></ol><pre><code class="language-swift">Image(&quot;dogs1&quot;)
.resizable()
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlucuqitnj30cy0ootae.jpg" alt="image-20211221225044534"/></p><ol start="6"><li>我们看到图片被压缩了，继续添加一个<code>.aspectRatio</code></li></ol><pre><code class="language-swift">Image(&quot;dogs1&quot;)
    .resizable()
    .aspectRatio(contentMode: .fit)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlufwjo2cj30cc0o8dgm.jpg" alt="image-20211221225341902"/></p><ol start="7"><li>继续添加 <strong>dog-and-nature</strong>到<code>VStack</code>中</li></ol><pre><code class="language-swift">Image(&quot;dog-and-nature&quot;)
    .resizable()
    .aspectRatio(contentMode: .fit)
    .frame(width:300, height:200)
    .clipShape(Circle())
    .overlay(Circle().stroke(Color.blue, lineWidth: 6))
    .shadow(radius: 10)
</code></pre><ol start="8"><li>我们写个工具方法来获取UIImage</li></ol><pre><code class="language-swift">func getImageFromUIImage(image:String) -&gt; UIImage {
    guard let img = UIImage(named: image) else {
        fatalError(&quot;Unable to load image&quot;)
    }
    return img
}
</code></pre><ol start="9"><li>然后使用UIImage来加载图片</li></ol><pre><code class="language-swift">Image(uiImage: getImageFromUIImage(image:&quot;dog2&quot;))
    .resizable()
    .frame(width: 200, height: 200)
    .aspectRatio(contentMode: .fit)
</code></pre><ol start="10"><li>最终效果</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlumbs7t0j30cq0pa0u9.jpg" alt="image-20211221225942417"/></p><h2>How it works…</h2><p>添加<code>Image</code>到View上时，<code>Image</code>默认显示原始尺寸。图片可能大了，也可能小了。</p><p>要让<code>Image</code>适应屏幕大小，我们需要添加<code>.resizable</code>modifier。这会让<code>Image</code>缩放以占满可用空间。</p><p>为了解决缩放的拉伸问题，我们可以使用<code>.aspectRatio</code>modifier。</p><p>但aspectFill时，图片可能超出范围，我们可以用<code>.clip()</code>裁减掉</p><p>如果我们要限制图片大小固定为某个值，可以使用<code>.frame</code>modifier。</p><p>如果想裁剪图片为某个形状，可以使用<code>.clipShape</code>modifier。</p><p>我们还可以使用<code>.overlay</code>和<code>.shadow</code>来添加边框和阴影。</p><p>注意modifer的顺序比较重要，不同顺序的组合可能得到不一样的结果。</p><h2>Image</h2><p>我们可以中资源中创建Image</p><ul><li>从bundle中的资源文件创建</li><li>从UIImage/NSImage创建</li><li>从CGImage创建</li><li>从SF Symbols创建</li></ul><h3>Creating an Image</h3><pre><code class="language-swift">//通过name初始化，bundle为nil默认为main bundle
init(_ name: String, bundle: Bundle? = nil)

</code></pre><h3>Creating an Image for Use as a Control</h3><pre><code class="language-swift">//和上面的类似， label用作accessibility
init(_ name: String, bundle: Bundle? = nil, label: Text)
init(_ cgImage: CGImage, scale: CGFloat, orientation: Image.Orientation = .up, label: Text)
</code></pre><h3>Creating an Image for Decorative Use</h3><pre><code class="language-swift">///创建装饰性的image，不会有accessibility
init(decorative name: String, bundle: Bundle? = nil)
init(decorative cgImage: CGImage, scale: CGFloat, orientation: Image.Orientation = .up)
</code></pre><h3>Creating a System Symbol Image</h3><pre><code class="language-swift">init(systemName: String)
</code></pre><h3>Creating an Image from a System Representation</h3><pre><code class="language-swift">///通过平台对应的Image初始化
init(uiImage: UIImage)
init(nsImage: NSImage)
</code></pre><h3>Resizing and Scaling Images</h3><pre><code class="language-swift">/// 拉伸，EdgeInsets中间的区域不拉伸，四周拉伸，ResizingMode制定了拉伸方式
func resizable(capInsets: EdgeInsets = EdgeInsets(), resizingMode: Image.ResizingMode = .stretch) -&gt; Image
</code></pre><h3>Specifying Image Rendering Behavior</h3><pre><code class="language-swift">///设置symble image的render方式
func symbolRenderingMode(_ mode: SymbolRenderingMode?) -&gt; Image
//两种mode: original:图片本色 temple: 将所有不透明的颜色渲染为forgroundColor。
func renderingMode(_ renderingMode: Image.TemplateRenderingMode?) -&gt; Image
///渲染那种需要插值的图片，指定插值质量
func interpolation(_ interpolation: Image.Interpolation) -&gt; Image
///是否开启反锯齿
func antialiased(_ isAntialiased: Bool) -&gt; Image
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlvhx2yyuj30yq0jqwgq.jpg" alt="image-20211221233014594"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SwiftUI专辑002-处理文本]]></title>
        <id>/2021/11/05/SwiftUI专辑-002-处理文本</id>
        <link href="https://gouxin.fun/2021/11/05/SwiftUI专辑-002-处理文本"/>
        <updated>2021-11-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerimg]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
文本是任何App的一个基础。
本章我们将介绍：</p><ul><li><strong>Text</strong></li><li><strong>TextField</strong></li><li><strong>SecureField</strong></li><li><strong>TextEditor</strong></li></ul><h2>准备</h2><p>创建一个名为<strong>FormattedText</strong>的新 SwiftUI 项目。</p><h2>怎么做…</h2><p>首先将Text用VStack包裹一下</p><pre><code class="language-swift">struct ContentView: View {
var body: some View {
        VStack{
            Text(&quot;Hello World&quot;)
        }
    }
}
</code></pre><p>然后添加一个fontWeight modifier。</p><pre><code class="language-swift">Text(&quot;Hello World&quot;).fontWeight(.medium)
</code></pre><p>添加两个个state</p><pre><code class="language-swift">@State var password = &quot;&quot;
@State var someText = &quot;&quot;
</code></pre><p>添加一个Text和SecureField, 用Text显示SecureField的输入</p><pre><code class="language-swift">SecureField(&quot;Enter a password&quot;, text: $password).padding()
Text(&quot;password entered: \(password)&quot;).italic()
</code></pre><p>添加一个Text和TextField，用Text显示TextField的输入</p><pre><code class="language-swift">TextField(&quot;Enter some text&quot;, text: $someText).padding()
Text(&quot;\(someText)&quot;).font(.largeTitle).underline()
</code></pre><p>再尝试一下其他modifier</p><pre><code class="language-swift">Text(&quot;Changing text color and make it bold&quot;).foregroundColor(Color.blue).bold()
Text(&quot;Use kerning to change space between lines of text&quot;).kerning(7)
Text(&quot;Changing baseline offset&quot;).baselineOffset(100)
Text(&quot;Strikethrough&quot;).strikethrough()
Text(&quot;This is a multiline text implemented in SwiftUI. The trailing modifier was added to the text. This text also implements multiple modifiers&quot;)
    .background(Color.yellow)
    .multilineTextAlignment(.trailing)
    .lineSpacing(10)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj3txyjzfj30cu0qgjsg.jpg" alt="image-20211219140147411"/></p><h2>How it works…</h2><p>Text有关于font，spacing等相关的Modifier。TextFiled和SecureField都需要一个<code>State</code>来存储输入，我们可以使用<code>@State</code>来声明一个<code>State</code>。SwiftUI会在<code>State</code>改变时，自动刷新UI。</p><p>我们通过$来绑定<code>State</code>。</p><pre><code class="language-swift">  TextField(&quot;Enter some text&quot;, text: $someText)     
</code></pre><h2>There&#x27;s more…</h2><p>我们继续添加Text，当子视图超过10个时，就会报错。原来是SwiftUI只支持最大10个子视图。所以此时，我们需要使用<code>Group</code>来分割我们的子视图。</p><h2>详细介绍</h2><h3>Text</h3><p>用于显示1行或者多行的只读文本。</p><h4>Creating a Text View from a String</h4><pre><code class="language-swift">//国际化
init(_ key: LocalizedStringKey, tableName: String? = nil, bundle: Bundle? = nil, comment: StaticString? = nil)
//普通字符串，无国际化
init&lt;S&gt;(_ content: S) where S : StringProtocol
//富文本
init(_ attributedContent: AttributedString)
</code></pre><h4>Creating a Text View for a Date</h4><pre><code class="language-swift">// 显示某个时间范围3:09-3.10 PM
init(_ dates: ClosedRange&lt;Date&gt;)
init(_ interval: DateInterval)
// 显示日期, 按照style
init(_ date: Date, style: Text.DateStyle)
</code></pre><h4>Creating a Text View with Formatting</h4><p>显示非string对象, 需要你的type遵循FormatStyle协议。</p><pre><code class="language-swift">init&lt;F&gt;(_ input: F.FormatInput, format: F) where F : FormatStyle, F.FormatInput : Equatable, F.FormatOutput == String
init&lt;Subject&gt;(_ subject: Subject, formatter: Formatter) where Subject : ReferenceConvertible
init&lt;Subject&gt;(_ subject: Subject, formatter: Formatter) where Subject : NSObject
</code></pre><p>我们也可以实现自己的formater。比如我们要格式化日期为yyyy-MM-dd。但默认Date.FormatStyle提供的似乎不够用，我们可以实现自己的formater。</p><pre><code class="language-swift">struct YYYYMMddDateStyle: FormatStyle {
    typealias FormatInput = Date
    typealias FormatOutput = String
    
    static let dateFormater: DateFormatter = {
        let formater = DateFormatter()
        formater.dateFormat = &quot;yyyy-MM-dd&quot;
        return formater
    }()
    func format(_ value: Date) -&gt; String {
        return YYYYMMddDateStyle.dateFormater.string(from: value)
    }
}
/// 扩展一下FormatStyle，这样就有提示了
extension FormatStyle where Self == YYYYMMddDateStyle {
    static var yyyyMMddDateStyle:YYYYMMddDateStyle { return .init() }
}

//使用
struct ContentView: View {
    var body: some View {
        Text.init(Date(), format: .yyyyMMddDateStyle)
    }
}
</code></pre><h4>Creating a Text View from an Image</h4><p>将图片包裹为Text，适合和其他Text拼接。</p><pre><code class="language-swift">init(_ image: Image)
</code></pre><p>例子:</p><pre><code class="language-swift">struct ContentView: View {
    @State var password = &quot;&quot;
    @State var someText = &quot;Initial text&quot;
    var body: some View {
            Text(&quot;hello&quot;) + Text(Image(&quot;my-img-name&quot;)) + Text(&quot;world&quot;)
    }
}            
</code></pre><h4>Choosing a Font</h4><p>字体相关：</p><pre><code class="language-swift">func font(Font?) -&gt; Text
func fontWeight(Font.Weight?) -&gt; Text
</code></pre><h4>Styling the View’s Text</h4><p>文本样式</p><pre><code class="language-swift">func foregroundColor(Color?) -&gt; Text
func bold() -&gt; Text
func italic() -&gt; Text
func strikethrough(Bool, color: Color?) -&gt; Text
func underline(Bool, color: Color?) -&gt; Text
func monospacedDigit() -&gt; Text
func kerning(CGFloat) -&gt; Text
func tracking(CGFloat) -&gt; Text
func baselineOffset(CGFloat) -&gt; Text
func textCase(Text.Case?) -&gt; some View
</code></pre><h4>Fitting Text into Available Space</h4><p>缩放相关:</p><pre><code class="language-swift">func allowsTightening(Bool) -&gt; some View//是否允许缩放两个字符间的间距
func minimumScaleFactor(CGFloat) -&gt; some View//缩放字体
func truncationMode(Text.TruncationMode) -&gt; some View//截断
</code></pre><h4>Handling Multiline Text</h4><p>处理多行文本</p><pre><code class="language-swift">func lineLimit(Int?) -&gt; some View
func lineSpacing(CGFloat) -&gt; some View
func multilineTextAlignment(TextAlignment) -&gt; some View
</code></pre><h4>其他</h4><p>还有些voiceover和accessbility相关的功能，可以暂时忽略</p><h3>TextField</h3><p>输入框。</p><h4>Creating a Text Field with a String Value</h4><p>textfield和string绑定。需要3个东西： title, binding和prompt。</p><pre><code class="language-swift">init(_ titleKey: LocalizedStringKey, text: Binding&lt;String&gt;, prompt: Text?)
init&lt;S&gt;(_ title: S, text: Binding&lt;String&gt;, prompt: Text?) where S : StringProtocol
init(text: Binding&lt;String&gt;, prompt: Text? = nil, label: () -&gt; Label)
</code></pre><p>注意title和prompt的区别。</p><pre><code class="language-swift">Form {
    TextField(text: $username, prompt: Text(&quot;Required&quot;)) {
        Text(&quot;Username&quot;)
    }
    SecureField(text: $password, prompt: Text(&quot;Required&quot;)) {
        Text(&quot;Password&quot;)
    }
}
</code></pre><p>在macOS上：前面的文字是title/label。placeholder是prompt。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj9ltz1ppj30qi05m74e.jpg" alt="image-20211219172142715"/></p><p>在ios上，不会单独显示label，如果提供了prompt，则用prompt作为placeholder，没有提供则用title/label作为placeholder。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj9nghei6j30og094q2x.jpg" alt="image-20211219172316635"/></p><h4>Creating a Text Field with an Arbitrary Value</h4><p>TextField并不一定只能binding到String，可以Binding到任何类型，只是需要一个ParseableFormatStyle 或者 Formatter。</p><pre><code class="language-swift">init&lt;F&gt;(_ titleKey: LocalizedStringKey, value: Binding&lt;F.FormatInput&gt;, format: F, prompt: Text? = nil) where F : ParseableFormatStyle, F.FormatOutput == String
init&lt;S, F&gt;(_ title: S, value: Binding&lt;F.FormatInput&gt;, format: F, prompt: Text? = nil) where S : StringProtocol, F : ParseableFormatStyle, F.FormatOutput == String
init&lt;F&gt;(value: Binding&lt;F.FormatInput&gt;, format: F, prompt: Text? = nil, label: () -&gt; Label) where F : ParseableFormatStyle, F.FormatOutput == String
init&lt;V&gt;(_ titleKey: LocalizedStringKey, value: Binding&lt;V&gt;, formatter: Formatter, prompt: Text?)
init&lt;S, V&gt;(_ title: S, value: Binding&lt;V&gt;, formatter: Formatter, prompt: Text?) where S : StringProtocol
init&lt;V&gt;(value: Binding&lt;V&gt;, formatter: Formatter, prompt: Text? = nil, label: () -&gt; Label)
</code></pre><p>我们来举个例子，将一个Person绑定到TextField。TextField显示<code>firstName lastName</code>。</p><p>先定义Person</p><pre><code class="language-swift">struct Person {
    var firstName = &quot;&quot;
    var lastName = &quot;&quot;
}
</code></pre><p>定义解析策略，负责将String解析成Person</p><pre><code class="language-swift">/// 解析，负责将string解析成自定义类型
struct PersonParseStrategy: ParseStrategy {
    typealias ParseInput = String
    typealias ParseOutput = Person
    func parse(_ value: String) throws -&gt; Person {
        var components = value.components(separatedBy: &quot; &quot;)
        if components.isEmpty {
            return Person()
        } else if components.count == 1 {
            return Person(firstName: components[0], lastName: &quot;&quot;)
        } else {
            let firstName = components[0]
            components.removeFirst()
            let lastName = components.joined(separator: &quot; &quot;)
            return Person(firstName: firstName, lastName: lastName)
        }
    }
}
</code></pre><p>定义FormatStyle，负责将Person格式化为String</p><pre><code class="language-swift">/// formater, 负责将自定义类型解析成textfield的显示
struct PersonNameFormatStyle: ParseableFormatStyle {
    typealias Strategy = PersonParseStrategy
    typealias FormatInput = Person
    typealias FormatOutput = String
    var parseStrategy = PersonParseStrategy()
    func format(_ value: Person) -&gt; String {
        return &quot;\(value.firstName) \(value.lastName)&quot;
    }
}
@available(iOS 15.0, *)
extension ParseableFormatStyle where Self == PersonNameFormatStyle {
    static var personNameFormatStyle: PersonNameFormatStyle { .init() }
}
</code></pre><p>使用</p><pre><code class="language-swift">struct ContentView: View {
    @State var person = Person()
    var body: some View {
    TextField(&quot;请输入姓名&quot;, value: $person, format: .personNameFormatStyle, prompt: nil)
        Text(&quot;firstName:\(person.firstName) lastName:\(person.lastName)&quot;)
    }
}       
</code></pre><h4>Creating a Text Field with an Arbitrary Optional</h4><p>和上面的类似，只是支持Optional</p><pre><code class="language-swift">init&lt;F&gt;(_ titleKey: LocalizedStringKey, value: Binding&lt;F.FormatInput?&gt;, format: F, prompt: Text? = nil) where F : ParseableFormatStyle, F.FormatOutput == String
....省略
</code></pre><h4>Styling Text Fields</h4><p>设置text field的style</p><pre><code class="language-swift">func textFieldStyle&lt;S&gt;(_ style: S) -&gt; some View where S : TextFieldStyle
</code></pre><p>举例</p><pre><code class="language-swift">TextField(&quot;请输入姓名&quot;, value: $person, format: .personNameFormatStyle, prompt: nil)
.textFieldStyle(.roundedBorder)
</code></pre><h4>常用的UITextFieldDelegate对比</h4><p>.editingChanged</p><pre><code class="language-swift">TextField(&quot;&quot;, text: $password)
   .onChange(of: password) { newValue in
        password = Format(password)
   }
</code></pre><p>.editingDidBegin / .editingDidEnd</p><pre><code>@FocusState var isFocused: Bool
TextField(&quot;&quot;, text: $password)
    .focused($isFocused)                
    .onChange(of: isFocused) { newValue in
       print(&quot;current foucus state \(newValue)&quot;)
    }
</code></pre><p>textShouldReturn</p><pre><code class="language-swift">TextField(&quot;&quot;, text: $password)
   .onSubmit {
       print(&quot;clicked return btn&quot;)
   }
</code></pre><h3>SecureField</h3><p>只能binding到string，不能像TextField一样可以绑定任何值。</p><p>没有显示真实输入密码的功能。要实现眼睛功能，只有用TextField和SecureField一起。</p><h4>Creating a Secure Text Field</h4><p>和texfiled类似</p><pre><code class="language-swift">init&lt;S&gt;(_ title: S, text: Binding&lt;String&gt;, prompt: Text?) where S : StringProtocol
</code></pre><h4>Configuring Text Entry</h4><pre><code class="language-swift">func keyboardType(_ type: UIKeyboardType) -&gt; some View //键盘类型
func disableAutocorrection(_ disable: Bool?) -&gt; some View //自动修正
func textInputAutocapitalization(_ autocapitalization: TextInputAutocapitalization?) -&gt; some View //自动首字母大小写
//设置文本类型，系统会根据类型为输入提供建议
func textContentType(_ textContentType: UITextContentType?) -&gt; some View
</code></pre><h3>TextEditor</h3><p>显示和编辑多行较长的文本</p><h4>Creating a Text Editor</h4><pre><code class="language-swift">init(text: Binding&lt;String&gt;)
</code></pre><h4>Styling the View’s Text</h4><pre><code class="language-swift">func font(_ font: Font?) -&gt; some View
func foregroundColor(_ color: Color?) -&gt; some View
func multilineTextAlignment(_ alignment: TextAlignment) -&gt; some View
func lineSpacing(_ lineSpacing: CGFloat) -&gt; some View
func allowsTightening(_ flag: Bool) -&gt; some View
</code></pre><h4>Managing Text Entry</h4><pre><code class="language-swift">func textInputAutocapitalization(_ autocapitalization: TextInputAutocapitalization?) -&gt; some View
func disableAutocorrection(_ disable: Bool?) -&gt; some View
func keyboardType(_ type: UIKeyboardType) -&gt; some View
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SwiftUI专辑001-layout相关控件]]></title>
        <id>/2021/11/04/SwiftUI专辑-001-layout相关控件</id>
        <link href="https://gouxin.fun/2021/11/04/SwiftUI专辑-001-layout相关控件"/>
        <updated>2021-11-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerimg]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本文将介绍用于布局相关的一些控件</p><ul><li>VStack</li><li>HStack</li><li>ZStack</li><li>Spacer</li><li>Divider</li></ul><h2>准备</h2><p>先创建一个叫做<code>TheStacks</code>的SwiftUI工程。</p><h2>写代码</h2><p>修改ContentView里的body为以下代码, 然后resume Preview：</p><pre><code class="language-swift">VStack {
            Text(&quot;VStack Item 1&quot;)
            Text(&quot;VStack Item 2&quot;)
            Text(&quot;VStack Item 3&quot;)
        }.background(Color.blue)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9ytz8862j302s05h3yb.jpg" alt="008i3skNly1gx9ys9dvjmj30do0qwmxn"/></p><p>然后我们在添加一些Divider和Spacer。</p><pre><code class="language-swift">VStack {
            Text(&quot;VStack Item 1&quot;)
            Text(&quot;VStack Item 2&quot;)
            Spacer()
            Divider().background(Color.white)
            Text(&quot;VStack Item 3&quot;)            
        }.background(Color.blue)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9z4p6o9kj304608it8l.jpg" alt="image-20211211162833693"/></p><p>我们再在<code>item 3</code>之后加一个HStack和ZStack。</p><pre><code class="language-swift">VStack {
            Text(&quot;VStack Item 1&quot;)
            Text(&quot;VStack Item 2&quot;)
            Spacer()
            Divider().background(Color.white)
            Text(&quot;VStack Item 3&quot;)
            HStack {
                Text(&quot;Item 1&quot;)
                Divider().background(Color.black)
                Text(&quot;HStack Item 2&quot;)
                Divider().background(Color.black)
                Spacer()
                Text(&quot;HStack Item 3&quot;)
            }.background(Color.red)
            ZStack {
                Text(&quot;ZStack Item 1&quot;).padding().background(Color.green).opacity(0.8)
                Text(&quot;ZStack Item 2&quot;).padding().background(Color.green).offset(x: 80, y: -400)
            }
        }.background(Color.blue)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9za4cl4zj305k0b8mx9.jpg" alt="截屏2021-12-11 下午4.33.17"/></p><h2>这是怎么工作的？</h2><p>一个新的SwiftUI工程默认是以一个居中的Text开始的。</p><p><code>body</code>返回一个<code>View</code>。</p><p>如果要添加竖直排列的其他View，我们用VStack替换掉默认的Text，然后添加内容。</p><p>SwiftUI的Stack使用如下步骤来决定如何显示它的内容(详细可参考WWDC2019:利用SwiftUI构建自定义视图)：</p><ol><li>Figure out its internal spacing and subtract that from the size proposed by its parent view.(确定子视图的大小，从父视图提供的大小中减去子视图)</li><li>Divide the remaining space into equal parts.(将剩余空间按剩余子视图数量等分)</li><li>Process the size of its least flexible view.(处理 least flexibl的视图，确定其大小)</li><li>Divide the remaining unclaimed space by the unallocated space, and then repeat <em>Step 2</em>.（用剩余空间减去其大小，再重复步骤2）</li><li>The stack then aligns its content and chooses its own size to exactly enclose its children.( stack对其他的内容，确定其自身大小，其大小是刚好包裹子视图)</li></ol><p>添加<strong>Spacer</strong>可以强制View使用最大的空间。这是因为<strong>Spacer()</strong>是最flexible的视图，它在显示所有其他视图之后填充剩余空间。</p><p><strong>Divider</strong>用来画一个占满parent宽度的水平线，这也是为什么我们加了<strong>Divider</strong>后，蓝色背景会撑满屏幕宽度。默认<strong>Divider</strong>没有颜色，我们可以通过<code>.background(Color)</code>modifier来设置。</p><p>modifier是一系列可以应用到View上的方法，换句话说：他将某些改动设置到View上，然后返回新的View。</p><p>常用的<strong>.background(Color. black)</strong>, <strong>.padding()</strong>, and <strong>.offsets(…)</strong>都是modifier。</p><p><strong>HStack</strong>和<strong>VStack</strong>类似，不过他是水平从左到右显示他的内容。添加<strong>Spacer</strong>到<strong>HStack</strong>中，会让它填满水平空白区域，<strong>Divider</strong>也是竖直向下的。</p><p><strong>ZStack</strong>和<strong>HStack</strong> 、 <strong>VStack</strong> 类似，不过是重叠他的content在已有的item上。</p><h2>There&#x27;s more…</h2><p>你还可以使用<strong>.frame</strong> modifier来调整component的width和height。</p><pre><code class="language-swift">.frame(
  maxWidth: .infinity,
    maxHeight: .infinity,
    alignment: .topLeading
)
</code></pre><h2>SwiftUI 中布局的工作原理</h2><p>详细可参考WWDC2019:利用SwiftUI构建自定义视图</p><h3>Hello world布局</h3><p>我们先来看一个Hello world的例子。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfshsh127j30zc0jqjsj.jpg" alt="image-20211216171253892"/></p><p>这里有3个View：</p><ul><li>Text: 大小由文本决定</li><li>ContentView：大小由children决定，所以上图中ContentView的大小刚好包裹Text</li><li>RootView：屏幕减去safeArea的区域，你可以通过<code>.edgesIgnoringSafeArea(.all)</code>modifier来修改这个行为，这样就是整个屏幕。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfsmiww1yj30z40juabb.jpg" alt="image-20211216171729871"/></p><p>我们把任何带有<code>var body: some View</code>的视图成为<code>中性视图(Layout Neutral)</code>，他的边界是由他的<code>body</code>决定的，因此我们上面才说ContentView的大小和Text是一致的。</p><p>我们再来看看布局过程：</p><ul><li>RootView：嘿，我有整个安全区域那么大，你需要多大的空间？</li><li>ContentView：好的，但是我是中性视图，我得问下我的body。Text你好，我有整个安全区域那么大，你需要多少空间？</li><li>Text：好的，我的文本是Helloworld，我只需要100 * 20那么大。</li><li>ContentView：好的，我是中性视图，你多大我就多大，RootView，我只需要100 * 20那么大。</li><li>RootView：好的，我还有很多剩余空间，我默认会把你放到我的center那里。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxftfq527nj30z80jyjsz.jpg" alt="image-20211216174533016"/></p><p>总结下布局过程：</p><ol><li>Parent为children提供一个size</li><li>Children确定自己的大小</li><li>Parent将children放到自己的坐标系中</li><li>屏幕像素是整数，但大小是小数，处理小数大小，会round到最近的整数</li></ol><h3>更复杂的例子</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxftngd4c6j30ze0jmdh9.jpg" alt="image-20211216175258340"/></p><ul><li>RootView：嘿，我有整个安全区域那么大，你需要多大的空间？</li><li>Toast：好的，但是我是中性视图，我得问下我的body。Background你好，我有整个安全区域那么大，你需要多少空间？</li><li>Background: 好的，但是我也是中性视图。Padding你好，我有整个安全区域那么大，你需要多少空间？</li><li>Padding：好的。Text你好，我有整个安全区域减去10 padding那么多空间，你需要多少空间？</li><li>Text：我需要100* 100 。</li><li>Padding: 好的, Background，我只需要110* 110</li><li>Background: 好的，我还有子视图Color，我得问下他，Color你好，我有110 * 110, 那么大，你需要多少。</li><li>Color：我也需要110 * 110</li><li>Background：好的，Toast，我只需要110 *110</li><li>Toast: 好的,RootView，我也只需要110* 110</li><li>RootView: 好的，我还有很多剩余空间，我默认会把你放到我的center那里。</li></ul><h3>再来一个简单但重要的例子</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfu70mnauj30yo0jkaau.jpg" alt="image-20211216181143533"/></p><p>SwiftUI中除非你指定图片是可缩放的，否则图片的size就是图片本身的大小。</p><p>现在我想让图片是30x30，我们加个frame modifier。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfu8csg25j30yq0j8myk.jpg" alt="image-20211216181304205"/></p><p>你会在图片周围发现一个30x30的框，这和我们刚刚说的图片大小不可改矛盾了么？</p><p>frame并不是约束，而是modifier，modifier返回的是一个新的view。所以你加了frame modifier后，30x30实际上是新的view。Image还是20x20。</p><h3>再看看Stack的布局原理</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfugngw30j30yw0jadhj.jpg" alt="image-20211216182102883"/></p><p>我们首先得注意到，SwiftUI并不是直接吧Stack堆砌在一起，而是在他们之间留有adaptive space。这是SwiftUI将apple 人性化设计指南的一些规则默认应用到了SwiftUI的结果，他们希望你能通过最简单的代码，也能产生漂亮的结果。如果你不希望有这些space，可以在Stack初始化的参数中指定spacing为0。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuirdcufj30yo0ig0u2.jpg" alt="image-20211216182304331"/></p><pre><code class="language-swift">VStack(spacing: 0) {
            Text(&quot;hello world111&quot;).background(Color.red)
            Image(&quot;question-circle&quot;).background(Color.green)
        }
</code></pre><p>现在我们来分析下Stack是如何工作的？我们看个例子。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuo84px1j30yu0ja0u9.jpg" alt="image-20211216182819005"/></p><ol><li>首先Parent告诉HStack建议的size</li><li>HStack先减去spacing(如果没指定，是有默认space的，上面说过)，得到剩余空间<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfurqbo6vj30gq06g3yi.jpg" alt="image-20211216183141238"/></li><li>因为HStack有3个children，所以将剩余空间3等分<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuswb3oxj30eu06eweh.jpg" alt="image-20211216183248259"/></li><li>找出least flexible的子视图，其中图片是least flexible的，因为他的size是固定的。所以剩余空间减去图片size<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuw0e4s0j30f605sdfu.jpg" alt="image-20211216183548332"/></li><li>重复上面过程。目前有2个children。所以2等分<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuwzhgh5j30ek0680ss.jpg" alt="image-20211216183644570"/></li><li>两个优先级一样，因此处理第一个，先把一半的size分配给<code>Delicious</code>。但<code>Delicious</code>说，太多了，我要不了这么多，我只要这么多size。<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfv27t0v9j30de058dfv.jpg" alt="image-20211216184145585"/></li><li>再重复上面的过程，得到最新的剩余空间<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfv3agfbhj30gm05q3yk.jpg" alt="image-20211216184248523"/></li><li>把剩下的所有空间分配给<code>Avocado Toast</code>。<code>Avocado Toast</code>说，太多了，我用不完这么多空间。于是<code>Avocado Toast</code>刚好能显示完，整个HStack的size会比Parent提供的小一些。</li><li>水平方向的size确定了，然后确定竖直方向的。竖直方向按照HStack的<code>alignment</code>参数对其，然后size刚好能包裹整个Hstack。</li><li>至此整个Hstack的大小就完全确定了。</li></ol><p>再来看看，如果第8步中剩余空间不够<code>Avocado Toast</code>显示了，那么<code>Avocado Toast</code>会被截断</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfvc8au0yj30fa05eq32.jpg" alt="image-20211216185124090"/></p><p>但是如果我们想尽可能不截断<code>Avocado Toast</code>,优先截断<code>Delicios</code>，要怎么做呢？我们可以指定优先级。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfvfor138j30g0094q36.jpg" alt="image-20211216185442941"/></p><p>在有优先级的情况下，SwiftUI会先给所有低优先级的视图预留最小size，然后把剩余空间分配给高优先级视图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfvhkjb9qj30fg07w0sw.jpg" alt="image-20211216185632384"/></p><h3>Alignment</h3><h4>alignmentGuide</h4><p>还记得我们第9步中说到<code>alignment</code>么？这里再多说一点其中的基线对其<code>lastTextBaseline</code>。有时候我们可能对默认基线对其不满意， 我们可以通过<code>alignmentGuide</code>自定义对其位置:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfvr2ju9hj30xo0hejtx.jpg" alt="image-20211216190539364"/></p><p><code>.alignmentGuide(.lastTextBaseline) { d in d[.bottom] * 0.975 }</code>的意思是对于<code>lastTextBaseline</code>这种对其方式，他的对其位置是在<code>.bottom</code>的0.927处</p><h4>自定义对其方式</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfw0hw2bxj30mg05gt8x.jpg" alt="image-20211216191443420"/></p><p>考虑下我们要将星星，和<code>Avocado Toast</code>对其。啥？他们不是在两个不同的VStack中么？没关系我们可以自定义对其方式，让他们对其。</p><p>首先，自定义一种对其方式<code>midStartAndTitle</code>：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfw3fdbzoj30re0ekwfx.jpg" alt="image-20211216191732259"/></p><p>使用新的对其方式</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfwc8fjwmj30xu0iy40z.jpg" alt="image-20211216192559807"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个简单的StringKeyChain]]></title>
        <id>/2021/11/03/一个简单的StringKeyChain</id>
        <link href="https://gouxin.fun/2021/11/03/一个简单的StringKeyChain"/>
        <updated>2021-11-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerimg]]></summary>
        <content type="html"><![CDATA[<p><img src="./B6086038-32F7-48AE-AC07-DBAE5C0F21D7.png" alt="headerimg"/></p><p>一个简单的<code>StringKeyChain</code>封装，存储/获取字符串到keychain中。通常用于生成设备的唯一id。</p><pre><code class="language-swift">class StringKeyChain {
    static func save(value: String, key: String) {
        let data = value.data(using: .utf8)!
        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,
                                    kSecAttrAccount as String: key,
                                    kSecValueData as String: data]
        SecItemDelete(query as CFDictionary)
        let status = SecItemAdd(query as CFDictionary, nil)
        if status != errSecSuccess {
            print(&quot;keychain save error&quot;)
        }
    }

    static func getValue(key: String) -&gt; String? {
        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,
                                    kSecAttrAccount as String: key,
//                                    kSecAttrService as String: key,
//                                    kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlock,
                                    kSecMatchLimit as String: kSecMatchLimitOne,
                                    kSecReturnData as String: kCFBooleanTrue!]

        var retrivedData: AnyObject?

        _ = SecItemCopyMatching(query as CFDictionary, &amp;retrivedData)

        guard let data = retrivedData as? Data else { return nil }
        return String(data: data, encoding: .utf8)
    }
}


</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用XcodeKit编写一个XcodeExtension?]]></title>
        <id>/2021/11/02/如何用XcodeKit编写一个XcodeExtension</id>
        <link href="https://gouxin.fun/2021/11/02/如何用XcodeKit编写一个XcodeExtension"/>
        <updated>2021-11-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[HEADer]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="HEADer"/>
Xcode提供了XcodeKit，来允许我们编写Xcode的扩展。但是这个Extension功能有限，只能处理当前打开的文件的源码。
我们可以用来：格式化、自动生成代码等。
常用的Extension有XCFormat，可以格式化Swift和OC代码，可以在AppStore中下载。
整体开发插件的功能还是比较简单，我们从头演示一个移除一行开头的数字的插件。</p><h2>创建Xcode Extension工程</h2><h3>创建一个macOS工程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6clhtzij313a0do0u1.jpg" alt="image-20211129180100344"/></p><p>这个macOS工程，对应从App Store下载完Extension后，在桌面上生成的那个App。你可以在这个App中做Extension设置相关的界面。</p><h3>新建一个Xcode Source Editor Extention Target</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6l504ldj313y0cydh7.jpg" alt="截屏2021-11-29 下午6.09.11"/></p><h3>运行Extension Target</h3><p>点击运行Extension Target，选择Xcode，此时会打开一个灰色的Xcode。</p><p>打开我们的插件的macOS工程。</p><p>选择<code>Editor</code>菜单，底部就出现了我们的自定义菜单。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6wlndiej30tq05ct95.jpg" alt="image-20211129182015367"/></p><p>如果菜单没有出现，那么请修改一下Extension Target中XcodeKit的链接方式，选择<code>Embed &amp; Sign</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6xtzyhhj319u0k2gnk.jpg" alt="image-20211129182127182"/></p><h2>Xcode Source Editor Extention</h2><p>默认的<code>Xcode Source Editor Extention</code>会为你生成两个文件：</p><ul><li><code>SourceEditorExtension</code>:  这个文件定义你小菜单中的内容和extension启动时的回调。</li><li><code>SourceEditorCommand</code>: 是小菜单中的命令对应的实现类。</li></ul><h3>小菜单的定义</h3><p>小菜单的定义有两种方式，一种是通过<code>SourceEditorExtension</code>的代码定义。一种是通过<code>Info.plist</code>定义。代码定义的优先级更高，会覆盖Info.plist中的定义。</p><h4>在Info.plist中定义</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww78nx1j2j318i0ceq5g.jpg" alt="image-20211129183151859"/></p><p>每个命令就是小菜单中的一个命令对应。</p><ul><li>XCSourceEditorCommandClassName： 这个命令对应的实现类。格式是moduleName + 实现类的类名： <code>$(PRODUCT_MODULE_NAME).YourImplClassName</code>。</li><li>XCSourceEditorCommandIdentifier：你的这个命令的一个唯一id。格式是bundleId +一个字符串： <code>$(PRODUCT_BUNDLE_IDENTIFIER).SourceEditorCommand</code></li><li>XCSourceEditorCommandName：菜单中出现的命令的名字</li></ul><h4>在SourceEditorExtension中定义小菜单</h4><pre><code class="language-swift">class SourceEditorExtension: NSObject, XCSourceEditorExtension {
    
    /*
    func extensionDidFinishLaunching() {
        // If your extension needs to do any work at launch, implement this optional method.
    }
    */
    
    
    var commandDefinitions: [[XCSourceEditorCommandDefinitionKey: Any]] {
        // If your extension needs to return a collection of command definitions that differs from those in its Info.plist, implement this optional property getter.
        let command: [XCSourceEditorCommandDefinitionKey: Any] = [
            //格式moduleName.命令实现类的类名
            .classNameKey: &quot;GxEditorToolsExtension.SourceEditorCommand&quot;,
            //格式bundleId.自定义字符串
            .identifierKey: &quot;com.haixue.GxXcodeEditorTools.GxEditorToolsExtension.removeLinePrefixNum&quot;,
            //自定义名称
            .nameKey: &quot;我的小菜单&quot;
        ]
        return [command]
    }
    
}

</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww7hohzb6j30ok05gaag.jpg" alt="image-20211129184031347"/></p><h3>命令的实现</h3><p>实现类都遵循<code>XCSourceEditorCommand</code>协议。</p><p>当我们点击小菜单，会通过command的<code>XCSourceEditorCommandClassName</code>找到对应的实现类。调用实现类的<code>func perform(...)</code>方法。</p><p>我们看到新建项目默认为我们生成了一个command模板SourceEditorCommand。</p><pre><code class="language-swift">class SourceEditorCommand: NSObject, XCSourceEditorCommand {
    
    func perform(with invocation: XCSourceEditorCommandInvocation, completionHandler: @escaping (Error?) -&gt; Void ) -&gt; Void {
        // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.
        
        completionHandler(nil)
    }
    
}
</code></pre><h3>实现我们自己的命令</h3><pre><code class="language-swift">import Foundation
import XcodeKit

class RemoveLinePrefixNumCommand: NSObject, XCSourceEditorCommand {
    
    func perform(with invocation: XCSourceEditorCommandInvocation, completionHandler: @escaping (Error?) -&gt; Void ) -&gt; Void {
        // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.
        let lines = invocation.buffer.lines
        let result = lines.map { &quot;\($0)&quot; }.map{ self.removePrefixNum(str: $0) }
        invocation.buffer.lines.removeAllObjects()
        invocation.buffer.lines.addObjects(from: result)        
        completionHandler(nil)
    }
    
    func removePrefixNum(str: String) -&gt; String {
        var chars: [Character] = []
        //空格和数字
        let sets: Set&lt;Character&gt; = [&quot; &quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]
        var shouldCheck = true
        for c in str {
            if shouldCheck {
                if sets.contains(c) {
                    chars.append(&quot; &quot;)
                } else {
                    chars.append(c)
                    shouldCheck = false
                }
            } else{
                chars.append(c)
            }
        }
        return String(chars)
    }
}

</code></pre><pre><code class="language-objective-c">//可以看到invocation有用的也只有一个Buffer对象
@interface XCSourceEditorCommandInvocation : NSObject
/** The identifier of the command the user invoked. */
@property (readonly, copy) NSString *commandIdentifier;
/** The buffer of source text on which the command can operate. */
@property (readonly, strong) XCSourceTextBuffer *buffer;
@property (copy) void (^cancellationHandler)(void);
@end
</code></pre><pre><code class="language-objective-c">///buffer，又只能操作tab、lines、selections。
@interface XCSourceTextBuffer : NSObject

@property (readonly, copy) NSString *contentUTI;
@property (readonly) NSInteger tabWidth;
@property (readonly) NSInteger indentationWidth;
@property (readonly) BOOL usesTabsForIndentation;

@property (readonly, strong) NSMutableArray &lt;NSString *&gt; *lines;
@property (readonly, strong) NSMutableArray &lt;XCSourceTextRange *&gt; *selections;
@property (copy) NSString *completeBuffer;
@end
</code></pre><p>xcodeKit只能操作文本，像语法解析等都得借助别的工具来实现。</p><h3>调试</h3><p>在工程中打上断点，点击运行。</p><p>在灰色xcode中打开我们工程，点击小菜单。就会进入我们断点。</p><h3>集成到Xcode的Editor菜单</h3><p>进入<strong>系统偏好设置</strong>--<strong>扩展</strong>，选中我们的插件钩上即可</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwwg9umm74j30xw0oc0uo.jpg" alt="image-20211129234423601"/></p><h3>制作安装包</h3><p><code>archive</code> ，然后选择copy app，得到一个.app</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwghg4w4tj311q0lydgo.jpg" alt="image-20211129235140936"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwgj43el5j30t20jsac5.jpg" alt="image-20211129235317200"/></p><p>新建一个文件夹，将.app和应用程序的提升文件一起放入，重命名提升文件为Application。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwgkqyjeaj30f405s3yh.jpg" alt="image-20211129235452152"/></p><p>打开磁盘工具</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwglezhl6j30li0ti75q.jpg" alt="image-20211129235529816"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwglrcau8j30v4084ab6.jpg" alt="image-20211129235549564"/></p><p>选择刚刚的文件夹，就制作成了dmg。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何查看iOS、iPadOS系统版本占比？]]></title>
        <id>/2021/11/01/如何查看ios和ipados当前系统版本占比</id>
        <link href="https://gouxin.fun/2021/11/01/如何查看ios和ipados当前系统版本占比"/>
        <updated>2021-11-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[header]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="header"/>
每当开始新项目的时候，我们都得决定应该把最低系统版本设置为多少，此时，我们都希望能有个参考，市场上的系统版本的占比究竟是多少？
苹果官网有一个最近3个系统版本的占比统计，我们可以参考一下。</p><h2>官网占比统计</h2><p><a href="https://developer.apple.com/support/app-store/">官网统计页面</a></p><p><img src="./iOS_and_iPadOS_usage.png" alt="iOS_and_iPadOS_usage"/></p><p>可以看到统计时间是2021年6月3日，</p><p>iphone</p><ul><li><p>近四年的设备中已有98%到iOS13以上。</p></li><li><p>所有设备中93%已经到iOS13以上。</p></li></ul><p>iPad</p><ul><li>近四年的设备中已有99%到iOS13以上。</li><li>所有设备中88%已经到iOS13以上。</li></ul><h2>常用App的最低版本</h2><p>我们再去appstore中看下免费App排行榜设置的最低版本是多少。</p><table><thead><tr><th>App名称</th><th>兼容性</th></tr></thead><tbody><tr><td>国家反诈中心</td><td>iOS10</td></tr><tr><td>微信</td><td>iOS12</td></tr><tr><td>抖音</td><td>iOS10</td></tr><tr><td>QQ</td><td>iOS9</td></tr><tr><td>支付宝</td><td>iOS9</td></tr><tr><td>拼多多</td><td>iOS9</td></tr><tr><td>淘宝</td><td>iOS9</td></tr><tr><td>百度</td><td>iOS10</td></tr><tr><td>美团</td><td>iOS10</td></tr><tr><td>剪映</td><td>iOS11</td></tr><tr><td>高德地图</td><td>iOS10</td></tr><tr><td>小红书</td><td>iOS10</td></tr><tr><td>得物</td><td>iOS10</td></tr><tr><td>快手极速版</td><td>iOS9</td></tr><tr><td>快手</td><td>iOS10</td></tr><tr><td>抖音极速版</td><td>iOS10</td></tr><tr><td>腾讯视频</td><td>iOS10</td></tr><tr><td>咸鱼</td><td>iOS9</td></tr><tr><td>京东</td><td>iOS9</td></tr><tr><td>钉钉</td><td>iOS10</td></tr><tr><td>酷狗音乐</td><td>iOS9</td></tr><tr><td>优酷</td><td>iOS10</td></tr><tr><td>QQ音乐</td><td>iOS9</td></tr><tr><td>网易云音乐</td><td>iOS11</td></tr><tr><td>哔哩哔哩</td><td>iOS9</td></tr><tr><td>爱奇艺</td><td>iOS10</td></tr><tr><td>Soul</td><td>iOS11</td></tr><tr><td>知乎</td><td>iOS11</td></tr><tr><td>今日头条</td><td>iOS10</td></tr><tr><td>虎牙直播</td><td>iOS10</td></tr><tr><td>探探</td><td>iOS11</td></tr><tr><td>。。。</td><td></td></tr></tbody></table><p>可以看到主流是iOS10。iOS11也呈现出增多的趋势。微信竟然直接是iOS12。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Xcode13的Info.plist不见了?]]></title>
        <id>/2021/10/31/Xcode13的Info.plist不见了</id>
        <link href="https://gouxin.fun/2021/10/31/Xcode13的Info.plist不见了"/>
        <updated>2021-10-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Header]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="Header"/>
创建新的SwiftUI项目，发现Info.plist不见了？</p><p>哦~~~，原来是Xcode13引起的。</p><p>查看<a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-13-release-notes">Xcode13 Release Note</a>，可以看到</p><blockquote><p>Projects created from several templates no longer require configuration files such as entitlements and <code>Info.plist</code> files. Configure common fields in the target’s Info tab, and build settings in the project editor. These files are added to the project when additional fields are used. (68254857)</p></blockquote><p>原来新的模板不在创建Info.plist了，Info.plist的功能转移到<code>Target-&gt;Info</code>下了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3pltcx9j311o0oyjub.jpg" alt="image-20211124115621173"/></p><p>在Info中修改相关设置。如果你添加了一个自定义Key，那么系统会帮你创建一个Info.plist来包含你的自定义key-value。</p><p>你也可以自己直接新建。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3p3sf3lj319g05agm4.jpg" alt="image-20211124115550252"/></p><p>非SwiftUI项目中还是存在Info.plist，但是大部分内容还是都移动到了<code>Target-&gt;Info</code>中。Info.plist只保留了部分Key-Value。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3sea29cj316g0dcwg7.jpg" alt="image-20211124115901894"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[appstore截图尺寸规范设置]]></title>
        <id>/2021/10/30/appstore截图尺寸规范</id>
        <link href="https://gouxin.fun/2021/10/30/appstore截图尺寸规范"/>
        <updated>2021-10-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerImg]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="headerImg"/></p><p>上架AppStore时需要传各种机型的预览图片。这里记录一下官方文档，方便UI问你尺寸时给出准确的尺寸。</p><h2>官方链接</h2><p><a href="https://help.apple.com/app-store-connect/#/devd274dd925">https://help.apple.com/app-store-connect/#/devd274dd925</a></p><h2>至少提供的尺寸</h2><p>至少需要提供6.5、5.5、12.9英寸的截图。</p><p>5.8的可以复用6.5的。</p><p>3.5、4、4.7的可以复用5.5的</p><p>ipad复用12.9的</p><h2>截屏规范</h2><table><thead><tr><th align="left">设备尺寸或平台</th><th align="left">截屏尺寸</th><th align="left">要求</th><th align="left">截屏源</th></tr></thead><tbody><tr><td align="left">6.5 英寸：iPhone 13 Pro Max、iPhone 12 Pro Max、iPhone 11 Pro Max，iPhone 11、iPhone XS Max、iPhone XR</td><td align="left">1284 x 2778 像素（竖屏）2778 x 1284 像素（横屏）1242 x 2688 像素（竖屏）2688 x 1242 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，则此项为必需项。</td><td align="left">上传 6.5 英寸截屏</td></tr><tr><td align="left">5.8 英寸：iPhone 13 Pro、iPhone 13、iPhone 13 mini、iPhone 12 Pro、iPhone 12、iPhone 12 mini、iPhone 11 Pro、iPhone XS、iPhone X</td><td align="left">1170 x 2532 像素（竖屏）2532 x 1170 像素（横屏）1125 x 2436 像素（竖屏）2436 x 1125 像素（横屏）1080 x 2340 像素（竖屏）2340 x 1080 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 6.5 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 6.5 英寸截屏可选：上传 5.8 英寸截屏</td></tr><tr><td align="left">5.5 英寸：iPhone 8 Plus、iPhone 7 Plus、iPhone 6s Plus</td><td align="left">1242 x 2208 像素（竖屏）2208 x 1242 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，则此项为必需项。</td><td align="left">上传 5.5 英寸截屏</td></tr><tr><td align="left">4.7 英寸：iPhone SE（第 2 代）、iPhone 8、iPhone 7、iPhone 6s、iPhone 6</td><td align="left">750 x 1334 像素（竖屏）1334 x 750 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸截屏可选：上传 4.7 英寸截屏</td></tr><tr><td align="left">4 英寸：iPhone SE（第 1 代）</td><td align="left">640 x 1096 像素（竖屏，不含状态栏）640 x 1136 像素（竖屏，含状态栏）1136 x 600 像素（横屏，不含状态栏）1136 x 640 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸或 4.7 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸或 4.7 英寸截屏可选：上传 4 英寸截屏</td></tr><tr><td align="left">3.5 英寸：iPhone 4s</td><td align="left">640 x 920 像素（竖屏，不含状态栏）640 x 960 像素（竖屏，含状态栏）960 x 600 像素（横屏，不含状态栏）960 x 640 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸 iPhone 截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸、4.7 英寸或 4 英寸截屏可选：上传 3.5 英寸截屏</td></tr><tr><td align="left">12.9 英寸：iPad Pro（第 4 代、第 3 代）</td><td align="left">2048 x 2732 像素（竖屏）2732 x 2048 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，则此项为必需项。</td><td align="left">上传适用于 12.9 英寸 iPad Pro（第 3 代）的截屏</td></tr><tr><td align="left">12.9 英寸：iPad Pro（第 2 代）</td><td align="left">2048 x 2732 像素（竖屏）2732 x 2048 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，则此项为必需项。</td><td align="left">上传适用于 12.9 英寸 iPad Pro（第 2 代）的截屏</td></tr><tr><td align="left">11 英寸：iPad Pro、iPad Air（第 4 代）、iPad mini（第 6 代）</td><td align="left">1488 x 2266 像素（竖屏）2266 x 1488 像素（横屏）1668 x 2388 像素（竖屏）2388 x 1668 像素（横屏）1640 x 2360 像素（竖屏）2360 x 1640 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 3 代）的缩小版截屏可选：上传 11 英寸截屏</td></tr><tr><td align="left">10.5 英寸：iPad（第 9 代、第 8 代、第 7 代）、iPad Pro、iPad Air</td><td align="left">1668 x 2224 像素（竖屏）2224 x 1668 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 2 代）的缩小版截屏可选：上传 10.5 英寸截屏</td></tr><tr><td align="left">9.7 英寸：iPad、iPad mini</td><td align="left">1536 x 2008 像素（竖屏，不含状态栏）1536 x 2048 像素（竖屏，含状态栏）2048 x 1496 像素（横屏，不含状态栏）2048 x 1536 像素（横屏，含状态栏）768 x 1004 像素（竖屏，不含状态栏）768 x 1024 像素（竖屏，含状态栏）1024 x 748 像素（横屏，不含状态栏）1024 x 768 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）或 10.5 英寸的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 2 代）的缩小版截屏或缩小版 10.5 英寸截屏可选：上传 9.7 英寸截屏</td></tr><tr><td align="left">Mac</td><td align="left">宽高比须为 16:10，以下尺寸均可： 1280 x 800 像素1440 x 900 像素2560 x 1600 像素2880 x 1800 像素</td><td align="left">对于 Mac App 为必需项。</td><td align="left">以任一所列尺寸上传的 Mac 的截屏</td></tr><tr><td align="left">Apple TV</td><td align="left">1920 x 1080 像素3840 x 2160 像素</td><td align="left">对于 Apple TV App 为必需项。</td><td align="left">以任一所列尺寸上传的 Apple TV 截屏</td></tr><tr><td align="left">Apple Watch：Series 7、Series 6、Series 5、Series 4、Series 3、SE</td><td align="left">396 x 484 像素（Series 7）368 x 448 像素（Series 6、Series 5、Series 4、SE）312 x 390 像素（Series 3）</td><td align="left">对于 Apple Watch App 为必需项。</td><td align="left">以任一所列尺寸上传的 Apple Watch 截屏</td></tr></tbody></table><h2>App 内活动媒体素材规范</h2><table><thead><tr><th align="left">媒体类型</th><th align="left">支持的扩展名</th><th align="left">宽高比</th><th align="left">最小尺寸／分辨率</th><th align="left">最大尺寸／分辨率</th></tr></thead><tbody><tr><td align="left">活动卡片图像</td><td align="left">.jpg、.jpeg、.png</td><td align="left">16 : 9</td><td align="left">1920 x 1080 像素</td><td align="left">3840 x 2160 像素</td></tr><tr><td align="left">活动卡片视频</td><td align="left">.mov、.m4v、.mp4</td><td align="left">16 : 9</td><td align="left">1920 x 1080 像素 30 fps 或 60 fps</td><td align="left">3840 x 2160 像素 30 fps 或 60 fps</td></tr><tr><td align="left">活动详情页面图像</td><td align="left">.jpg、.jpeg、.png</td><td align="left">9 : 16</td><td align="left">1080 x 1920 像素</td><td align="left">2160 x 3840 像素</td></tr><tr><td align="left">活动详情页面视频</td><td align="left">.mov、.m4v、.mp4</td><td align="left">9 : 16</td><td align="left">1080 x 1920 像素 30 fps 或 60 fps</td><td align="left">2160 x 3840 像素 30 fps 或 60 fps</td></tr></tbody></table>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[推流分辨率码率设置]]></title>
        <id>/2021/10/29/推流码率设置</id>
        <link href="https://gouxin.fun/2021/10/29/推流码率设置"/>
        <updated>2021-10-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Header]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="Header"/></p><p>做直播始终离不开分辨率和码率的设置。</p><p>这里记录下腾讯音视频sdk中对推流参数的设置建议。</p><h3>分辨率码率对应表</h3><table><thead><tr><th>分辨率</th><th>码率范围</th></tr></thead><tbody><tr><td>160 * 160</td><td>100Kbps ~ 150Kbps</td></tr><tr><td>270*270</td><td>200Kbps ~ 300Kbps</td></tr><tr><td>480*480</td><td>350Kbps ~ 525Kbps</td></tr><tr><td>320*240</td><td>250Kbps ~ 375Kbps</td></tr><tr><td>480*360</td><td>400Kbps ~ 600Kbps</td></tr><tr><td>640*480</td><td>600Kbps ~ 900Kbps</td></tr><tr><td>320*180</td><td>250Kbps ~ 400Kbps</td></tr><tr><td>480*270</td><td>350Kbps ~ 550Kbps</td></tr><tr><td>640*360</td><td>500Kbps ~ 900Kbps</td></tr><tr><td>960*540</td><td>800Kbps ~ 1500Kbps</td></tr><tr><td>1280*720</td><td>1000Kbps ~ 1800Kbps</td></tr><tr><td>1920*1080</td><td>2500Kbps ~ 3000Kbps</td></tr></tbody></table>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pod repo push使用总结]]></title>
        <id>/2021/10/28/pod-repo-push使用总结</id>
        <link href="https://gouxin.fun/2021/10/28/pod-repo-push使用总结"/>
        <updated>2021-10-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[90088193-C7B8-4466-9DB9-DE681F7BF357]]></summary>
        <content type="html"><![CDATA[<p><img src="./90088193-C7B8-4466-9DB9-DE681F7BF357.png" alt="90088193-C7B8-4466-9DB9-DE681F7BF357"/></p><p>我们在修改完lib库后的最后一步就是使用<code>pod repo push</code>，将新的版本推到仓库里。</p><p>可是有时候会遇到各种奇怪的问题，导致一直push不成功，这里总结下使用方式。</p><h3>使用方式</h3><pre><code class="language-shell">pod repo push &lt;仓库&gt; xxx.podspec
</code></pre><h3>使用pod lib lint检查</h3><p>在push前，我们最好使用<code>pod lib lint</code>检查一下，因为这个命令可以提前暴露出push时会遇到的问题。</p><h4>--allow-warnings</h4><p>最常用的选项，忽略警告</p><h4>--fail-fast</h4><p>建议加上，遇到error可以立马结束，这样就不用在很长很长的log里找到底是什么error。</p><h4>--no-subspecs</h4><p>如果有很多subspec，可以加上这个，能快点。</p><h4>--skip-import-validation</h4><p>跳过import校验。通常我们遇到下面的错误时，可以跳过对能否import的校验</p><pre><code class="language-shell"> - NOTE  | [iOS] xcodebuild:  ld: warning: ignoring file xxx/xx/x.a, missing required architecture x86_64 in file xxx/xx/
 - NOTE  | [iOS] xcodebuild:  ld: warning: ignoring file xxx/xx/x.a, missing required architecture i386 in file xxx/xx/
</code></pre><h4>--sources</h4><p>指定source，如果error是某个lib找不到，那么就通过这个指定这个lib的source, 可以指定多个，用逗号隔开。</p><pre><code class="language-shell">--sources=&quot;http://my-private/xxx/CocoapodsRepos.git,https://github.com/CocoaPods/Specs.git&quot;
</code></pre><h3>使用pod repo push</h3><p>一般能通过pod lib lint的，基本上push都没啥问题。不建议不lint直接push，因为push产生的Log会很长很长，如果遇到error将很难发现问题。一般常用的option：</p><h4>--allow-warnings</h4><p>最常用的选项，忽略警告</p><h4>--sources</h4><p>指定source，如果error是某个lib找不到，那么就通过这个指定这个lib的source, 可以指定多个，用逗号隔开。</p><h4>--skip-import-validation</h4><p>跳过import校验</p><h3>其他</h3><p>有时候还会遇到一些奇奇怪怪的问题。比如：能编译过，但是lint/push时都报compile Error，最后发现是RealReachability的header中会少一些宏定义，代码中又引用了这些宏，最终全部替换掉就能正常push。</p><p>总之，先lint，用<code>--fail-fast</code>尽快找到错误提示，完成修改。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flex-Layout]]></title>
        <id>/2021/10/27/Flex-Layout</id>
        <link href="https://gouxin.fun/2021/10/27/Flex-Layout"/>
        <updated>2021-10-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[193EADF1-38F8-4FAF-9335-A05209EC236A]]></summary>
        <content type="html"><![CDATA[<p><img src="./193EADF1-38F8-4FAF-9335-A05209EC236A.png" alt="193EADF1-38F8-4FAF-9335-A05209EC236A"/></p><h2>flex布局</h2><p>flex布局由两部分组成：flex container(弹性容器)和flex item(弹性元素)组成。</p><h2>Flex container</h2><p>你可以通过<code>display:flex</code> 或者 <code>display:inline-flex</code>，来将一个元素变成弹性容器。<code>display:flex</code>声明的是块级框， <code>display:inline-flex</code>声明的是行内块级框。</p><p>当你声明一个元素是flex container时，他的每个直接子元素都变成了一个flex item。</p><h3>排版原则</h3><p>将item按照justifycontent的设置依次<strong>沿着主轴</strong>排列,默认不换行。</p><p>如果换行的话，那么<strong>沿着交叉轴</strong>方向排列下一行。</p><h3>flex container的轴</h3><p>弹性容器有2个轴：主轴 和 交叉轴。</p><p><code>flex-direction</code>定义了主轴的方向，他的取值如下：</p><pre><code class="language-css">row: 水平书写方向
row-reverse: 与row相反
coulm: 垂直于主轴的书写方向
coulm-reverse:与coulm相反
</code></pre><p>那么交叉轴呢？交叉轴始终和主轴垂直，方向是这个方向的书写方向。</p><p>这里都是用的书写方向，而不是水平向右这类词汇，因为对于不同的书写方向row的方向也不同，比如：对于从右到左书写方向的，他的row是，从右到左。</p><p>知道了主轴和交叉轴方向后，弹性元素将沿着主轴方向布局，如果允许换行，那么新的一行沿着交叉轴方向排列。</p><h3>换行flex-wrap</h3><p>如果弹性元素在主轴方向上排列不下。默认是不会换行的，如果设置了shrink，那就缩小尺寸，否则将从边框溢出。</p><p>我们可以使用flex-wrap控制换行。他的值如下：</p><pre><code>nowrap: 不换行
wrap: 沿着交叉轴方向换行
wrap-reverse: 沿着交叉轴的反方向换行
</code></pre><h3>flex-direction和flex-wrap的简写</h3><p><code>flex-flow</code>是flex-direction和flex-wrap的简写</p><h3>控制空白的位置</h3><p>目前为止，我们知道flex item会沿着主轴方向进行排列，如果有多行，那么行沿着交叉轴方向排列，这也意味着如果一行没占满，留有空白，那么这个空白始终出现在主轴+交叉轴的方向那。</p><p>我们可以控制这个行为，下面是相关属性：</p><pre><code class="language-css">justify-content ：控制一行中，item在主轴方向上的布局方式(我个人更喜欢理解为空白的处理方式)
flex-start: item沿着主轴依次布局，（空白全在末尾）
flex-end:item沿着主轴反方向依次布局，（空白全在开头）
center: 把所有item作为一个整体居中布局。 (空白两侧等分)
space-between: 把每行第一个元素放在主轴起边， 最后一个元素放在主轴终边。然后余下的item的两侧放置等量空白, 如果没有多余空白，那么会把最后一个元素撑到外面去。
space-around: item两侧有等量的不折叠的空白。
space-evenly: 把剩余空白等分，和item依次排列。这也意味着第一个元素到主轴起边和最后一个元素到主轴终边的距离是一样的。
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2tjs3h9ij31400sf4ci.jpg" alt="图像"/></p><p>如果没有多余空白，页不允许换行，那么将溢出，justify-content对溢出也有影响</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2tp24qdrj313x0ot134.jpg" alt="图像"/></p><h3>一行中如何对齐元素</h3><p>上面justify-content的例子有点特殊，因为他们的item的高度都是相等的，以至于我们忽略了，如果item也有不同高度时的情况。</p><p>如果item有不同的高度，那么item在交叉轴方向上应该如何布局嘞？</p><p>他受下面的属性控制：</p><pre><code class="language-css">align-items : 定义一行中，item在交叉轴上的布局方式
flex-start: 沿着交叉轴起边对其
flex-end: 沿着交叉轴终边对其
center: 在一行中垂直居中对其
stretch: 全部拉伸填满交叉轴方向
baseline: 各个item基线对其
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2u1epaxhj30dz12gq8x.jpg" alt="图像"/></p><h3>交叉轴对齐方式覆盖</h3><p>刚刚讲了align-items是item在一行中交叉轴上的布局方式。但有时我们可能存在特异化需求，比如奇数位置上的item是flex-start, 偶数位置上是flex-end。</p><p><code>align-self</code>便是用于覆盖align-items属性的值，和align-items不同的是，align-self是声明在flex item上的，覆盖了flex container上的align-items属性。</p><p>由于是覆盖align-items，所以他的取值和align-items是一样的，作用也是一样的。</p><h3>多个行的布局方式</h3><p>如果允许换行，那么久可能出现多个行的情况，默认情况下，多个行是沿着交叉轴方向依次排列。但我们可以改变这个行为。</p><p><code>align-content</code>属性指定了交叉轴方向上的额外空间如何分配到各个行之间。</p><p>他的取值和justify-content类似，多了个stretch。</p><pre><code class="language-css">align-content: 
flex-start : 沿着交叉轴起边依次排列行,(空白在末尾)
flex-end : 沿着交叉轴终边开始依次排列行，(空白在开头)
center: 把各个行作为一个整体，居中排列
space-between: 第一行放在交叉轴起边，最后一行放在交叉轴终边，剩余空间等分和item依次排列
space-around: item两边有等量的不折叠的空白
space-evenly: item两边有等量空白
stretch: 等分空白，每一行拉伸等量空白空间。
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2ujy594dj30u00zp1kx.jpg" alt="图像"/></p><h2>Flex item</h2><p>刚刚我们说的除了align-self，其他都是应用在container上的属性。接下来，我们再看看应用在item上的属性。</p><p>除了align-self，还有flex, flex-grow, flex-shrink, flex-basis, order。</p><p>其中flex是flex-grow flex-shrink flex-basis的缩写。</p><p>我们可能遇到出现的结果和想象的不一样的情况，这个大多数有2个原因：</p><ol><li>对属性含义的误解</li><li>忽略各个情况下的默认值</li></ol><p>弹性元素还有：外边距不折叠的特性。float和clear对弹性元素不起作用。</p><p>Vertical-align对弹性元素没有作用，vertical-align是文本属性中的一员，用于控制文本在文本行框中的垂直方向上的对其方式。所以你item指定了vertical-align:bottom，那么只是item中的文本在文本行框中底部对齐，而不是把item推向container的底部。</p><p>绝对定位对item也有影响。如果某个item使用了绝对定位，那么这个item将从文档流移除，不会参与弹性布局。虽然他从文档流中移除了，但是justify-content和align-self还是会影响绝对定位元素。比如：align-self:center，那么绝对定位item会在弹性容器中交叉轴方向居中。</p><h3>Flex-basis</h3><p>含义：根据增长因子或者缩减因子分配多余或者缺少空间之前，弹性元素的大小。</p><p>不鼓励：单独使用，建议用flex简写</p><pre><code class="language-css">flex-basis:
auto: width ==&gt; min-width =&gt; content
&lt;length&gt;: 指定长度,比如200px
&lt;percentage&gt;: 百分比，相对于弹性container
</code></pre><p>注意：flex-basis的默认值是auto，但是如果你指定了flex属性，省略了flex-basis，那么flex-basis是0%。</p><h3>Flex-grow</h3><p>含义：有多余空间时是否允许增大，以及如何分配剩余空间。</p><p>不鼓励：单独使用，建议用flex简写</p><p>负数无效。</p><p>下面看看container宽750，有3个100px的item：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2w7s8g6fj30w20u01bu.jpg" alt="图像"/></p><p>如果我们换成flex:1, flex:1, flex:3呢？我们看到又是分配的全部空间，而不是剩余空间。为什么呢？这就和默认值有关了。</p><p>如果我们单独设flex-grow，没有设置flex，和flex-basis，那么这个时候flex-basis是auto。也就是在分配剩余空间前，item占用width的空间，所以得到剩余空间是450px。</p><p>如果指定了flex:1， 但是省略了flex-basis，那么flex-basis是0，也就是说在分配剩余空间前，item不占空间，3个item都不占空间，那么剩余空间就是整个空间的大小，所以看到的是按比例分配。</p><h3>Flex-shrink</h3><p>翻译：空间不够放置所有弹性元素，而且弹性容器不能增加尺寸也不允许换行时，如何分配“缺少空间”。</p><p>不鼓励：单独使用，建议用flex简写</p><p>那么如何分配呢？首先得计算出缩减比例，缩减比例不仅和shrink有关，还和item宽度有关。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2x0tya2wj30zv07c408.jpg" alt="图像"/></p><p>最终item的宽度为</p><p>120/(150 <em> 1 + 250 </em> 1+ 200 <em>1) </em> 1 </p><p>Width = itemWidth <em> shrink </em> 缩小比例。</p><h3>flex</h3><p>之前说了flex是flex-grow flex-shrink flex-basis的简写，推荐使用这个。</p><p>唯一需要注意的是他的默认值。省略flex-basis的话是0 而不是auto。</p><h3>order</h3><p>定义item的顺序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何为githubPage添加自定义域名]]></title>
        <id>/2021/10/26/如何为githubPage添加自定义域名</id>
        <link href="https://gouxin.fun/2021/10/26/如何为githubPage添加自定义域名"/>
        <updated>2021-10-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD]]></summary>
        <content type="html"><![CDATA[<p><img src="./68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD.png" alt="68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD"/></p><p>当我们把blog托管在github page上后，就能得到一个<code>&lt;userName&gt;.github.io</code>的域名。不过有点丑，没关系我们还可以用自己的域名。</p><h3>第一步：购买域名</h3><p>我是在阿里云上买的一个域名，购买完成后，进入<code>解析设置</code>， 然后添加记录。</p><p><img src="./23A6A5C1-68E6-4B1C-B56F-C962C574E897.png" alt="23A6A5C1-68E6-4B1C-B56F-C962C574E897"/></p><h5>添加一个CNAME记录</h5><p>记录类型：CNAME</p><p>主机记录：www</p><p>记录值:  xxx.github.io</p><h5>添加多个A记录</h5><p>参考<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">官方文档</a>, 添加多个A 和 AAAA</p><p>记录类型：A</p><p>主机记录：不填</p><p>记录值:  185.199.108.153</p><h3>第二步：修改仓库setting</h3><p><img src="./226E7E5E-6EE6-457B-85F9-CD1823B554ED.png" alt="226E7E5E-6EE6-457B-85F9-CD1823B554ED"/></p><p>Custom domain处填写你自己的域名，然后等一会github解析，成功后勾选<code>Enforce https</code>。</p><p>现在就可以访问新的。</p><h3>第三步：其他修改</h3><p>如果你使用像<code>docusaurus</code>这样的框架，那么还得修改config文件中的url和baseUrl。</p><pre><code class="language-json">{
  url: &#x27;https://gouxin.fun&#x27;,
  baseUrl: &#x27;/&#x27;,
}
</code></pre><p>然后你还会发现，每次deploy后custom domain都会被重置。我们还需要在static目录下加上CNAME文件，参考<a href="https://docusaurus.io/zh-CN/docs/deployment#docusaurusconfigjs-settings">https://docusaurus.io/zh-CN/docs/deployment#docusaurusconfigjs-settings</a></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客开张啦]]></title>
        <id>/2021/10/25/博客开张啦</id>
        <link href="https://gouxin.fun/2021/10/25/博客开张啦"/>
        <updated>2021-10-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[6DE1C549-029E-49E9-A79B-669B782FD675]]></summary>
        <content type="html"><![CDATA[<p><img src="./6DE1C549-029E-49E9-A79B-669B782FD675.png" alt="6DE1C549-029E-49E9-A79B-669B782FD675"/></p><p> 之前的blog在老电脑上，现在已经找不到了，有段时间没有写博客了。现在用<a href="https://docusaurus.io/">docusaurus</a>重新搭建自己的博客。相比于hexo，docusaurus使用React更灵活。</p><p>加油！加油！加油</p>]]></content>
    </entry>
</feed>
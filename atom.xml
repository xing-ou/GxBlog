<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gouxin.fun/</id>
    <title>Gx'sBlog Blog</title>
    <updated>2021-11-10T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gouxin.fun/"/>
    <subtitle>Gx'sBlog Blog</subtitle>
    <icon>https://gouxin.fun/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[一个简单的StringKeyChain]]></title>
        <id>一个简单的StringKeyChain</id>
        <link href="https://gouxin.fun/2021/11/10/一个简单的StringKeyChain"/>
        <updated>2021-11-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerimg]]></summary>
        <content type="html"><![CDATA[<p><img src="./B6086038-32F7-48AE-AC07-DBAE5C0F21D7.png" alt="headerimg"/></p><p>一个简单的<code>StringKeyChain</code>封装，存储/获取字符串到keychain中。通常用于生成设备的唯一id。</p><pre><code class="language-swift">class StringKeyChain {
    static func save(value: String, key: String) {
        let data = value.data(using: .utf8)!
        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,
                                    kSecAttrAccount as String: key,
                                    kSecValueData as String: data]
        SecItemDelete(query as CFDictionary)
        let status = SecItemAdd(query as CFDictionary, nil)
        if status != errSecSuccess {
            print(&quot;keychain save error&quot;)
        }
    }

    static func getValue(key: String) -&gt; String? {
        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,
                                    kSecAttrAccount as String: key,
//                                    kSecAttrService as String: key,
//                                    kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlock,
                                    kSecMatchLimit as String: kSecMatchLimitOne,
                                    kSecReturnData as String: kCFBooleanTrue!]

        var retrivedData: AnyObject?

        _ = SecItemCopyMatching(query as CFDictionary, &amp;retrivedData)

        guard let data = retrivedData as? Data else { return nil }
        return String(data: data, encoding: .utf8)
    }
}


</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用XcodeKit编写一个XcodeExtension?]]></title>
        <id>如何用XcodeKit编写一个XcodeExtension?</id>
        <link href="https://gouxin.fun/2021/11/02/如何用XcodeKit编写一个XcodeExtension"/>
        <updated>2021-11-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[HEADer]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="HEADer"/>
Xcode提供了XcodeKit，来允许我们编写Xcode的扩展。但是这个Extension功能有限，只能处理当前打开的文件的源码。
我们可以用来：格式化、自动生成代码等。
常用的Extension有XCFormat，可以格式化Swift和OC代码，可以在AppStore中下载。
整体开发插件的功能还是比较简单，我们从头演示一个移除一行开头的数字的插件。</p><h2>创建Xcode Extension工程</h2><h3>创建一个macOS工程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6clhtzij313a0do0u1.jpg" alt="image-20211129180100344"/></p><p>这个macOS工程，对应从App Store下载完Extension后，在桌面上生成的那个App。你可以在这个App中做Extension设置相关的界面。</p><h3>新建一个Xcode Source Editor Extention Target</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6l504ldj313y0cydh7.jpg" alt="截屏2021-11-29 下午6.09.11"/></p><h3>运行Extension Target</h3><p>点击运行Extension Target，选择Xcode，此时会打开一个灰色的Xcode。</p><p>打开我们的插件的macOS工程。</p><p>选择<code>Editor</code>菜单，底部就出现了我们的自定义菜单。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6wlndiej30tq05ct95.jpg" alt="image-20211129182015367"/></p><p>如果菜单没有出现，那么请修改一下Extension Target中XcodeKit的链接方式，选择<code>Embed &amp; Sign</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6xtzyhhj319u0k2gnk.jpg" alt="image-20211129182127182"/></p><h2>Xcode Source Editor Extention</h2><p>默认的<code>Xcode Source Editor Extention</code>会为你生成两个文件：</p><ul><li><code>SourceEditorExtension</code>:  这个文件定义你小菜单中的内容和extension启动时的回调。</li><li><code>SourceEditorCommand</code>: 是小菜单中的命令对应的实现类。</li></ul><h3>小菜单的定义</h3><p>小菜单的定义有两种方式，一种是通过<code>SourceEditorExtension</code>的代码定义。一种是通过<code>Info.plist</code>定义。代码定义的优先级更高，会覆盖Info.plist中的定义。</p><h4>在Info.plist中定义</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww78nx1j2j318i0ceq5g.jpg" alt="image-20211129183151859"/></p><p>每个命令就是小菜单中的一个命令对应。</p><ul><li>XCSourceEditorCommandClassName： 这个命令对应的实现类。格式是moduleName + 实现类的类名： <code>$(PRODUCT_MODULE_NAME).YourImplClassName</code>。</li><li>XCSourceEditorCommandIdentifier：你的这个命令的一个唯一id。格式是bundleId +一个字符串： <code>$(PRODUCT_BUNDLE_IDENTIFIER).SourceEditorCommand</code></li><li>XCSourceEditorCommandName：菜单中出现的命令的名字</li></ul><h4>在SourceEditorExtension中定义小菜单</h4><pre><code class="language-swift">class SourceEditorExtension: NSObject, XCSourceEditorExtension {
    
    /*
    func extensionDidFinishLaunching() {
        // If your extension needs to do any work at launch, implement this optional method.
    }
    */
    
    
    var commandDefinitions: [[XCSourceEditorCommandDefinitionKey: Any]] {
        // If your extension needs to return a collection of command definitions that differs from those in its Info.plist, implement this optional property getter.
        let command: [XCSourceEditorCommandDefinitionKey: Any] = [
            //格式moduleName.命令实现类的类名
            .classNameKey: &quot;GxEditorToolsExtension.SourceEditorCommand&quot;,
            //格式bundleId.自定义字符串
            .identifierKey: &quot;com.haixue.GxXcodeEditorTools.GxEditorToolsExtension.removeLinePrefixNum&quot;,
            //自定义名称
            .nameKey: &quot;我的小菜单&quot;
        ]
        return [command]
    }
    
}

</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww7hohzb6j30ok05gaag.jpg" alt="image-20211129184031347"/></p><h3>命令的实现</h3><p>实现类都遵循<code>XCSourceEditorCommand</code>协议。</p><p>当我们点击小菜单，会通过command的<code>XCSourceEditorCommandClassName</code>找到对应的实现类。调用实现类的<code>func perform(...)</code>方法。</p><p>我们看到新建项目默认为我们生成了一个command模板SourceEditorCommand。</p><pre><code class="language-swift">class SourceEditorCommand: NSObject, XCSourceEditorCommand {
    
    func perform(with invocation: XCSourceEditorCommandInvocation, completionHandler: @escaping (Error?) -&gt; Void ) -&gt; Void {
        // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.
        
        completionHandler(nil)
    }
    
}
</code></pre><h3>实现我们自己的命令</h3><pre><code class="language-swift">import Foundation
import XcodeKit

class RemoveLinePrefixNumCommand: NSObject, XCSourceEditorCommand {
    
    func perform(with invocation: XCSourceEditorCommandInvocation, completionHandler: @escaping (Error?) -&gt; Void ) -&gt; Void {
        // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.
        let lines = invocation.buffer.lines
        let result = lines.map { &quot;\($0)&quot; }.map{ self.removePrefixNum(str: $0) }
        invocation.buffer.lines.removeAllObjects()
        invocation.buffer.lines.addObjects(from: result)        
        completionHandler(nil)
    }
    
    func removePrefixNum(str: String) -&gt; String {
        var chars: [Character] = []
        //空格和数字
        let sets: Set&lt;Character&gt; = [&quot; &quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]
        var shouldCheck = true
        for c in str {
            if shouldCheck {
                if sets.contains(c) {
                    chars.append(&quot; &quot;)
                } else {
                    chars.append(c)
                    shouldCheck = false
                }
            } else{
                chars.append(c)
            }
        }
        return String(chars)
    }
}

</code></pre><pre><code class="language-objective-c">//可以看到invocation有用的也只有一个Buffer对象
@interface XCSourceEditorCommandInvocation : NSObject
/** The identifier of the command the user invoked. */
@property (readonly, copy) NSString *commandIdentifier;
/** The buffer of source text on which the command can operate. */
@property (readonly, strong) XCSourceTextBuffer *buffer;
@property (copy) void (^cancellationHandler)(void);
@end
</code></pre><pre><code class="language-objective-c">///buffer，又只能操作tab、lines、selections。
@interface XCSourceTextBuffer : NSObject

@property (readonly, copy) NSString *contentUTI;
@property (readonly) NSInteger tabWidth;
@property (readonly) NSInteger indentationWidth;
@property (readonly) BOOL usesTabsForIndentation;

@property (readonly, strong) NSMutableArray &lt;NSString *&gt; *lines;
@property (readonly, strong) NSMutableArray &lt;XCSourceTextRange *&gt; *selections;
@property (copy) NSString *completeBuffer;
@end
</code></pre><p>xcodeKit只能操作文本，像语法解析等都得借助别的工具来实现。</p><h3>调试</h3><p>在工程中打上断点，点击运行。</p><p>在灰色xcode中打开我们工程，点击小菜单。就会进入我们断点。</p><h3>集成到Xcode的Editor菜单</h3><p>进入<strong>系统偏好设置</strong>--<strong>扩展</strong>，选中我们的插件钩上即可</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwwg9umm74j30xw0oc0uo.jpg" alt="image-20211129234423601"/></p><h3>制作安装包</h3><p><code>archive</code> ，然后选择copy app，得到一个.app</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwghg4w4tj311q0lydgo.jpg" alt="image-20211129235140936"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwgj43el5j30t20jsac5.jpg" alt="image-20211129235317200"/></p><p>新建一个文件夹，将.app和应用程序的提升文件一起放入，重命名提升文件为Application。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwgkqyjeaj30f405s3yh.jpg" alt="image-20211129235452152"/></p><p>打开磁盘工具</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwglezhl6j30li0ti75q.jpg" alt="image-20211129235529816"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwglrcau8j30v4084ab6.jpg" alt="image-20211129235549564"/></p><p>选择刚刚的文件夹，就制作成了dmg。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何查看iOS、iPadOS系统版本占比？]]></title>
        <id>如何查看iOS、iPadOS系统版本占比？</id>
        <link href="https://gouxin.fun/2021/11/01/如何查看ios和ipados当前系统版本占比"/>
        <updated>2021-11-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[header]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="header"/>
每当开始新项目的时候，我们都得决定应该把最低系统版本设置为多少，此时，我们都希望能有个参考，市场上的系统版本的占比究竟是多少？
苹果官网有一个最近3个系统版本的占比统计，我们可以参考一下。</p><h2>官网占比统计</h2><p><a href="https://developer.apple.com/support/app-store/">官网统计页面</a></p><p><img src="./iOS_and_iPadOS_usage.png" alt="iOS_and_iPadOS_usage"/></p><p>可以看到统计时间是2021年6月3日，</p><p>iphone</p><ul><li><p>近四年的设备中已有98%到iOS13以上。</p></li><li><p>所有设备中93%已经到iOS13以上。</p></li></ul><p>iPad</p><ul><li>近四年的设备中已有99%到iOS13以上。</li><li>所有设备中88%已经到iOS13以上。</li></ul><h2>常用App的最低版本</h2><p>我们再去appstore中看下免费App排行榜设置的最低版本是多少。</p><table><thead><tr><th>App名称</th><th>兼容性</th></tr></thead><tbody><tr><td>国家反诈中心</td><td>iOS10</td></tr><tr><td>微信</td><td>iOS12</td></tr><tr><td>抖音</td><td>iOS10</td></tr><tr><td>QQ</td><td>iOS9</td></tr><tr><td>支付宝</td><td>iOS9</td></tr><tr><td>拼多多</td><td>iOS9</td></tr><tr><td>淘宝</td><td>iOS9</td></tr><tr><td>百度</td><td>iOS10</td></tr><tr><td>美团</td><td>iOS10</td></tr><tr><td>剪映</td><td>iOS11</td></tr><tr><td>高德地图</td><td>iOS10</td></tr><tr><td>小红书</td><td>iOS10</td></tr><tr><td>得物</td><td>iOS10</td></tr><tr><td>快手极速版</td><td>iOS9</td></tr><tr><td>快手</td><td>iOS10</td></tr><tr><td>抖音极速版</td><td>iOS10</td></tr><tr><td>腾讯视频</td><td>iOS10</td></tr><tr><td>咸鱼</td><td>iOS9</td></tr><tr><td>京东</td><td>iOS9</td></tr><tr><td>钉钉</td><td>iOS10</td></tr><tr><td>酷狗音乐</td><td>iOS9</td></tr><tr><td>优酷</td><td>iOS10</td></tr><tr><td>QQ音乐</td><td>iOS9</td></tr><tr><td>网易云音乐</td><td>iOS11</td></tr><tr><td>哔哩哔哩</td><td>iOS9</td></tr><tr><td>爱奇艺</td><td>iOS10</td></tr><tr><td>Soul</td><td>iOS11</td></tr><tr><td>知乎</td><td>iOS11</td></tr><tr><td>今日头条</td><td>iOS10</td></tr><tr><td>虎牙直播</td><td>iOS10</td></tr><tr><td>探探</td><td>iOS11</td></tr><tr><td>。。。</td><td></td></tr></tbody></table><p>可以看到主流是iOS10。iOS11也呈现出增多的趋势。微信竟然直接是iOS12。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Xcode13的Info.plist不见了?]]></title>
        <id>Xcode13的Info.plist不见了?</id>
        <link href="https://gouxin.fun/2021/10/31/Xcode13的Info.plist不见了"/>
        <updated>2021-10-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Header]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="Header"/>
创建新的SwiftUI项目，发现Info.plist不见了？</p><p>哦~~~，原来是Xcode13引起的。</p><p>查看<a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-13-release-notes">Xcode13 Release Note</a>，可以看到</p><blockquote><p>Projects created from several templates no longer require configuration files such as entitlements and <code>Info.plist</code> files. Configure common fields in the target’s Info tab, and build settings in the project editor. These files are added to the project when additional fields are used. (68254857)</p></blockquote><p>原来新的模板不在创建Info.plist了，Info.plist的功能转移到<code>Target-&gt;Info</code>下了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3pltcx9j311o0oyjub.jpg" alt="image-20211124115621173"/></p><p>在Info中修改相关设置。如果你添加了一个自定义Key，那么系统会帮你创建一个Info.plist来包含你的自定义key-value。</p><p>你也可以自己直接新建。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3p3sf3lj319g05agm4.jpg" alt="image-20211124115550252"/></p><p>非SwiftUI项目中还是存在Info.plist，但是大部分内容还是都移动到了<code>Target-&gt;Info</code>中。Info.plist只保留了部分Key-Value。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3sea29cj316g0dcwg7.jpg" alt="image-20211124115901894"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[appstore截图尺寸规范设置]]></title>
        <id>appstore截图尺寸规范设置</id>
        <link href="https://gouxin.fun/2021/10/30/appstore截图尺寸规范"/>
        <updated>2021-10-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[headerImg]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="headerImg"/></p><p>上架AppStore时需要传各种机型的预览图片。这里记录一下官方文档，方便UI问你尺寸时给出准确的尺寸。</p><h2>官方链接</h2><p><a href="https://help.apple.com/app-store-connect/#/devd274dd925">https://help.apple.com/app-store-connect/#/devd274dd925</a></p><h2>至少提供的尺寸</h2><p>至少需要提供6.5、5.5、12.9英寸的截图。</p><p>5.8的可以复用6.5的。</p><p>3.5、4、4.7的可以复用5.5的</p><p>ipad复用12.9的</p><h2>截屏规范</h2><table><thead><tr><th align="left">设备尺寸或平台</th><th align="left">截屏尺寸</th><th align="left">要求</th><th align="left">截屏源</th></tr></thead><tbody><tr><td align="left">6.5 英寸：iPhone 13 Pro Max、iPhone 12 Pro Max、iPhone 11 Pro Max，iPhone 11、iPhone XS Max、iPhone XR</td><td align="left">1284 x 2778 像素（竖屏）2778 x 1284 像素（横屏）1242 x 2688 像素（竖屏）2688 x 1242 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，则此项为必需项。</td><td align="left">上传 6.5 英寸截屏</td></tr><tr><td align="left">5.8 英寸：iPhone 13 Pro、iPhone 13、iPhone 13 mini、iPhone 12 Pro、iPhone 12、iPhone 12 mini、iPhone 11 Pro、iPhone XS、iPhone X</td><td align="left">1170 x 2532 像素（竖屏）2532 x 1170 像素（横屏）1125 x 2436 像素（竖屏）2436 x 1125 像素（横屏）1080 x 2340 像素（竖屏）2340 x 1080 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 6.5 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 6.5 英寸截屏可选：上传 5.8 英寸截屏</td></tr><tr><td align="left">5.5 英寸：iPhone 8 Plus、iPhone 7 Plus、iPhone 6s Plus</td><td align="left">1242 x 2208 像素（竖屏）2208 x 1242 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，则此项为必需项。</td><td align="left">上传 5.5 英寸截屏</td></tr><tr><td align="left">4.7 英寸：iPhone SE（第 2 代）、iPhone 8、iPhone 7、iPhone 6s、iPhone 6</td><td align="left">750 x 1334 像素（竖屏）1334 x 750 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸截屏可选：上传 4.7 英寸截屏</td></tr><tr><td align="left">4 英寸：iPhone SE（第 1 代）</td><td align="left">640 x 1096 像素（竖屏，不含状态栏）640 x 1136 像素（竖屏，含状态栏）1136 x 600 像素（横屏，不含状态栏）1136 x 640 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸或 4.7 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸或 4.7 英寸截屏可选：上传 4 英寸截屏</td></tr><tr><td align="left">3.5 英寸：iPhone 4s</td><td align="left">640 x 920 像素（竖屏，不含状态栏）640 x 960 像素（竖屏，含状态栏）960 x 600 像素（横屏，不含状态栏）960 x 640 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸 iPhone 截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸、4.7 英寸或 4 英寸截屏可选：上传 3.5 英寸截屏</td></tr><tr><td align="left">12.9 英寸：iPad Pro（第 4 代、第 3 代）</td><td align="left">2048 x 2732 像素（竖屏）2732 x 2048 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，则此项为必需项。</td><td align="left">上传适用于 12.9 英寸 iPad Pro（第 3 代）的截屏</td></tr><tr><td align="left">12.9 英寸：iPad Pro（第 2 代）</td><td align="left">2048 x 2732 像素（竖屏）2732 x 2048 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，则此项为必需项。</td><td align="left">上传适用于 12.9 英寸 iPad Pro（第 2 代）的截屏</td></tr><tr><td align="left">11 英寸：iPad Pro、iPad Air（第 4 代）、iPad mini（第 6 代）</td><td align="left">1488 x 2266 像素（竖屏）2266 x 1488 像素（横屏）1668 x 2388 像素（竖屏）2388 x 1668 像素（横屏）1640 x 2360 像素（竖屏）2360 x 1640 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 3 代）的缩小版截屏可选：上传 11 英寸截屏</td></tr><tr><td align="left">10.5 英寸：iPad（第 9 代、第 8 代、第 7 代）、iPad Pro、iPad Air</td><td align="left">1668 x 2224 像素（竖屏）2224 x 1668 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 2 代）的缩小版截屏可选：上传 10.5 英寸截屏</td></tr><tr><td align="left">9.7 英寸：iPad、iPad mini</td><td align="left">1536 x 2008 像素（竖屏，不含状态栏）1536 x 2048 像素（竖屏，含状态栏）2048 x 1496 像素（横屏，不含状态栏）2048 x 1536 像素（横屏，含状态栏）768 x 1004 像素（竖屏，不含状态栏）768 x 1024 像素（竖屏，含状态栏）1024 x 748 像素（横屏，不含状态栏）1024 x 768 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）或 10.5 英寸的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 2 代）的缩小版截屏或缩小版 10.5 英寸截屏可选：上传 9.7 英寸截屏</td></tr><tr><td align="left">Mac</td><td align="left">宽高比须为 16:10，以下尺寸均可： 1280 x 800 像素1440 x 900 像素2560 x 1600 像素2880 x 1800 像素</td><td align="left">对于 Mac App 为必需项。</td><td align="left">以任一所列尺寸上传的 Mac 的截屏</td></tr><tr><td align="left">Apple TV</td><td align="left">1920 x 1080 像素3840 x 2160 像素</td><td align="left">对于 Apple TV App 为必需项。</td><td align="left">以任一所列尺寸上传的 Apple TV 截屏</td></tr><tr><td align="left">Apple Watch：Series 7、Series 6、Series 5、Series 4、Series 3、SE</td><td align="left">396 x 484 像素（Series 7）368 x 448 像素（Series 6、Series 5、Series 4、SE）312 x 390 像素（Series 3）</td><td align="left">对于 Apple Watch App 为必需项。</td><td align="left">以任一所列尺寸上传的 Apple Watch 截屏</td></tr></tbody></table><h2>App 内活动媒体素材规范</h2><table><thead><tr><th align="left">媒体类型</th><th align="left">支持的扩展名</th><th align="left">宽高比</th><th align="left">最小尺寸／分辨率</th><th align="left">最大尺寸／分辨率</th></tr></thead><tbody><tr><td align="left">活动卡片图像</td><td align="left">.jpg、.jpeg、.png</td><td align="left">16 : 9</td><td align="left">1920 x 1080 像素</td><td align="left">3840 x 2160 像素</td></tr><tr><td align="left">活动卡片视频</td><td align="left">.mov、.m4v、.mp4</td><td align="left">16 : 9</td><td align="left">1920 x 1080 像素 30 fps 或 60 fps</td><td align="left">3840 x 2160 像素 30 fps 或 60 fps</td></tr><tr><td align="left">活动详情页面图像</td><td align="left">.jpg、.jpeg、.png</td><td align="left">9 : 16</td><td align="left">1080 x 1920 像素</td><td align="left">2160 x 3840 像素</td></tr><tr><td align="left">活动详情页面视频</td><td align="left">.mov、.m4v、.mp4</td><td align="left">9 : 16</td><td align="left">1080 x 1920 像素 30 fps 或 60 fps</td><td align="left">2160 x 3840 像素 30 fps 或 60 fps</td></tr></tbody></table>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[推流分辨率码率设置]]></title>
        <id>推流分辨率码率设置</id>
        <link href="https://gouxin.fun/2021/10/29/推流码率设置"/>
        <updated>2021-10-29T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Header]]></summary>
        <content type="html"><![CDATA[<p><img src="./Header.png" alt="Header"/></p><p>做直播始终离不开分辨率和码率的设置。</p><p>这里记录下腾讯音视频sdk中对推流参数的设置建议。</p><h3>分辨率码率对应表</h3><table><thead><tr><th>分辨率</th><th>码率范围</th></tr></thead><tbody><tr><td>160 * 160</td><td>100Kbps ~ 150Kbps</td></tr><tr><td>270*270</td><td>200Kbps ~ 300Kbps</td></tr><tr><td>480*480</td><td>350Kbps ~ 525Kbps</td></tr><tr><td>320*240</td><td>250Kbps ~ 375Kbps</td></tr><tr><td>480*360</td><td>400Kbps ~ 600Kbps</td></tr><tr><td>640*480</td><td>600Kbps ~ 900Kbps</td></tr><tr><td>320*180</td><td>250Kbps ~ 400Kbps</td></tr><tr><td>480*270</td><td>350Kbps ~ 550Kbps</td></tr><tr><td>640*360</td><td>500Kbps ~ 900Kbps</td></tr><tr><td>960*540</td><td>800Kbps ~ 1500Kbps</td></tr><tr><td>1280*720</td><td>1000Kbps ~ 1800Kbps</td></tr><tr><td>1920*1080</td><td>2500Kbps ~ 3000Kbps</td></tr></tbody></table>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pod repo push使用总结]]></title>
        <id>pod repo push使用总结</id>
        <link href="https://gouxin.fun/2021/10/28/pod-repo-push使用总结"/>
        <updated>2021-10-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[90088193-C7B8-4466-9DB9-DE681F7BF357]]></summary>
        <content type="html"><![CDATA[<p><img src="./90088193-C7B8-4466-9DB9-DE681F7BF357.png" alt="90088193-C7B8-4466-9DB9-DE681F7BF357"/></p><p>我们在修改完lib库后的最后一步就是使用<code>pod repo push</code>，将新的版本推到仓库里。</p><p>可是有时候会遇到各种奇怪的问题，导致一直push不成功，这里总结下使用方式。</p><h3>使用方式</h3><pre><code class="language-shell">pod repo push &lt;仓库&gt; xxx.podspec
</code></pre><h3>使用pod lib lint检查</h3><p>在push前，我们最好使用<code>pod lib lint</code>检查一下，因为这个命令可以提前暴露出push时会遇到的问题。</p><h4>--allow-warnings</h4><p>最常用的选项，忽略警告</p><h4>--fail-fast</h4><p>建议加上，遇到error可以立马结束，这样就不用在很长很长的log里找到底是什么error。</p><h4>--no-subspecs</h4><p>如果有很多subspec，可以加上这个，能快点。</p><h4>--skip-import-validation</h4><p>跳过import校验。通常我们遇到下面的错误时，可以跳过对能否import的校验</p><pre><code class="language-shell"> - NOTE  | [iOS] xcodebuild:  ld: warning: ignoring file xxx/xx/x.a, missing required architecture x86_64 in file xxx/xx/
 - NOTE  | [iOS] xcodebuild:  ld: warning: ignoring file xxx/xx/x.a, missing required architecture i386 in file xxx/xx/
</code></pre><h4>--sources</h4><p>指定source，如果error是某个lib找不到，那么就通过这个指定这个lib的source, 可以指定多个，用逗号隔开。</p><pre><code class="language-shell">--sources=&quot;http://my-private/xxx/CocoapodsRepos.git,https://github.com/CocoaPods/Specs.git&quot;
</code></pre><h3>使用pod repo push</h3><p>一般能通过pod lib lint的，基本上push都没啥问题。不建议不lint直接push，因为push产生的Log会很长很长，如果遇到error将很难发现问题。一般常用的option：</p><h4>--allow-warnings</h4><p>最常用的选项，忽略警告</p><h4>--sources</h4><p>指定source，如果error是某个lib找不到，那么就通过这个指定这个lib的source, 可以指定多个，用逗号隔开。</p><h4>--skip-import-validation</h4><p>跳过import校验</p><h3>其他</h3><p>有时候还会遇到一些奇奇怪怪的问题。比如：能编译过，但是lint/push时都报compile Error，最后发现是RealReachability的header中会少一些宏定义，代码中又引用了这些宏，最终全部替换掉就能正常push。</p><p>总之，先lint，用<code>--fail-fast</code>尽快找到错误提示，完成修改。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flex-Layout]]></title>
        <id>Flex-Layout</id>
        <link href="https://gouxin.fun/2021/10/27/Flex-Layout"/>
        <updated>2021-10-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[193EADF1-38F8-4FAF-9335-A05209EC236A]]></summary>
        <content type="html"><![CDATA[<p><img src="./193EADF1-38F8-4FAF-9335-A05209EC236A.png" alt="193EADF1-38F8-4FAF-9335-A05209EC236A"/></p><h2>flex布局</h2><p>flex布局由两部分组成：flex container(弹性容器)和flex item(弹性元素)组成。</p><h2>Flex container</h2><p>你可以通过<code>display:flex</code> 或者 <code>display:inline-flex</code>，来将一个元素变成弹性容器。<code>display:flex</code>声明的是块级框， <code>display:inline-flex</code>声明的是行内块级框。</p><p>当你声明一个元素是flex container时，他的每个直接子元素都变成了一个flex item。</p><h3>排版原则</h3><p>将item按照justifycontent的设置依次<strong>沿着主轴</strong>排列,默认不换行。</p><p>如果换行的话，那么<strong>沿着交叉轴</strong>方向排列下一行。</p><h3>flex container的轴</h3><p>弹性容器有2个轴：主轴 和 交叉轴。</p><p><code>flex-direction</code>定义了主轴的方向，他的取值如下：</p><pre><code class="language-css">row: 水平书写方向
row-reverse: 与row相反
coulm: 垂直于主轴的书写方向
coulm-reverse:与coulm相反
</code></pre><p>那么交叉轴呢？交叉轴始终和主轴垂直，方向是这个方向的书写方向。</p><p>这里都是用的书写方向，而不是水平向右这类词汇，因为对于不同的书写方向row的方向也不同，比如：对于从右到左书写方向的，他的row是，从右到左。</p><p>知道了主轴和交叉轴方向后，弹性元素将沿着主轴方向布局，如果允许换行，那么新的一行沿着交叉轴方向排列。</p><h3>换行flex-wrap</h3><p>如果弹性元素在主轴方向上排列不下。默认是不会换行的，如果设置了shrink，那就缩小尺寸，否则将从边框溢出。</p><p>我们可以使用flex-wrap控制换行。他的值如下：</p><pre><code>nowrap: 不换行
wrap: 沿着交叉轴方向换行
wrap-reverse: 沿着交叉轴的反方向换行
</code></pre><h3>flex-direction和flex-wrap的简写</h3><p><code>flex-flow</code>是flex-direction和flex-wrap的简写</p><h3>控制空白的位置</h3><p>目前为止，我们知道flex item会沿着主轴方向进行排列，如果有多行，那么行沿着交叉轴方向排列，这也意味着如果一行没占满，留有空白，那么这个空白始终出现在主轴+交叉轴的方向那。</p><p>我们可以控制这个行为，下面是相关属性：</p><pre><code class="language-css">justify-content ：控制一行中，item在主轴方向上的布局方式(我个人更喜欢理解为空白的处理方式)
flex-start: item沿着主轴依次布局，（空白全在末尾）
flex-end:item沿着主轴反方向依次布局，（空白全在开头）
center: 把所有item作为一个整体居中布局。 (空白两侧等分)
space-between: 把每行第一个元素放在主轴起边， 最后一个元素放在主轴终边。然后余下的item的两侧放置等量空白, 如果没有多余空白，那么会把最后一个元素撑到外面去。
space-around: item两侧有等量的不折叠的空白。
space-evenly: 把剩余空白等分，和item依次排列。这也意味着第一个元素到主轴起边和最后一个元素到主轴终边的距离是一样的。
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2tjs3h9ij31400sf4ci.jpg" alt="图像"/></p><p>如果没有多余空白，页不允许换行，那么将溢出，justify-content对溢出也有影响</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2tp24qdrj313x0ot134.jpg" alt="图像"/></p><h3>一行中如何对齐元素</h3><p>上面justify-content的例子有点特殊，因为他们的item的高度都是相等的，以至于我们忽略了，如果item也有不同高度时的情况。</p><p>如果item有不同的高度，那么item在交叉轴方向上应该如何布局嘞？</p><p>他受下面的属性控制：</p><pre><code class="language-css">align-items : 定义一行中，item在交叉轴上的布局方式
flex-start: 沿着交叉轴起边对其
flex-end: 沿着交叉轴终边对其
center: 在一行中垂直居中对其
stretch: 全部拉伸填满交叉轴方向
baseline: 各个item基线对其
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2u1epaxhj30dz12gq8x.jpg" alt="图像"/></p><h3>交叉轴对齐方式覆盖</h3><p>刚刚讲了align-items是item在一行中交叉轴上的布局方式。但有时我们可能存在特异化需求，比如奇数位置上的item是flex-start, 偶数位置上是flex-end。</p><p><code>align-self</code>便是用于覆盖align-items属性的值，和align-items不同的是，align-self是声明在flex item上的，覆盖了flex container上的align-items属性。</p><p>由于是覆盖align-items，所以他的取值和align-items是一样的，作用也是一样的。</p><h3>多个行的布局方式</h3><p>如果允许换行，那么久可能出现多个行的情况，默认情况下，多个行是沿着交叉轴方向依次排列。但我们可以改变这个行为。</p><p><code>align-content</code>属性指定了交叉轴方向上的额外空间如何分配到各个行之间。</p><p>他的取值和justify-content类似，多了个stretch。</p><pre><code class="language-css">align-content: 
flex-start : 沿着交叉轴起边依次排列行,(空白在末尾)
flex-end : 沿着交叉轴终边开始依次排列行，(空白在开头)
center: 把各个行作为一个整体，居中排列
space-between: 第一行放在交叉轴起边，最后一行放在交叉轴终边，剩余空间等分和item依次排列
space-around: item两边有等量的不折叠的空白
space-evenly: item两边有等量空白
stretch: 等分空白，每一行拉伸等量空白空间。
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2ujy594dj30u00zp1kx.jpg" alt="图像"/></p><h2>Flex item</h2><p>刚刚我们说的除了align-self，其他都是应用在container上的属性。接下来，我们再看看应用在item上的属性。</p><p>除了align-self，还有flex, flex-grow, flex-shrink, flex-basis, order。</p><p>其中flex是flex-grow flex-shrink flex-basis的缩写。</p><p>我们可能遇到出现的结果和想象的不一样的情况，这个大多数有2个原因：</p><ol><li>对属性含义的误解</li><li>忽略各个情况下的默认值</li></ol><p>弹性元素还有：外边距不折叠的特性。float和clear对弹性元素不起作用。</p><p>Vertical-align对弹性元素没有作用，vertical-align是文本属性中的一员，用于控制文本在文本行框中的垂直方向上的对其方式。所以你item指定了vertical-align:bottom，那么只是item中的文本在文本行框中底部对齐，而不是把item推向container的底部。</p><p>绝对定位对item也有影响。如果某个item使用了绝对定位，那么这个item将从文档流移除，不会参与弹性布局。虽然他从文档流中移除了，但是justify-content和align-self还是会影响绝对定位元素。比如：align-self:center，那么绝对定位item会在弹性容器中交叉轴方向居中。</p><h3>Flex-basis</h3><p>含义：根据增长因子或者缩减因子分配多余或者缺少空间之前，弹性元素的大小。</p><p>不鼓励：单独使用，建议用flex简写</p><pre><code class="language-css">flex-basis:
auto: width ==&gt; min-width =&gt; content
&lt;length&gt;: 指定长度,比如200px
&lt;percentage&gt;: 百分比，相对于弹性container
</code></pre><p>注意：flex-basis的默认值是auto，但是如果你指定了flex属性，省略了flex-basis，那么flex-basis是0%。</p><h3>Flex-grow</h3><p>含义：有多余空间时是否允许增大，以及如何分配剩余空间。</p><p>不鼓励：单独使用，建议用flex简写</p><p>负数无效。</p><p>下面看看container宽750，有3个100px的item：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2w7s8g6fj30w20u01bu.jpg" alt="图像"/></p><p>如果我们换成flex:1, flex:1, flex:3呢？我们看到又是分配的全部空间，而不是剩余空间。为什么呢？这就和默认值有关了。</p><p>如果我们单独设flex-grow，没有设置flex，和flex-basis，那么这个时候flex-basis是auto。也就是在分配剩余空间前，item占用width的空间，所以得到剩余空间是450px。</p><p>如果指定了flex:1， 但是省略了flex-basis，那么flex-basis是0，也就是说在分配剩余空间前，item不占空间，3个item都不占空间，那么剩余空间就是整个空间的大小，所以看到的是按比例分配。</p><h3>Flex-shrink</h3><p>翻译：空间不够放置所有弹性元素，而且弹性容器不能增加尺寸也不允许换行时，如何分配“缺少空间”。</p><p>不鼓励：单独使用，建议用flex简写</p><p>那么如何分配呢？首先得计算出缩减比例，缩减比例不仅和shrink有关，还和item宽度有关。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2x0tya2wj30zv07c408.jpg" alt="图像"/></p><p>最终item的宽度为</p><p>120/(150 <em> 1 + 250 </em> 1+ 200 <em>1) </em> 1 </p><p>Width = itemWidth <em> shrink </em> 缩小比例。</p><h3>flex</h3><p>之前说了flex是flex-grow flex-shrink flex-basis的简写，推荐使用这个。</p><p>唯一需要注意的是他的默认值。省略flex-basis的话是0 而不是auto。</p><h3>order</h3><p>定义item的顺序。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何为githubPage添加自定义域名]]></title>
        <id>如何为githubPage添加自定义域名</id>
        <link href="https://gouxin.fun/2021/10/26/如何为githubPage添加自定义域名"/>
        <updated>2021-10-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD]]></summary>
        <content type="html"><![CDATA[<p><img src="./68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD.png" alt="68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD"/></p><p>当我们把blog托管在github page上后，就能得到一个<code>&lt;userName&gt;.github.io</code>的域名。不过有点丑，没关系我们还可以用自己的域名。</p><h3>第一步：购买域名</h3><p>我是在阿里云上买的一个域名，购买完成后，进入<code>解析设置</code>， 然后添加记录。</p><p><img src="./23A6A5C1-68E6-4B1C-B56F-C962C574E897.png" alt="23A6A5C1-68E6-4B1C-B56F-C962C574E897"/></p><h5>添加一个CNAME记录</h5><p>记录类型：CNAME</p><p>主机记录：www</p><p>记录值:  xxx.github.io</p><h5>添加多个A记录</h5><p>参考<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">官方文档</a>, 添加多个A 和 AAAA</p><p>记录类型：A</p><p>主机记录：不填</p><p>记录值:  185.199.108.153</p><h3>第二步：修改仓库setting</h3><p><img src="./226E7E5E-6EE6-457B-85F9-CD1823B554ED.png" alt="226E7E5E-6EE6-457B-85F9-CD1823B554ED"/></p><p>Custom domain处填写你自己的域名，然后等一会github解析，成功后勾选<code>Enforce https</code>。</p><p>现在就可以访问新的。</p><h3>第三步：其他修改</h3><p>如果你使用像<code>docusaurus</code>这样的框架，那么还得修改config文件中的url和baseUrl。</p><pre><code class="language-json">{
  url: &#x27;https://gouxin.fun&#x27;,
  baseUrl: &#x27;/&#x27;,
}
</code></pre><p>然后你还会发现，每次deploy后custom domain都会被重置。我们还需要在static目录下加上CNAME文件，参考<a href="https://docusaurus.io/zh-CN/docs/deployment#docusaurusconfigjs-settings">https://docusaurus.io/zh-CN/docs/deployment#docusaurusconfigjs-settings</a></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[博客开张啦]]></title>
        <id>博客开张啦</id>
        <link href="https://gouxin.fun/2021/10/25/博客开张啦"/>
        <updated>2021-10-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[6DE1C549-029E-49E9-A79B-669B782FD675]]></summary>
        <content type="html"><![CDATA[<p><img src="./6DE1C549-029E-49E9-A79B-669B782FD675.png" alt="6DE1C549-029E-49E9-A79B-669B782FD675"/></p><p> 之前的blog在老电脑上，现在已经找不到了，有段时间没有写博客了。现在用<a href="https://docusaurus.io/">docusaurus</a>重新搭建自己的博客。相比于hexo，docusaurus使用React更灵活。</p><p>加油！加油！加油</p>]]></content>
    </entry>
</feed>
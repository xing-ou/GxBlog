<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Gx'sBlog Blog</title>
        <link>https://gouxin.fun/</link>
        <description>Gx'sBlog Blog</description>
        <lastBuildDate>Thu, 13 Jan 2022 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[SwiftUI专辑070-一个定时器App]]></title>
            <link>https://gouxin.fun/2022/01/13/SwiftUI专辑-071-一个定时器App</link>
            <guid>/2022/01/13/SwiftUI专辑-071-一个定时器App</guid>
            <pubDate>Thu, 13 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
当我们subscribe一个publisher后，这个结果需要存储到某个地方，通常我们都是通过调用<code>.store</code>方法存储在某个 <strong>AnyCancellable Set</strong>中。但是每个都这么用，可能会显得有点重复，我们将用@ResultBuilder来包裹所有的subscribtion，将所有AnyCancellable放到同一个set中。</p><p>我们来看一个定时器的例子。</p><h2>Getting ready</h2><p>首先，新建一个项目：<strong>StopWatch</strong></p><h2>How to do it…</h2><ol><li>构建数据model</li></ol><pre><code class="language-swift">class StopWatchTimer: ObservableObject {
    @Published var deciseconds: Int = 0
    @Published var seconds: Int = 0
    @Published var minutes: Int = 0
    @Published var started = false
    private var cancellableSet: Set&lt;AnyCancellable&gt; = []

    func start() {
    }

    func stop() {
    }
}
</code></pre><ol start="2"><li>实现start和stop</li></ol><pre><code class="language-swift">func stop() {
    cancellableSet = []
    started = false
}

func start() {
    cancellableSet.store {
        Timer.publish(every: 0.1, on: RunLoop.main)
            .autoconnect()
            .sink { _ in
                self.deciseconds = (self.deciseconds + 1)%10
            }
        Timer.publish(every: 1.0, on: RunLoop.main)
            .autoconnect()
            .sink { _ in
                self.seconds = (self.seconds + 1)%60
            }
        Timer.publish(every: 60, on: RunLoop.main)
            .autoconnect()
            .sink { _ in
                self.minutes = (self.minutes + 1)%60
            }
    }
  started = true
}
</code></pre><ol start="3"><li>实现<code>cancellableSet.store</code>方法</li></ol><pre><code class="language-swift">typealias CancellableSet = Set&lt;AnyCancellable&gt;
extension CancellableSet {
    mutating func store(@CancellableBuilder _ cancellables: () -&gt; [AnyCancellable]) {
        formUnion(cancellables())
    }

    @resultBuilder
    struct CancellableBuilder {
        static func buildBlock(_ cancellables:AnyCancellable...) -&gt; [AnyCancellable] {
            return cancellables
        }
    }
}

</code></pre><ol start="4"><li>实现UI</li></ol><pre><code class="language-swift">extension Int {
    var formatted: String {
        String(format: &quot;%02d&quot;, self)
    }
}

@available(iOS 15.0, *)
struct ContentView: View {
    @StateObject private var timer = StopWatchTimer()
    var body: some View {
        VStack(spacing: 12) {
            HStack(spacing: 0) {
                Text(&quot;\(timer.minutes.formatted)&quot;)
                    .font(.system(size: 80))
                    .frame(width: 100)
                Text(&quot;:&quot;)
                    .font(.system(size: 80))
                Text(&quot;\(timer.seconds.formatted)&quot;)
                    .font(.system(size: 80))
                    .frame(width: 100)
                Text(&quot;:&quot;)
                    .font(.system(size: 80))
                Text(&quot;\(timer.deciseconds.formatted)&quot;)
                    .font(.system(size: 80))
                    .frame(width: 100)
            }
            Button {
                if timer.started {
                    timer.stop()
                } else {
                    timer.start()
                }
            } label: {
                Text(timer.started ? &quot;Stop&quot; : &quot;Start&quot;)
                    .foregroundColor(.white)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 16)
                    .frame(width: 100)
                    .background(timer.started ? Color.red : Color.green)
                    .cornerRadius(5)
            }
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyc7hms97sj30bw0oqgly.jpg" alt="image-20220113180947904"/></p><h2>How it works…</h2><p>首先我们学习了<code>Timer.publish</code>，知道了如何生成时间。</p><p>然后<strong>.autoconnect()</strong>让publisher立马开始。</p><p>最后，我们使用了@ResultBuilder，这样在builder闭包中的多个subscribe产生的<strong>AnyCancellable</strong>就会被收集起来放到cancellableSet中。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑070-Combine简介]]></title>
            <link>https://gouxin.fun/2022/01/12/SwiftUI专辑-070-Combine简介</link>
            <guid>/2022/01/12/SwiftUI专辑-070-Combine简介</guid>
            <pubDate>Wed, 12 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
我们还是来看个<strong>CoreLocation</strong>的例子。</p><h2>Getting ready</h2><p>新建一个项目：<strong>CombineCoreLocationManager</strong></p><p><strong>PROJECT</strong> &gt; <strong>Info</strong>中添加获取定位权限Key：<strong>NSLocationWhenInUseUsageDescription</strong></p><h2>How to do it…</h2><ol><li>首先实现个LocationManager，封装一下CLLocationManager。</li></ol><pre><code class="language-swift">import CoreLocation
import SwiftUI
class LocationManager: NSObject {
    enum LocationError: String, Error {
        case restricted
        case denied
        case unknown
    }

    private let locationManager = CLLocationManager()

    override init() {
        super.init()
        self.locationManager.delegate = self
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
        self.locationManager.requestWhenInUseAuthorization()
    }

    func start() {
        self.locationManager.startUpdatingLocation()
    }
}
</code></pre><ol start="2"><li>目前为止和Combine还没什么关系，我们继续添加2个Publisher</li></ol><pre><code class="language-swift">class LocationManager: NSObject {
  ...
  let statusPublisher = PassthroughSubject&lt;CLAuthorizationStatus, LocationError&gt;()
    let locationPublisher = PassthroughSubject&lt;CLLocation?, Never&gt;()
  ...
}

</code></pre><ol start="3"><li>然后我们实现CLLocationManagerDelegate，把回调的value转发给publisher</li></ol><pre><code class="language-swift">extension LocationManager: CLLocationManagerDelegate {
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        switch manager.authorizationStatus {
        case .restricted: self.statusPublisher.send(completion: .failure(.restricted))
        case .denied: self.statusPublisher.send(completion: .failure(.denied))
        case .notDetermined, .authorizedAlways,.authorizedWhenInUse:
            self.statusPublisher.send(manager.authorizationStatus)
        @unknown default:
            self.statusPublisher.send(completion: .failure(.unknown))
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        locationPublisher.send(location)
    }
}
</code></pre><ol start="3"><li>创建一个<strong>LocationViewModel</strong>，用于提供界面显示的数据</li></ol><pre><code class="language-swift">extension Optional where Wrapped == CLLocation {
    var latitudeDescription: String {
        guard let self = self else {
            return &quot;-&quot;
        }
        return String(format: &quot;%0.4f&quot;, self.coordinate.latitude)
    }

    var longitudeDescription: String {
        guard let self = self else {
            return &quot;-&quot;
        }
        return String(format: &quot;%0.4f&quot;, self.coordinate.longitude)
    }
}

class LocationViewModel: ObservableObject {
    @Published
    private var status: CLAuthorizationStatus = .notDetermined
    @Published
    private var currentLocation: CLLocation?
    @Published
    var errorMessage = &quot;&quot;
    private let locationManager = LocationManager()

    private var cancellableSet: Set&lt;AnyCancellable&gt; = []
    init() {
        self.locationManager
            .statusPublisher
            .debounce(for: 0.5, scheduler: RunLoop.main)
            .removeDuplicates()
            .sink { completion in
                switch completion {
                case .finished: break
                case let .failure(error):
                    self.errorMessage = error.rawValue
                }
            } receiveValue: { self.status = $0 }
            .store(in: &amp;self.cancellableSet)

        self.locationManager.locationPublisher
            .debounce(for: 0.5, scheduler: RunLoop.main)
            .removeDuplicates(by: self.lessThanOneMeter)
            .assign(to: \.currentLocation, on: self)
            .store(in: &amp;self.cancellableSet)
    }

    private func lessThanOneMeter(_ lhs: CLLocation?, _ rhs: CLLocation?) -&gt; Bool {
        if lhs == nil &amp;&amp; rhs == nil {
            return true
        }
        guard let lhr = lhs,
              let rhr = rhs else {
            return false
        }
        return lhr.distance(from: rhr) &lt; 1
    }

    func startUpdating() {
        self.locationManager.start()
    }

    // 准备UI数据
    var thereIsAnError: Bool {
        !self.errorMessage.isEmpty
    }

    var latitude: String {
        self.currentLocation.latitudeDescription
    }

    var longitude: String {
        self.currentLocation.longitudeDescription
    }

    var statusDescription: String {
        switch self.status {
        case .notDetermined: return &quot;notDetermined&quot;
        case .authorizedWhenInUse: return &quot;authorizedWhenInUse&quot;
        case .authorizedAlways: return &quot;authorizedAlways&quot;
        case .restricted: return &quot;restricted&quot;
        case .denied: return &quot;denied&quot;
        @unknown default: return &quot;unknown&quot;
        }
    }
}
</code></pre><ol start="4"><li>然后再ContentView中使用</li></ol><pre><code class="language-swift">struct ContentView: View {
    @StateObject var locationViewModel = LocationViewModel()
    var body: some View {
        Group {
            if locationViewModel.thereIsAnError {
                Text(&quot;Location Service terminated with error:\(locationViewModel.errorMessage)&quot;)
            } else {
                Text(&quot;Status:\(locationViewModel.statusDescription)&quot;)
                HStack {
                    Text(&quot;Latitude: \(locationViewModel.latitude)&quot;)
                    Text(&quot;Longitude:\(locationViewModel.longitude)&quot;)
                }
            }
        }.padding(.horizontal, 24)
        .task {
            locationViewModel.startUpdating()
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyc5m0w4i6j30b40b5q3a.jpg" alt="Figure_10.4_B17962"/></p><h2>How it works…</h2><p>首先你可能注意到我们 <strong>@Published</strong> 修饰的是 <strong>private</strong>变量，你可能感到奇怪，通常我们都是设置为Public，这样能够让外部访问，不过我们这里是ViewModel，数据需要被加工后才能使用，所以我们隐藏原始数据，暴露加工后的数据。</p><p>首先，我们在LocationManager中定义了2个publisher，他们是Subject。subject是管理输入的，有一个<code>.send</code>方法来发送event。常用的subject是：<strong>CurrentValueSubject</strong> 和 <strong>PassthroughSubject</strong>。</p><p>CurrentValueSubject有初始值，自己维护改变的值，即使没有任何subscribers。</p><p>PassthroughSubject没有初始值，如果没有subscribers，收到的值会被抛弃。</p><pre><code class="language-swift">//可以类比RxSwift的onEvent, onError, onCompleted
// 发送event
statusPublisher.send(status)
//发送finish
statusPublisher.send(completion: .finish)
//发送失败
statusPublisher.send(completion: .failure(.restricted))
</code></pre><p>然后我们再来看看subscribe，我们在Init方法中做的subscribe。</p><pre><code class="language-swift">locationManager.locationPublisher
    // 节流
    .debounce(for: 0.5, scheduler: RunLoop.main)
    // 移除重复
    .removeDuplicates(by: lessThanOneMeter)
    // 相当于rxswift的 subscribe
    .assign(to: \.currentLocation, on: self)
    // 相当于rxswift的 addToDisposeBag()
    .store(in: &amp;cancellableSet)// cancellableSet相当于DisposeBag
</code></pre><p><code>sink</code>可以同时接受completion状态和recivedValue，可以更精确的处理数据。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑069-@EnvironmentObject]]></title>
            <link>https://gouxin.fun/2022/01/11/SwiftUI专辑-069-@EnvironmentObject</link>
            <guid>/2022/01/11/SwiftUI专辑-069-@EnvironmentObject</guid>
            <pubDate>Tue, 11 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
有时我们必须在多个视图之间共享数据，比如：ThemeManager。</p><p>如果你通过View层级一层一层传递，那实在是太烦了。</p><p>SwiftUI 通过 <strong>Environment</strong> 的概念来解决这个问题, 在那添加公共对象(通常都是ObservableObject), 这些对象会在View chain中共享 。</p><p>我们来看一个例子。</p><h2>Getting ready</h2><p>首先，创建一个新的项目：<strong>SongPlayer</strong></p><p>再找6张图片，作为歌曲封面，添加到项目的<strong>Assets</strong>下。</p><h2>How to do it…</h2><ol><li>创建Song的Model</li></ol><pre><code class="language-swift">struct Song: Identifiable, Equatable {
    var id = UUID()
    let artist: String
    let name: String
    let cover: String
}
</code></pre><ol start="2"><li>让我们添加个播放器，保存当前播放的歌曲，并提供一个播放方法</li></ol><pre><code class="language-swift">class MusicPlayer: ObservableObject {
    @Published var currentSong: Song?
    func pressButton(song: Song) {
        if currentSong == song {
            currentSong = nil
        } else {
            currentSong = song
        }
    }
}
</code></pre><ol start="3"><li>实现一个播放按钮</li></ol><pre><code class="language-swift">struct PlayButton: View {
    @EnvironmentObject
    private var musicPlayer: MusicPlayer
    let song: Song
    private var buttonText: String {
        if song == musicPlayer.currentSong {
            return &quot;stop&quot;
        } else {
            return &quot;play&quot;
        }
    }

    var body: some View {
        Button {
            musicPlayer.pressButton(song: song)
        } label: {
            Image(systemName: buttonText)
                .font(.system(.largeTitle))
                .foregroundColor(.black)
        }
    }
}
</code></pre><ol start="4"><li>实现播放列表的cell</li></ol><pre><code class="language-swift">struct SongView: View {
    @EnvironmentObject
    private var musicPlayer: MusicPlayer
    let song: Song
    var body: some View {
        HStack {
            NavigationLink(destination:PlayerView(song: song)) {
                Image(song.cover)
                    .renderingMode(.original)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(width: 100, height: 100)
                VStack(alignment: .leading) {
                    Text(song.name)
                    Text(song.artist).italic()
                }
            }

            Spacer()

            PlayButton(song: song)

        }.buttonStyle(PlainButtonStyle())
    }
}
</code></pre><ol start="5"><li>实现播放详情View</li></ol><pre><code class="language-swift">struct PlayerView: View {
    @EnvironmentObject
    private var musicPlayer: MusicPlayer
    let song: Song
    var body: some View {
        VStack {
            Image(song.cover)
                .renderingMode(.original)
                .resizable()
                .aspectRatio(contentMode: .fill)
                .frame(width: 300, height: 300)
            HStack {
                Text(song.name)
                Text(song.artist).italic()
            }
            PlayButton(song: song)
        }
    }
}
</code></pre><ol start="6"><li>实现一个mini播放器VIew</li></ol><pre><code class="language-swift">struct MiniPlayerView: View {
    @EnvironmentObject
    private var musicPlayer: MusicPlayer

    var body: some View {
        if let currentSong = musicPlayer.currentSong {
            SongView(song: currentSong)
                .padding(.all, 24)
        } else {
            EmptyView()
        }
    }
}
</code></pre><ol start="7"><li>在ContentView中准备好数据，显示播放列表</li></ol><pre><code class="language-swift">struct ContentView: View {
    @EnvironmentObject
    private var musicPlayer: MusicPlayer

    private let songs = [
        Song(artist: &quot;Luke&quot;, name: &quot;99&quot;, cover: &quot;cover0&quot;),
        Song(artist: &quot;Foxing&quot;, name: &quot;No Trespassing&quot;, cover: &quot;cover1&quot;),
        Song(artist: &quot;Breaking Benjamin&quot;, name: &quot;Phobia&quot;, cover: &quot;cover2&quot;),
        Song(artist: &quot;J2&quot;, name: &quot;Solenoid&quot;, cover: &quot;cover3&quot;),
        Song(artist: &quot;Wildflower Clothing&quot;, name: &quot;Lightning Bottles&quot;, cover: &quot;cover4&quot;),
        Song(artist: &quot;The Broken Spirits&quot;, name: &quot;Rubble&quot;, cover: &quot;cover5&quot;),
    ]

    var body: some View {
        ZStack(alignment: .bottom) {
            NavigationView {
                List(self.songs) { song in
                    SongView(song: song)
                }
                .listStyle(.plain)
                .navigationTitle(&quot;Music Player&quot;)
            }
            MiniPlayerView()
                .background(.gray)
                .offset(y: 44)
        }
    }
}
</code></pre><ol start="8"><li>设置preview的environmentObject，这样在预览中就能看到</li></ol><pre><code class="language-swift">struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView().environmentObject(MusicPlayer())
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyb27lxasgj30b407ewf5.jpg" alt="Figure_9.9_B17962"/></p><h2>How it works…</h2><p>每个View都会被他的ancestors设置Environment，然后view可以从Environment中获取value，只需要标记为@EnvironmentObject。</p><p>你可以把Environment认为是一个HashMap，key是对象的类型，value是对于的值。</p><p>由此，我们可以推断在<strong>Environment </strong>不能有两个相同类型的对象，不过这通常不是问题，我们有别的方法解决。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑068-@StateObject]]></title>
            <link>https://gouxin.fun/2022/01/10/SwiftUI专辑-068-@StateObject</link>
            <guid>/2022/01/10/SwiftUI专辑-068-@StateObject</guid>
            <pubDate>Mon, 10 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
一开始<strong>@ObservedObject</strong>是被用来把逻辑从View中分离出去的。</p><p>apple期望我们从外部传入那个对象，而不是在View内部创建这个对象。因为在内部创建的话，就将ObservedObject的生命周期和view的生命周期绑定在了一起，View销毁，ObservedObject也会被销毁。</p><p>但是实际情况是，我们的View很有可能会被不断的销毁和重建，这种销毁和重建并不是我们的逻辑，而是SwiftUI刷新界面的规则，我们无法干预。随着View的销毁和重建，内部的state也被重置了，这是一个很奇怪的行为。</p><p>apple意识到了这一点，加了个新的<strong>@StateObject</strong>修饰符来解决这个问题。</p><p>本文将演示这种奇怪的行为，并介绍如何使用@StateObject。</p><h2>Getting ready</h2><p>首先，创建一个新的项目<strong>Counter</strong></p><h2>How to do it…</h2><ol><li>首先，我们新建一个Counter，相当于一个ViewModel</li></ol><pre><code class="language-swift">class Counter: ObservableObject {
    @Published var value: Int = 0
    func inc() {
        value += 1
    }

    func dec() {
        value -= 1
    }
}
</code></pre><ol start="2"><li>构建我们的计数器ConterView</li></ol><pre><code class="language-swift">struct CounterView: View {
    @ObservedObject var counter = Counter()
  // @StateObject var counter = Counter()
    var body: some View {
        VStack(spacing: 12) {
            Text(&quot;\(counter.value)&quot;)
            HStack(spacing: 12){
                Button {
                    counter.dec()
                } label: {
                    Text(&quot;-&quot;)
                        .padding()
                        .foregroundColor(.white)
                        .background(.red)
                }
                Button {
                    counter.inc()
                } label: {
                    Text(&quot;+&quot;)
                        .padding()
                        .foregroundColor(.white)
                        .background(.red)
                }
            }
        }
    }
}
</code></pre><ol start="3"><li>在ContentView中使用我们的额CounterView，并加个按钮刷新界面</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var refreshedAt: Date = Date()
    var body: some View {
        VStack(spacing:12) {
            Text(&quot;Refresh at &quot;) + Text(refreshedAt.formatted(date: .omitted, time: .standard) )
            CounterView()
            Button {
                refreshedAt = Date()
            } label: {
                Text(&quot;Refresh&quot;)
                    .padding()
                    .foregroundColor(.white)
                    .background(.blue)
            }
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyazyfczwuj30by0osmxf.jpg" alt="image-20220112170337738"/></p><h2>How it works...</h2><p>当我们点击加号，再点击refresh，我们发现计数器的值归零了。这不是我们期望的，我们只想要更新时间。</p><p>这个的原因是，当我们点击按钮，更新refreshedAt，这会重新render body，这意味着SwiftUI会销毁当前的View，重新构建，CounterView也重新构建了，内部的value被重置了。</p><p>现在我们将counter改为@StateObject：</p><pre><code class="language-swift">@StateObject var counter = Counter()
</code></pre><p>当我们点击加号，再点击refresh，一切正常，计数器的值保留了。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑067-@ObservedObject]]></title>
            <link>https://gouxin.fun/2022/01/09/SwiftUI专辑-067-@ObservedObject</link>
            <guid>/2022/01/09/SwiftUI专辑-067-@ObservedObject</guid>
            <pubDate>Sun, 09 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/></p><p>我们使用@State时有一点我们可能并没有注意到，那就是多数时候都是修饰的都是值类型，如果我们用@State去修饰引用类型呢？这就要小心了，因为改变引用类型内部的变量，SwiftUI并不能感知到，所以你的修改可能并不能反应到UI上。</p><p>那我们确实需要修饰引用类型呢？这个时候就需要@ObservedObject。</p><p>@ObservedObject修饰的对象需要遵循<strong>ObservableObject</strong>协议，同时需要被监听的属性还需要用<strong>@Published</strong>修饰。</p><p>这在将Foundation的一些对象桥接到SwiftUI中会非常有用。本文我们将用<strong>CoreLocation</strong>为例来演示一下@ObservedObject。</p><h2>Getting ready</h2><p>首先，新建一个SwiftUI工程：<strong>SwiftUICoreLocation</strong></p><p><strong>PROJECT</strong> &gt; <strong>Info</strong> 中添加获取定位的key：<strong>NSLocationWhenInUseUsageDescription</strong>，并设置一个提示信息。</p><h2>How to do it…</h2><p>我们准备将<strong>CLLocationManager</strong>包装为<strong>ObservableObject</strong>，然后暴露两个属性</p><ul><li>location的状态</li><li>当前location</li></ul><ol><li>首先，我们创建一个LocationManager</li></ol><pre><code class="language-swift">class LocationManager: NSObject, ObservableObject {
    private let locationManager = CLLocationManager()
    @Published var status: CLAuthorizationStatus?
    @Published var current: CLLocation?
    override init() {
        super.init()
        self.locationManager.delegate = self
        self.locationManager.distanceFilter = 10
        self.locationManager.desiredAccuracy = kCLLocationAccuracyBest
        self.locationManager.requestWhenInUseAuthorization()
        self.locationManager.startUpdatingLocation()
    }
}

extension LocationManager: CLLocationManagerDelegate {
    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        self.status = manager.authorizationStatus
    }
    
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        guard let location = locations.last else { return }
        self.current = location
    }
}

extension Optional where Wrapped == CLAuthorizationStatus {
    var description: String {
        guard let self = self else {
            return &quot;unknown&quot;
        }
        switch self {
        case .notDetermined: return &quot;notDetermined&quot;
        case .authorizedWhenInUse: return &quot;authorizedWhenInUse&quot;
        case .authorizedAlways: return &quot;authorizedAlways&quot;
        case .restricted: return &quot;restricted&quot;
        case .denied: return &quot;denied&quot;
        @unknown default: return &quot;unknown&quot;
        }
    }
}

extension Optional where Wrapped == CLLocation {
    var latitudeDescription: String {
        guard let self = self else {
            return &quot;-&quot;
        }
        return &quot;\(self.coordinate.latitude)&quot;
    }
    var longitudeDescription: String {
        guard let self = self else {
            return &quot;-&quot;
        }
        return &quot;\(self.coordinate.longitude)&quot;
    }
}
</code></pre><ol start="2"><li>使用我们的LocationManager</li></ol><pre><code class="language-swift">struct ContentView: View {
    @ObservedObject var locationManager = LocationManager()
    var body: some View {
        VStack {
            Text(&quot;Status: \(locationManager.status.description)&quot;)
            HStack {
                Text(&quot;Latitude: \(locationManager.current.latitudeDescription)&quot;)
                Text(&quot;Longitude: \(locationManager.current.longitudeDescription)&quot;)

            }
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyavuq6giyj30c40omaad.jpg" alt="image-20220112144140755"/></p><h2>How it works…</h2><p>你可以认为<strong>@Published</strong>是一种自动的property observer，当value改变时，能够发出一个通知。</p><p>而你用<strong>@ObservedObject</strong> 修饰的会接受到通知，并重新渲染UI。</p><p><strong>@Published</strong> 是 <strong>Combine</strong> publisher的一个语法糖，我们之后会了解他。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑066-@Binding]]></title>
            <link>https://gouxin.fun/2022/01/08/SwiftUI专辑-066-@Binding</link>
            <guid>/2022/01/08/SwiftUI专辑-066-@Binding</guid>
            <pubDate>Sat, 08 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
我们上一篇讲了@State，如果我们有其他VIew要修改我们的State呢？</p><p>在TodoList demo 中，todos array是struct，是值类型，如果我们传递state到child view，那么传递的是值的copy。当child view修改array时，并不能反映到parent view的array中，所以也看不到变化。</p><p>SwiftUI通过<strong>@Binding</strong>解决这个问题，其本质上可以看成是生成一个对get和set方法的封装struct。</p><p>我们将沿用上一个TodoList的demo来看看@Binding的使用。</p><h2>Getting ready</h2><p>沿用上一个TodoList的项目，如果你新建项目的话，可以拷贝如下代码到项目。</p><pre><code class="language-swift">struct Todo: Identifiable {
    let id = UUID()
    let description: String
    var done: Bool
}

@available(iOS 15.0, *)
struct ContentView: View {
    @State var todos = [
        Todo(description: &quot;review the first chapter&quot;, done: false),
        Todo(description: &quot;buy wine&quot;, done: false),
        Todo(description: &quot;paint kitchen&quot;, done: false),
        Todo(description: &quot;cut the grass&quot;, done: false),
    ]    
    var body: some View {
        List($todos) { $todo in
            HStack {
                Text(todo.description).strikethrough(todo.done)
                Spacer()
                Image(systemName:todo.done ? &quot;checkmark.square&quot; : &quot;square&quot;)
            }
            .contentShape(Rectangle())
            .onTapGesture {
                todo.done.toggle()
            }
        }
    }
}
</code></pre><h2>How to do it…</h2><ol><li>创建一个新的View来添加新的todo</li></ol><pre><code class="language-swift">@available(iOS 15.0, *)
struct InputTodoView: View {
    @Binding var todos: [Todo]
    @State private var newTodoDescription: String = &quot;&quot;
    var body: some View {
        HStack {
            TextField(&quot;Todo&quot;, text: $newTodoDescription)
                .textFieldStyle(.roundedBorder)
            Spacer()
            Button {
                guard !newTodoDescription.isEmpty else { return }
                todos.append(Todo(description: newTodoDescription, done: false))
                newTodoDescription = &quot;&quot;
            } label: {
                Text(&quot;Add&quot;)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 8)
                    .foregroundColor(.white)
                    .background(.green)
                    .cornerRadius(5)
            }
        }.frame(height: 60)
        .padding(.horizontal, 24)
        .padding(.bottom, 30)
        .background(Color.gray)
    }
}
</code></pre><ol start="2"><li>将InputTodoView添加到界面上</li></ol><pre><code class="language-swift">var body: some View {
    ZStack(alignment: .bottom) {
        List($todos) { $todo in
            HStack {
                Text(todo.description).strikethrough(todo.done)
                Spacer()
                Image(systemName:todo.done ? &quot;checkmark.square&quot; : &quot;square&quot;)
            }
            .contentShape(Rectangle())
            .onTapGesture {
                todo.done.toggle()
            }
        }
        InputTodoView(todos: $todos)
    }.edgesIgnoringSafeArea(.bottom)        
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyapo5ymqsj309q0jdq3i.jpg" alt="Figure_9.2_B17962"/></p><h2>How it works…</h2><p>就像我们开头说的那样，children要修改parent的state，parent直接吧state传递给children是不行的，因为传递的是值的copy。</p><p>SwiftUI使用<strong>@Binding</strong> 创建一个双向绑定</p><ul><li>parent的变化会反应到children上</li><li>children的变化也会反映到parent上</li></ul><p>我们在children声明state时，使用@Binding，parent传入时传的是$state，而不是state。$操作符的意思是获取State结构体中的projectedValue属性。我们可以看到State结构体的projectedValue正是一个Binding类型。</p><pre><code class="language-swift">var projectedValue: Binding&lt;Value&gt; { get }
</code></pre><h2>深入了解@Binding</h2><p>我们首先来看看，Binding结构体的Api</p><pre><code class="language-swift">@frozen @propertyWrapper @dynamicMemberLookup struct Binding&lt;Value&gt;
// Creating a Binding
init&lt;V&gt;(Binding&lt;V&gt;)
init(get: @escaping () -&gt; Value, set: @escaping (Value, Transaction) -&gt; Void)
init(get: @escaping () -&gt; Value, set: @escaping (Value) -&gt; Void)
</code></pre><p>我们可以看到2点</p><ul><li>Binding是能够进行dynamicMemberLookup，也就是说我们能够使用<code>$state.someproperty</code>这样的方式来进行访问，这返回什么呢？得看他的subscript是怎么实现的，我们稍后再看</li><li>我们看到初始化方法，就是get和set方法，正如开头说的那样。可以把Binding看成是get和set方法的一个封装。</li></ul><p>有了这两点了解，我们来实现一个我们自己的@MyBinding。</p><p>首先，定义一个property wrapper，包含一个get和set方法。</p><pre><code class="language-swift">@propertyWrapper
struct MyBinding&lt;T&gt; {
    private let getValue: () -&gt; T
    private let setValue: (T) -&gt; Void
    var wrappedValue: T {
        get {
            return getValue()
        }
        nonmutating set {
            setValue(newValue)
        }
    }
    
    var projectedValue: Self { self }
    
    init(getValue: @escaping () -&gt; T, setValue: @escaping (T) -&gt; Void) {
        self.getValue = getValue
        self.setValue = setValue
    }
}
</code></pre><h3>补全@MyState</h3><p>我们来用一下试一试，补全下上一篇文章的@MyState</p><pre><code class="language-swift">final class Box&lt;T&gt;: ObservableObject {
    @Published var value: T
    init(_ value: T) {
        self.value = value
    }
}
// highlight-start
@propertyWrapper
struct MyBinding&lt;T&gt; {
    private let getValue: () -&gt; T
    private let setValue: (T) -&gt; Void
    var wrappedValue: T {
        get {
            return getValue()
        }
        nonmutating set {
            setValue(newValue)
        }
    }
    
    var projectedValue: Self { self }
    
    init(getValue: @escaping () -&gt; T, setValue: @escaping (T) -&gt; Void) {
        self.getValue = getValue
        self.setValue = setValue
    }
}
// highlight-end
@propertyWrapper
struct MyState&lt;T&gt;: DynamicProperty {
    @ObservedObject var box: Box&lt;T&gt;
    var wrappedValue: T {
        get {
            return box.value
        }
        nonmutating set {
            box.value = newValue
        }
    }
  // highlight-start
    var projectedValue: MyBinding&lt;T&gt; {
        return MyBinding {
            return box.value
        } setValue: { newValue in
            box.value = newValue
        }
    }
  // highlight-end
    init(wrappedValue: T) {
        self._box = ObservedObject(wrappedValue: Box&lt;T&gt;(wrappedValue))
    }
}
// highlight-start
struct ChildView: View {
  //使用我们自己MyBinding
    @MyBinding var text: String
    var body: some View {
        VStack {
            Text(&quot;this is children: \(text)&quot;)
            Button {
                text = &quot;\(Int.random(in: 200...300))&quot;
            } label: {
                Text(&quot;change from child&quot;)
            }
        }
    }
}
// highlight-end
@available(iOS 15.0, *)
struct ContentView: View {
    @MyState var text = &quot;hello world123&quot;
    var body: some View {
        VStack {
            Text(&quot;\(text)&quot;)
            Button {
                text = &quot;\(Int.random(in: 0...100))&quot;
            } label: {
                Text(&quot;change&quot;)
            }
            ChildView(text: $text)
        }
    }
}

</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gybwbbyagxg306a0ckmy0.gif" alt="Untitled"/></p><p>现在我们已经补全了@MyState，能够使用$text了。</p><h3>实现dynamicMemberLookup</h3><p>Ok，我们刚刚能够使用<code>$text</code>了，但是如果我们想要用<code>$state.somePropert</code>呢, 我们试一试</p><pre><code class="language-swift">struct ChildView: View {
  // highlight-start
  //我们改下chidlrenView，显示字符串的数量，也就是text.count
    @MyBinding var textCount: Int
    // highlight-end
    var body: some View {
        VStack {
            Text(&quot;this show textCount: \(textCount)&quot;)
        }
    }
}

struct ContentView: View {
    @MyState var text = &quot;hello world123&quot;
    var body: some View {
        VStack {
            Text(&quot;\(text)&quot;)
            Button {
                text = &quot;\(Int.random(in: 0...100))&quot;
            } label: {
                Text(&quot;change&quot;)
            }
            // highlight-start
          // 改下传参，但是报错了，因为我们的MyBinding不支持这种语法
            ChildView(textCount: $text.count)
            // highlight-end
        }
    }
}
</code></pre><p>所以，我们用dynamicMemberLookup修饰下MyBinding。</p><pre><code class="language-swift">@propertyWrapper
// highlight-start
@dynamicMemberLookup
// highlight-end
struct MyBinding&lt;T&gt; {
    ...
  // highlight-start
    subscript&lt;Sub&gt;(dynamicMember keyPath: WritableKeyPath&lt;T, Sub&gt;) -&gt; MyBinding&lt;Sub&gt; {
        return MyBinding&lt;Sub&gt; {
            return self.wrappedValue[keyPath: keyPath]
        } setValue: { newValue in
            self.wrappedValue[keyPath: keyPath] = newValue
        }
    }
  // highlight-end
}
</code></pre><p>我们来用一下：</p><pre><code class="language-swift">struct ChildView: View {
    @MyBinding var name: String
    var body: some View {
        VStack {
            Text(&quot;name is: \(name)&quot;)
            Button {
                name = &quot;child\(Int.random(in: 1...100))&quot;
            } label: {
                Text(&quot;点击修改name&quot;)
            }
        }
    }
}

struct Person {
    var name = &quot;&quot;
    var age = 20
}

@available(iOS 15.0, *)
struct ContentView: View {
    @MyState var person = Person(name:&quot;hello&quot;)
    var body: some View {
        VStack {
            Text(&quot;person name:\(person.name) age: \(person.age)&quot;)
            Button {
                person.name = &quot;parent\(Int.random(in: 200...300))&quot;
            } label: {
                Text(&quot;change&quot;)
            }
            ChildView(name: $person.name)
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gybzwh2oflg306a0ckq3z.gif" alt="Untitled"/></p><p>不错，我们成功使用了<code>$person.name</code>。</p><p>至此，我们对Binding已经有了一定的了解，也知道了$操作符的原理，以及$state.someProperty的原理。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑065-@State]]></title>
            <link>https://gouxin.fun/2022/01/07/SwiftUI专辑-065-@State</link>
            <guid>/2022/01/07/SwiftUI专辑-065-@State</guid>
            <pubDate>Fri, 07 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
@State是一个property wrapper。他负责read/write一个SwiftUI管理的value，当我们write新的value时，SwiftUI会重新计算body。</p><p>我们来看一个TodoList的demo。</p><h2>Getting ready</h2><p>首先，新建一个项目<strong>StaticTodoList</strong></p><h2>How to do it…</h2><ol><li>新建一个Todo的model</li></ol><pre><code class="language-swift">struct Todo: Identifiable {
    let id = UUID()
    let description: String
    var done: Bool
}
</code></pre><ol start="2"><li>我们准备一点数据</li></ol><pre><code class="language-swift">@State var todos = [
    Todo(description: &quot;review the first chapter&quot;, done: false),
    Todo(description: &quot;buy wine&quot;, done: false),
    Todo(description: &quot;paint kitchen&quot;, done: false),
    Todo(description: &quot;cut the grass&quot;, done: false),
]
</code></pre><ol start="3"><li>显示出来</li></ol><pre><code class="language-swift">var body: some View {
    List($todos) { $todo in
        HStack {
            Text(todo.description).strikethrough(todo.done)
            Spacer()
            Image(systemName:todo.done ? &quot;checkmark.square&quot; : &quot;square&quot;)
        }
        .contentShape(Rectangle())
        .onTapGesture {
            todo.done.toggle()
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gyaplbkxypj309q0jndg6.jpg" alt="Figure_9.1_B17962"/></p><h2>How it works…</h2><p>注意我们使用的是$todo，而不是todo，只有用$todo才能改变todo.done，不然todo是immutable的，尝试修改todo会报编译错误。</p><p>然后我们使用了<code>.contentShape(Rectangle())</code>，这是必须的，不然只有文字和图片能够相应onTapGesture，Spacer的区域不能响应点击事件。</p><h2>深入@State</h2><p>首先@State修饰后的value并不是value本身，而是一个State结构体， 这个结构体包裹着value，负责value的read和write。</p><p>我们要get这个value，可以直接使用定义的变量名，他会返回State结构体的wrappedValue字段。</p><p>你只能在View内部访问state属性，因此通常我们都将state声明为private，防止外部访问到这些state。</p><p>如果你想要将state传递给层级中的其他view，那么你需要在前面加上$，$操作符会返回State结构体的projectedValue字段。</p><p>我们可以自己来实现一个简单的@MyState。</p><p>我们先定义一个property wrapper，定义完成后，我们就可以用@MyState了</p><pre><code class="language-swift">@propertyWrapper
struct MyState&lt;T&gt; {
    var value: T
    var wrappedValue: T {
        get {
            return value
        }
        set {
            value = newValue
        }
    }
}
</code></pre><p>我们先尝试使用</p><pre><code class="language-swift">struct ContentView: View {
   //会报错，因为，如果我们想要这么使用，还需要为@MyState实现一个 init(wrappedValue:)的初始化方法
    @MyState var text = &quot;hello world&quot;
    var body: some View {
        Text(&quot;hello world&quot;)
    }
}
@propertyWrapper
struct MyState&lt;T&gt; {
  ...
  init(wrappedValue: T) {
    value = wrappedValue
  }
}

</code></pre><p>我们再尝试使用一下, 能够显示text</p><pre><code class="language-swift">struct ContentView: View {
    @MyState var text = &quot;hello world123&quot;
    var body: some View {
        Text(&quot;\(text)&quot;)
    }
}
</code></pre><p>那我们再尝试一下，加个按钮修改text，能够自动改变Text么</p><pre><code class="language-swift">struct ContentView: View {
    @MyState var text = &quot;hello world123&quot;
    var body: some View {
        VStack {
            Text(&quot;\(text)&quot;)
            Button {
              // 编译报错，提示Cannot assign to property: &#x27;self&#x27; is immutable
              // 原因在于设置text实际上是调用wrappedValue的set方法，我们定义的MyState是结构体
              // 修改结构体需要mutating，而set方法又不能用mutating修饰
                            // 不过我们可以通过使用nonmutating修饰set方法，告诉编译器我们不会修改结构体
                text = &quot;\(Int.random(in: 0...100))&quot;
            } label: {
                Text(&quot;change&quot;)
            }
        }
    }
}

struct MyState&lt;T&gt; {
    ...
    var wrappedValue: T {
       nonmutating set {
            value = newValue//加上之后，编译器错误就转移到了这里，因为我们确实改变了结构体
        }
      ...
    }
}

</code></pre><p>我们可以构建个引用类型，用这个引用类型再包裹T，这样就不会修改结构体了</p><pre><code class="language-swift">final class Box&lt;T&gt; {
    var value: T
    init(_ value: T) {
        self.value = value
    }
}

@propertyWrapper
struct MyState&lt;T&gt; {
    var box: Box&lt;T&gt;
    var wrappedValue: T {
        get {
            return box.value
        }
        nonmutating set {
            box.value = newValue
        }
    }
    init(wrappedValue: T) {
        box = Box&lt;T&gt;(wrappedValue)
    }
}
</code></pre><p>好的，我们解决了编译问题，运行下，点按钮，发现Text仍然没有改变，打断点发现set方法是调用了的，看来我们还缺少一种方法，在value更新的情况下通知SwiftUI重新渲染UI。遗憾的是苹果并没有提供手动更新UI的能力。更新的能力被封装在了@State、@ObservedObject、@StateObject、@EnvironmentObject内部。我们选择@ObservedObject来模拟。</p><pre><code class="language-swift">@propertyWrapper
struct MyState&lt;T&gt;: DynamicProperty {
    @ObservedObject var box: Box&lt;T&gt;
    var wrappedValue: T {
        get {
            return box.value
        }
        nonmutating set {
            box.value = newValue
        }
    }
    init(wrappedValue: T) {
        self._box = ObservedObject(wrappedValue: Box&lt;T&gt;(wrappedValue))
    }
}

final class Box&lt;T&gt;: ObservableObject {
    @Published var value: T
    init(_ value: T) {
        self.value = value
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gybv1mqr89g306a0ck3yz.gif" alt="Untitled"/></p><p>Ok，通过实现MyState，我们熟悉了propertyWrapper，也对@State有了一定的了解，不过我们的@MyState还有个东西没实现，那就是projectedValue, 如果我们使用$text，将会报错，因为我们没有实现projectedValue。我们将在学习@Binding中了解其原理，并补全实现。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑064-创建一个card stack]]></title>
            <link>https://gouxin.fun/2022/01/06/SwiftUI专辑-064-实现点赞动画</link>
            <guid>/2022/01/06/SwiftUI专辑-064-实现点赞动画</guid>
            <pubDate>Thu, 06 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
还记得我们自定义UICollectionLayout时做的那种卡片效果么，多个卡片叠在一起，我们可以用滑动手势将顶部卡片移走，显示出下面的卡片。现在我们用swiftui实现同样的功能。</p><h2>Getting ready</h2><p>首先，创建一个新项目：<strong>SwipeableCards</strong></p><h2>How to do it…</h2><ol><li>首先，我们创建一个User数据结构代表每个卡片的数据</li></ol><pre><code class="language-swift">struct User: Identifiable, Equatable {
    var id: Int
    let firstName: String
    let lastName: String
    let start: Color
    let end: Color
}
</code></pre><ol start="2"><li>在ContentView中准备一点数据</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State  private var users: [User] = [
        User(id: 0, firstName: &quot;Mark&quot;, lastName: &quot;Bennett&quot;, start: .red, end: .green),
        User(id: 1, firstName: &quot;John&quot;, lastName: &quot;Lewis&quot;, start: .green, end: .orange),
        User(id: 2, firstName: &quot;Joan&quot;, lastName: &quot;Mince&quot;, start: .blue, end: .green),
        User(id: 3, firstName: &quot;Liz&quot;, lastName: &quot;Garret&quot;, start: .orange, end: .purple),
        User(id: 4, firstName: &quot;Lola&quot;, lastName: &quot;Pince&quot;, start: .yellow, end: .gray),
        User(id: 5, firstName: &quot;Jim&quot;, lastName: &quot;Beam&quot;, start: .pink, end: .yellow),
        User(id: 6, firstName: &quot;Tom&quot;, lastName: &quot;Waits&quot;, start: .purple, end: .blue),
        User(id: 7, firstName: &quot;Mike&quot;, lastName: &quot;Rooney&quot;, start: .black, end: .gray),
        User(id: 8, firstName: &quot;Jane&quot;, lastName: &quot;Doe&quot;, start: .red, end: .green),
    ]
    var body: some View {
    }
}
</code></pre><ol start="3"><li>添加一个CardView到ContentView中</li></ol><pre><code class="language-swift">var body: some View {
    GeometryReader { geometry in
        ZStack {
            ForEach(users) { user in
                if user.id &gt; users.maxId - 4 {
                    CardView(user: user, onRemove: { removedUser in
                        users.removeAll { $0.id == removedUser.id }
                    }).animation(.spring(), value: users)
                        .frame(width: users.cardWidth(in: geometry, userId: user.id), height: 400)
                        .offset(x: 0, y: users.cardOffset(userId: user.id))
                }
            }
        }
    }.padding()
}
</code></pre><ol start="4"><li>再添加一个extention计算maxId</li></ol><pre><code class="language-swift">extension Array where Element == User {
    var maxId: Int { map { $0.id }.max() ?? 0 }
    func cardOffset(userId: Int) -&gt; Double {
        Double(count - 1 - userId) * 8.0
    }
    func cardWidth(in geometry: GeometryProxy, userId: Int) -&gt; Double {
        geometry.size.width - cardOffset(userId: userId)
    }
}
</code></pre><ol start="5"><li>实现我们的CardView</li></ol><pre><code class="language-swift">extension DragGesture.Value {
    func percentage(in geometry: GeometryProxy) -&gt; Double {
        abs(translation.width / geometry.size.width)
    }
}
struct CardView: View {
    @State private var translation: CGSize = .zero
    private var user: User
    private var onRemove: (_ user: User) -&gt; Void
    private var threshold: CGFloat = 0.5
    init(user: User, onRemove: @escaping (_ user: User)-&gt; Void) {
        self.user = user
        self.onRemove = onRemove
    }
    var body: some View {
        GeometryReader { geometry in
            VStack(alignment: .leading, spacing: 20) {
                Rectangle()
                    .fill(LinearGradient(gradient:Gradient(colors: [user.start, user.end]), startPoint: .topLeading, endPoint: .bottomTrailing))
                    .cornerRadius(10)
                    .frame(width: geometry.size.width - 40, height: geometry.size.height * 0.65)
                Text(&quot;\(user.firstName) \(user.lastName)&quot;)
                    .font(.title)
                    .bold()
            }.padding(20)
            .background(Color.white)
            .cornerRadius(8)
            .shadow(radius: 5)
            .animation(.spring(), value: translation)
            .offset(x: translation.width, y: 0)
            .rotationEffect(.degrees(Double(translation.width / geometry.size.width) * 20), anchor: .bottom)
            .gesture(
                DragGesture().onChanged({ value in
                    translation = value.translation
                }).onEnded({ value in
                    if value.percentage(in: geometry) &gt; self.threshold {
                        onRemove(user)
                    } else {
                        translation = .zero
                    }
                })
            )
        }
}

</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gya5i4nw25j30b40b9mxi.jpg" alt="Figure_8.23_B17962"/></p><h2>How it works…</h2><p>尽管代码比较长，但是还是挺简单的。</p><p>我们通过限制，只显示4个卡片,如果你想要显示更多，可修改设置</p><pre><code class="language-swift">if user.id &gt; self.users.maxId - 4 {
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑063-实现点赞动画]]></title>
            <link>https://gouxin.fun/2022/01/05/SwiftUI专辑-063-实现点赞动画</link>
            <guid>/2022/01/05/SwiftUI专辑-063-实现点赞动画</guid>
            <pubDate>Wed, 05 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
还记得各种直播间中的底部不断飘起各种颜色的小红心么？</p><p>我们来实现一个这种效果。</p><h2>Getting ready</h2><p>新建一个项目：<strong>FloatingHearts</strong></p><p>引入三方库：pod &quot;SwiftCubicSpline&quot;，来实现小红心漂移路径。</p><h2>How to do it…</h2><ol><li>首先，实现我们的动效</li></ol><pre><code class="language-swift">import SwiftCubicSpline

struct MoveShakeScale: GeometryEffect {
    private(set) var pct: CGFloat
    private let xPosition = UIScreen.main.bounds.width/4 + CGFloat.random(in: -20..&lt;20)
    private let scaleSpline = CubicSpline(points: [
        Point(x: 0, y: 0.0),
        Point(x: 0.3, y: 3.5),
        Point(x: 0.4, y: 3.1),
        Point(x: 1.0, y: 2.1),
    ])

    private let xSpline = CubicSpline(points: [
        Point(x: 0.0,  y: 0.0),
        Point(x: 0.15, y: 20.0),
        Point(x: 0.3,  y: 12),
        Point(x: 0.5,  y: 0),
        Point(x: 1.0,  y: 8),
    ])

    var animatableData: CGFloat {
        get { pct }
        set { pct = newValue }
    }
    
    func effectValue(size: CGSize) -&gt; ProjectionTransform {
        let scale = scaleSpline[x: Double(pct)]
        let xOffset = xSpline[x: Double(pct)]
        let yOffset = UIScreen.main.bounds.height/2 - pct * UIScreen.main.bounds.height/4*3
        let transTrasf = CGAffineTransform(translationX: xPosition + CGFloat(xOffset), y: yOffset)
        let scaleTrasf = CGAffineTransform(scaleX: CGFloat(scale), y: CGFloat(scale))
        return ProjectionTransform(scaleTrasf.concatenating(transTrasf))
    }
}
</code></pre><ol start="2"><li>定义我们的桃心View</li></ol><pre><code class="language-swift">
extension Color {
    init(r: Double, g: Double, b: Double) {
      self.init(red: r/255, green: g/255, blue: b/255)
    }
    static func random() -&gt; Color {
        Color(r: .random(in: 100...144),
              g: .random(in: 10...200),
              b: .random(in: 200...244))
    }
}
@available(iOS 15.0, *)
struct Heart: View, Identifiable {
    let id = UUID()
    @State private var opacity = 1.0
    @State private var scale: CGFloat = 1.0
    @State private var toAnimate = false
    var body: some View {
        Image(systemName: &quot;heart.fill&quot;)
            .foregroundColor(.random())
            .opacity(opacity)
            .modifier(MoveShakeScale(pct: toAnimate ? 1 : 0))
            .animation(Animation.easeIn(duration:5.0), value: toAnimate)
            .task {
                toAnimate.toggle()
                withAnimation(.easeIn(duration: 5)) {
                    opacity = 0
                }
            }
    }
}
@available(iOS 15.0, *)
extension Heart: Equatable {
    static func == (lhs: Heart, rhs: Heart) -&gt; Bool {
        lhs.id == rhs.id
    }
}
extension Array where Element: Equatable {
    mutating func remove(object: Element) {
        guard let index = firstIndex(of: object) else { return }
        remove(at: index)
    }

}
@available(iOS 15.0, *)
class Hearts: ObservableObject {
    @Published
    private(set) var all: [Heart] = []

    func new() {
        let heart = Heart()
        all.append(heart)
        DispatchQueue.main.asyncAfter(deadline: .now() + 10.0) {
            self.all.remove(object: heart)
        }
    }
}
@available(iOS 15.0, *)
struct HeartsView: View {
    @ObservedObject
    var hearts: Hearts
    var body: some View {
        ForEach(hearts.all) { $0 }
    }
}

</code></pre><ol start="3"><li>添加到ContentView中</li></ol><pre><code class="language-swift">struct ContentView: View {
    var hearts = Hearts()
    var body: some View {
        VStack {
            Spacer()
            HStack {
                Button {
                    hearts.new()
                } label: {
                    Image(systemName: &quot;heart&quot;)
                        .font(.title)
                        .frame(width: 80, height: 80)
                        .foregroundColor(.white)
                        .background(.blue)
                        .clipShape(Circle())
                        .shadow(radius: 10)
                    }
                    Spacer()
                }.padding(.horizontal, 30)
            }
            .overlay(HeartsView(hearts: hearts))
        }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9wq95jpzj30b40o2q34.jpg" alt="kdkd"/></p><h2>How it works…</h2><p>基本思想是让四个动画并行：</p><ul><li>从底部移动到顶部</li><li>变淡</li><li>放大和缩小</li><li>向上移动时轻微晃动</li></ul><p>水平运动的曲线是一种锯齿形，我们使用<strong>SwiftCubicSpline</strong>库来进行插值。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9x5qfawzj31ia0emgm3.jpg" alt="image-20220111184118149"/></p><p>GeometryEffect返回一系列的transformation应用到View上。这里我们使用时间作为动画属性，计算出移动和缩放的值，把这两个作为一个transform应用到View上。</p><p>透明度的变化是线性的，不能是曲线，所以单独处理。</p><p>动画结束后似乎没有什么回调供我们调用，因此我们使用DispatchQueue.main.asyncAfter来移除</p><pre><code class="language-swift">DispatchQueue.main.asyncAfter(deadline: .now() + 10.0) {
    self.all.remove(object: heart)
}
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑062-创建一个弹性Header]]></title>
            <link>https://gouxin.fun/2022/01/04/SwiftUI专辑-062-创建一个弹性Header</link>
            <guid>/2022/01/04/SwiftUI专辑-062-创建一个弹性Header</guid>
            <pubDate>Tue, 04 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
什么是弹性Header？还记得你有个TableView，header是一个图片，当往下拉动tableview时，header的图片会放大。</p><p>本文将用SwiftUI实现一个类似的效果。</p><h2>Getting ready</h2><p>首先创建一个新的项目：<strong>StretchableHeader</strong></p><p>准备2张图片。</p><h2>How to do it…</h2><ol><li>我们创建一个Row， 类似于Tableview的cell</li></ol><pre><code class="language-swift">struct Row: View {
    var body: some View {
        HStack {
            Image(&quot;avatar&quot;)
                .resizable()
                .frame(width: 50, height: 50)
                .clipShape(Circle())
            Spacer()
            VStack(alignment: .trailing) {
                Text(&quot;Billie Eilish&quot;)
                    .fontWeight(.heavy)
                Text(&quot;Happier Than Ever&quot;)
            }
        }.padding(.horizontal, 15)
    }
}
</code></pre><ol start="2"><li>准备一个列表</li></ol><pre><code class="language-swift">struct ContentView: View {
    
    var body: some View {
        ScrollView(.vertical, showsIndicators: false) {
            VStack {
                ForEach(0..&lt;6) { _ in
                    Row()
                    Divider()
                }

            }
        }.edgesIgnoringSafeArea(.all)
    }
}
</code></pre><ol start="3"><li>创建我们的弹性Header</li></ol><pre><code class="language-swift">extension GeometryProxy {
    private var offset: CGFloat {
        frame(in: .global).minY
    }
    var height: CGFloat {
        size.height + (offset &gt; 0 ? offset : 0)
    }

    var verticalOffset: CGFloat {
        offset &gt; 0 ? -offset : 0
    }
}

struct StretchableHeader: View {
    let imageName: String
    var body: some View {
        GeometryReader { geometry in
            Image(self.imageName)
                .resizable()
                .scaledToFill()
                .frame(width: geometry.size.width, height: geometry.height)
                .offset(y: geometry.verticalOffset)
        }.frame(height: 350)
    }
}
</code></pre><ol start="4"><li>添加到Vstack中</li></ol><pre><code class="language-swift">struct ContentView: View {
//...
    VStack {
        StretchableHeader(imageName: &quot;header&quot;)
        ForEach(0..&lt;6) { _ in
//...
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9vw89n2pj30bo0oe75g.jpg" alt="image-20220111175733278"/></p><h2>How it works…</h2><p>诀窍在于我们计算verticalOffset的方式：当我们尝试向下滑动图像时，图像顶部变得大于<strong>0</strong>，因此我们应用负偏移来补偿由滑动引起的偏移，并且图像贴在顶部。</p><p>高度也是一样：当图像向上移动时，高度是正常的，但是当它被粘到顶部后向下移动时，高度会随着拖动而增加。</p><p>请注意，图像是用<strong>.scaledToFill()</strong>修改的，这样当e 高度增加， 宽度按比例增加，并且 有放大效应。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑061-使用Lottie动画]]></title>
            <link>https://gouxin.fun/2022/01/03/SwiftUI专辑-061-使用Lottie动画</link>
            <guid>/2022/01/03/SwiftUI专辑-061-使用Lottie动画</guid>
            <pubDate>Mon, 03 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUi使用Lottie动画还得借助于UIKit。</p><p>我们来看看如何在SwiftUI中使用Lottie动画。</p><h2>Getting ready</h2><p>新建一个SwiftUI工程</p><p>pod中加入<code>pod &#x27;lottie-ios&#x27;</code></p><p>准备好一个lottie动画的json文件</p><h2>How to do it…</h2><ol><li>创建一个LottieAnimation,把UIKit的Lottie包裹为SwiftUI View</li></ol><pre><code class="language-swift">import Lottie
import SnapKit

struct LottieAnimation: UIViewRepresentable {
    private let animationView = AnimationView()
    var animationName = &quot;&quot;
    @Binding var play: Bool

    func makeUIView(context: Context) -&gt; some UIView {
        let view = UIView()
        animationView.animation = Animation.named(animationName)
        animationView.contentMode = .scaleAspectFit
        animationView.scalesLargeContentImage = true
        view.addSubview(animationView)
        animationView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
        return view
    }

    func updateUIView(_ uiView: UIViewType, context: Context) {
        guard play else { return }
        animationView.play { _ in
            play = false
        }
    }
}
</code></pre><ol start="2"><li>添加View到ContentView中</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var play = false

    var body: some View {
        ZStack {
            Color.yellow.edgesIgnoringSafeArea(.all)
            VStack {
                LottieAnimation(animationName:&quot;fill-heart&quot;,play: $play)
                    .padding(.horizontal, 30)
                Button {
                      play = true
                } label: {
                    Text(&quot;Fill me!&quot;)
                        .fontWeight(.heavy)
                        .padding(15)
                        .background(.white)
                        .cornerRadius(10)
                }

            }
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9v2da8vcj30c00oe74o.jpg" alt="image-20220111172851670"/></p><h2>How it works…</h2><p>Lottie有个<strong>AnimationView</strong>，我们设置动画的名称就可以进行动画。</p><p>但其是UIView的子类，所以我们需要将其包裹为一个SwiftUI View。</p><p>同时我们提供了play来控制是否进行动画。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑060-创建一个hero transition]]></title>
            <link>https://gouxin.fun/2022/01/02/SwiftUI专辑-060-创建一个herotransition</link>
            <guid>/2022/01/02/SwiftUI专辑-060-创建一个herotransition</guid>
            <pubDate>Sun, 02 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
什么是hero transition？还记得我们的商品列表有个图片，点击图片，然后图片慢慢变大，成为新界面顶部的header，我们称这种为hero transition。比如：appstroe中就很常见。</p><h2>Getting ready</h2><p>首先，新建一个项目：<strong>HeroViewTransition</strong></p><p>准备7张图片，加入项目中。</p><h2>How to do it…</h2><ol><li>首先创建一个Item来代表列表中的数据</li></ol><pre><code class="language-swift">struct Item: Identifiable {
    let id = UUID()
    let image : String
    let title : String
    let details : String
}
</code></pre><ol start="2"><li>准备列表的数据</li></ol><pre><code class="language-swift">let data = [
    Item(image: &quot;california&quot;, title: &quot;California&quot;, details: &quot;California, the most populous state in the United States and the third most extensive by area, is located on the western coast of the USA and is bordered by Oregon to the north, Nevada, to the east and northeast, Arizona to the southeast and it shares an international border with the Mexican state of Baja California to the south.&quot;),
    Item(image: &quot;miami&quot;, title: &quot;Miami&quot;, details: &quot;Miami is an international city at Florida’s south-eastern tip. Its Cuban influence is reflected in the cafes and cigar shops that line Calle Ocho in Little Havana. On barrier islands across the turquoise waters of Biscayne Bay is Miami Beach, home to South Beach. This glamorous neighbourhood is famed for its colourful art deco buildings, white sand, surfside hotels and trendsetting nightclubs.&quot;),
    Item(image: &quot;las-vegas&quot;, title: &quot;Las Vegas&quot;, details: &quot;Las Vegas, is a resort city famed for its vibrant nightlife, centered around 24-hour casinos and other entertainment options. Its main street and focal point is the Strip, just over 4 miles long.Nevada is a western U.S. state defined by its great expanses of desert, and by the 24-hour casinos and entertainment for which its largest city, Las Vegas, in Nevada’s Mojave Desert.&quot;),
    Item(image: &quot;paris&quot;, title: &quot;Paris&quot;, details: &quot;Paris is the capital and most-populous city of France. Situated on the Seine River, in the north of the country, it is in the centre of the Île-de-France region, also known as the région parisienne. Paris has an area of 105.4 square kilometres and with a population of 2,273,305 people within its city limits is the most populous urban area in the European Union.&quot;),
    Item(image: &quot;dublin&quot;, title: &quot;Dublin&quot;, details: &quot;Dublin, capital of the Republic of Ireland, is on Ireland’s east coast at the mouth of the River Liffey. Its medieval buildings include 13th-century Dublin Castle and imposing St. Patrick’s Cathedral, founded in 1191. Temple Bar is a riverside nightlife and cultural quarter, home to the Irish Film Institute. Bustling, largely pedestrianised Grafton Street is the city’s principal shopping area, also famed for its buskers.&quot;),
    Item(image: &quot;bali&quot;, title: &quot;Bali&quot;, details: &quot;Bali “the world’s best island resort” with its enchanting culture, beaches, dynamic dances and music, with grand mountain views, green rainforests to trek through, rolling waves to surf and deep blue pristine seas to dive in where one can swim with dugongs, dolphins and large mantarays. Covering less than 6,000 square kilometers, this lush isle has startling geographical contrasts; verdant rice terraces and sacred, mist-wreathed volcanoes, white-sand beaches and dense tropical rain forest. as well as being home to one of the world’s most vibrant cultures of  dance and music, lavish ceremonies and artistic achievements.&quot;),
    Item(image: &quot;singapore&quot;, title: &quot;Singapore&quot;, details: &quot;Singapore, an island city-state off southern Malaysia, is a bustling cosmopolitan city that offers a world-class living environment, with a landscape populated by high-rise buildings and gardens, and is a great place to visit for a couple of days if you are travelling to Asia. In circa-1820 Chinatown stands the red-and-gold Buddha’s Tooth Relic Temple, Little India offers colourful souvenirs and Arab Street is lined with fabric shops. Singapore is also known for eclectic street fare, served in hawker centres such as Tiong Bahru and Maxwell Road.&quot;),
]
</code></pre><ol start="3"><li>准备我们的列表，和跳转后的详情界面</li></ol><pre><code class="language-swift">struct DestinationListView: View {
    @Binding var selectedItem: Item!
    @Binding var showDetail: Bool
    let animation: Namespace.ID
    var body: some View {
        ScrollView(.vertical) {
            VStack(spacing: 20) {
                ForEach(data) { item in
                    Image(item.image)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .cornerRadius(10)
                        .shadow(radius: 5)
                        .matchedGeometryEffect(id: item.image, in: animation)
                        .onTapGesture {
                            selectedItem = item
                            withAnimation {
                                showDetail.toggle()
                            }
                        }
                }
            }.padding(.all, 20)
        }
    }
}

struct DestinationDetailView: View {
    var selectedItem: Item
    @Binding var showDetail: Bool
    let animation: Namespace.ID
    var body: some View {
        ZStack(alignment: .topTrailing){
            VStack{
                Image(selectedItem.image)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .matchedGeometryEffect(id: selectedItem.image, in: animation)
                Text(selectedItem.title)
                    .font(.title)
                Text(selectedItem.details)
                    .font(.callout)
                    .padding(.horizontal)
                Spacer()
            }.ignoresSafeArea(.all)
            Button {
                withAnimation {
                    showDetail.toggle()
                }
            } label: {
                Image(systemName: &quot;xmark&quot;)
                    .foregroundColor(.white)
                    .padding()
                    .background(.black.opacity(0.8))
                    .clipShape(Circle())
            }.background(Color.white.ignoresSafeArea(.all))
    }
}
</code></pre><ol start="3"><li>在ContentView中添加List</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State private var selectedItem: Item!
    @State private var showDetail = false
    @Namespace var animation
    var body: some View {
        ZStack {
            DestinationListView(selectedItem: $selectedItem, showDetail: $showDetail, animation: animation)
                .opacity(showDetail ? 0 : 1)
            if showDetail {
                DestinationDetailView(selectedItem: selectedItem, showDetail: $showDetail, animation: animation)
            }
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9t6d7vkug306a0ck45k.gif" alt="Untitled"/></p><h2>How it works…</h2><p>您可以在<strong>.matchedGeometryEffect</strong>里设置开始组件和结束组件，然后 SwiftUI 会神奇地为您创建动画。</p><p><strong>.matchedGeometryEffect</strong>会设置开始组件和结束组件间的关系，然后SwiftUI可以根据关系创建从开始位置到结束位置的动画。为了存储这种关系，<strong>.matchedGeometryEffect</strong>需要一个标识符和一个保存关系的地方。在我们的代码中，这是在以下行中完成的：</p><pre><code class="language-swift">//我们以image为标识符，存储在animation中。
.matchedGeometryEffect(id: item.image, in: animation)
</code></pre><p>SwiftUI提供了一个property warpper:<strong>@Namespace</strong>。他会将view动画相关的一些属性存储在全局的某个地方，SwiftUI使用这些属性来创建动画，然后渲染。</p><p>简单来说就是：通过<strong>.matchedGeometryEffect</strong>，我们定义了一个开始组件和一个结束组件。然后我们告诉SwiftUI，他们是同一个组件，然后SwiftUI自己会确定如何进行动画。在我们的例子中，动画就包括：</p><ul><li>y offset的改变</li><li>size的改变</li><li>圆角的改变</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑059-自定义view transitions]]></title>
            <link>https://gouxin.fun/2022/01/01/SwiftUI专辑-059-自定义viewtransitions</link>
            <guid>/2022/01/01/SwiftUI专辑-059-自定义viewtransitions</guid>
            <pubDate>Sat, 01 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI能够在view出现和消失时添加动画，我们称这个未transition。</p><p>本章，我们将演示如何创建自定义的出现和消失的transitions。</p><h2>Getting ready</h2><p>首先，创建一个新的项目<strong>CustomViewTransition</strong></p><h2>How to do it…</h2><ol><li>创建2个view</li></ol><pre><code class="language-swift">extension Image {
    func custom() -&gt; some View {
        self
        .resizable()
        .aspectRatio(contentMode: .fit)
        .cornerRadius(20)
        .shadow(radius: 10)
    }
}

struct FirstComponent: View {
    var body: some View {
        Image(systemName: &quot;gamecontroller&quot;).custom()
    }
}

struct SecondComponent: View {
    var body: some View {
        Image(systemName: &quot;car&quot;).custom()
    }
}
</code></pre><ol start="2"><li>添加到ContentView中, 这个时候点击change，是一个渐变的消失和显示的过程</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var showFirst = true
    var body: some View {
        VStack(spacing: 24){
            if showFirst {
                FirstComponent()
            } else{
                SecondComponent()
            }
            Button {
                showFirst.toggle()
            } label: {
                Text(&quot;Change&quot;)
            }
        }.animation(.easeIn, value: showFirst)
            .padding(.horizontal, 20)
    }
}
</code></pre><ol start="3"><li>让我们创建一个transition，并设置两个component的transiton为这个自定义的transition</li></ol><pre><code class="language-swift">extension AnyTransition {
    static var moveScaleAndFade: AnyTransition {
        let insertion = AnyTransition
            .scale
            .combined(with: .move(edge: .leading))
            .combined(with: .opacity)
        let removal = AnyTransition
            .scale
            .combined(with: .move(edge: .top))
            .combined(with: .opacity)
        return .asymmetric(insertion: insertion, removal: removal)
    }
}

...
if showFirst {
    FirstComponent().transition(.moveScaleAndFade)
} else{
    SecondComponent().transition(.moveScaleAndFade)
}
....
</code></pre><p>点击change, appear的图片从左侧逐渐放大移入，disappear的从上面逐渐缩小移除。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9rutfd80j30ay0nst90.jpg" alt="image-20220111153748091"/></p><h2>How it works…</h2><p>transition基本上就是在appear和disappear时应用的一系列transformations。</p><p>我们使用<strong>.combined</strong>函数，可以将transition与其他transition组合以创建更复杂的动画。</p><p>我们使用了<strong>.asymmetric</strong> transition。这意味着删除看起来与插入不同。但当然，我们也可以有一个对称的transition。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑058-同时进行多个animation]]></title>
            <link>https://gouxin.fun/2021/12/31/SwiftUI专辑-058-同时进行多个animation</link>
            <guid>/2021/12/31/SwiftUI专辑-058-同时进行多个animation</guid>
            <pubDate>Fri, 31 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI 允许 我们可以同时为多个属性设置动画，也可以使用不同的持续时间和不同的动画曲线对它们进行动画处理。</p><p>本章，我们将学习如何为两组特征设置动画，以及如何使结果看起来像一个单一的、平滑的动画。</p><h2>Getting ready</h2><p>首先，新建一个项目：<strong>MultipleAnimations</strong></p><h2>How to do it…</h2><ol><li>创建个rectangle，根据State改变多个属性</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var initialState = true
    var body: some View {
        VStack(spacing: 30) {
            Rectangle()
                .fill(initialState ? .blue : .red)
                .cornerRadius(initialState ? 50 : 0)
                .offset(y: initialState ? 0 : -200)
                .rotation3DEffect(initialState ? .degrees(0): .degrees(45), axis: (x: 1, y: 0, z: 0))
                .animation(.easeInOut(duration: 2), value: initialState)
               .frame(width:300, height:200)
        }
    }
}
</code></pre><ol start="2"><li>VStack中添加个按钮触发动画</li></ol><pre><code class="language-swift">Button {
    initialState.toggle()
} label: {
    Text(&quot;Animate&quot;)
        .fontWeight(.heavy)
        .foregroundColor(.white)
        .padding()
        .background(.green)
        .cornerRadius(5)
}
</code></pre><ol start="3"><li>尝试在添加2中变化</li></ol><pre><code class="language-swift">Rectangle()
.fill(initialState ? .blue : .red)
.cornerRadius(initialState ? 50 : 0)
.offset(y: initialState ? 0 : -200)
.rotation3DEffect(initialState ? .degrees(0): .degrees(45), axis: (x: 1, y: 0, z: 0))
.scaleEffect(initialState ? 1 : 0.8)
.rotationEffect(initialState ? Angle(degrees:0) : Angle(degrees:-90))
.animation(.linear(duration: 1), value: initialState)
.frame(width: 300, height: 200)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9qht0ovfj30hw0bq3z1.jpg" alt="Figure_8.7_B17962"/></p><h2>How it works…</h2><p>animation是对之前的所有修饰符，所以我们在animate修饰符前直接修改对应的属性就行。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑057-用withAnimation创建一组动画]]></title>
            <link>https://gouxin.fun/2021/12/30/SwiftUI专辑-057-用withAnimation创建一组动画</link>
            <guid>/2021/12/30/SwiftUI专辑-057-用withAnimation创建一组动画</guid>
            <pubDate>Thu, 30 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
创建动画有2中方式：</p><ul><li>使用 <strong>.animation()</strong> 修饰符</li><li>使用 <strong>withAnimation</strong> 函数</li></ul><p>上一章，我们介绍了用animation修饰符创建一组动画，本章我们将介绍用withAnimation函数结合delay创建一组动画。</p><h2>Getting ready</h2><p>首先新建一个项目：<strong>DelayedAnimations</strong></p><h2>How to do it…</h2><ol><li>首先定义个extention，方便我们处理样式</li></ol><pre><code class="language-swift">struct CustomText: ViewModifier {
    let foreground: Color
    let background: Color
    let cornerRadius: Double

    func body(content: Content) -&gt; some View {
        content
            .foregroundColor(foreground)
            .frame(width: 200)
            .padding()
            .background(background)
            .cornerRadius(cornerRadius)
    }
}

extension Text {
    func styled(color: Color) -&gt; some View {
            modifier(CustomText(foreground: .white,
                                background: color,
                                cornerRadius: 10))    
        }
}
</code></pre><ol start="2"><li>添加3个Text</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var hideFirst = true
    @State var hideSecond = true
    @State var hideThird = true
    
    var body: some View {
        VStack {
            VStack {
                Text(&quot;First&quot;).styled(color: .red).opacity(hideFirst ? 0 : 1)
                Text(&quot;Second&quot;).styled(color: .red).opacity(hideSecond ? 0 : 1)
                Text(&quot;Third&quot;).styled(color: .red).opacity(hideThird ? 0 : 1)
            }
        }
    }
}
</code></pre><ol start="3"><li>在第一个Vstack中加个Spacer和一个Button来触发动画</li></ol><pre><code class="language-swift">Spacer()
Button {
    withAnimation(.easeInOut) {
        hideFirst.toggle()
    }
    withAnimation(.easeInOut.delay(0.3)) {
        hideSecond.toggle()
    }
    withAnimation(.easeInOut.delay(0.6)) {
        hideThird.toggle()
    }
} label: {
    Text(&quot;Animate&quot;).fontWeight(.heavy).styled(color: .green)
}
</code></pre><p>点击animate，我们能够看到3个按钮依次出现，再点一次依次消失</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9pbwnj1bj30ce0p2q3f.jpg" alt="image-20220111141025243"/></p><h2>How it works…</h2><p>这个原理和animate修饰符一样，都是通过delay来实现一组动画。我们还是期待官方提供更合适的方法来实现一组动画。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑056-用修饰符的delay创建一组动画]]></title>
            <link>https://gouxin.fun/2021/12/29/SwiftUI专辑-056-用修饰符的delay创建一组动画</link>
            <guid>/2021/12/29/SwiftUI专辑-056-用修饰符的delay创建一组动画</guid>
            <pubDate>Wed, 29 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
目前已经是SwiftUI 3 了，但仍然无法将不同的动画连接在一起以创建一组动画。这肯定会在以后的 SwiftUI 版本中修复，但目前，我们可以使用延迟来实现一组动画。</p><p>我们知道，定义动画有两种方法：</p><ul><li>使用<strong>.animation()</strong>修饰符</li><li>使用<strong>withAnimation</strong>函数</li></ul><p>本章，我们将看到如何使用<strong>.animation()</strong>修饰符来创建一组动画，我们将在下一章中介绍<strong>withAnimation</strong>函数来创建一组动画。</p><h2>Getting ready</h2><p>首先，创建一个新的项目：<strong>DelayedAnimations</strong></p><h2>How to do it…</h2><p>此次我们将创建一个长方形，并加上一组动画：</p><ul><li>修改y offset</li><li>修改scale</li><li>围绕x轴的一个3D旋转</li></ul><ol><li>创建我们的长方形</li></ol><pre><code class="language-swift">struct ContentView: View {
    let duration = 1.0
    @State var change = false
    
    var body: some View {
        VStack(spacing: 30) {
            Rectangle()
                .fill(.blue)
                .offset(y: change ? -300 : 0)
                .animation(.easeInOut(duration: duration).delay(0), value: change)
                .scaleEffect(change ? 0.5 : 1)
                .animation(.easeInOut(duration: duration).delay(duration), value: change)
                .rotation3DEffect(change ? .degrees(45) : .degrees(0), axis: (x: 1, y: 0, z: 0))
                .animation(.easeInOut(duration: duration).delay( 2 * duration), value: change)
                .frame(width: 200, height: 200)
        }
    }
}
</code></pre><ol start="2"><li>创建一个按钮，触发动画</li></ol><pre><code class="language-swift">Button  {
    change.toggle()
} label: {
    Text(&quot;Animate&quot;)
        .fontWeight(.heavy)
        .foregroundColor(.white)
        .padding()
        .background(.green)
        .cornerRadius(5)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9l40cqryj30bu0oumxd.jpg" alt="image-20220111114426505"/></p><h2>How it works…</h2><p>当我们定义动画的时候，我们可以给他一个延迟。</p><p>每一个animate都是基于之前的修饰符进行动画的。</p><p>首先执行的是offset动画，结束后，第二个动画刚开始，他是基于当前offset进行scaleEffect。同理第三个rotation3DEffect。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑055-创建spring动画]]></title>
            <link>https://gouxin.fun/2021/12/28/SwiftUI专辑-055-创建spring动画</link>
            <guid>/2021/12/28/SwiftUI专辑-055-创建spring动画</guid>
            <pubDate>Tue, 28 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
我们将演示如何让一个banner做spring动画。</p><h2>Getting ready</h2><p>首先，创建一个新的项目：<strong>BannerWithASpringAnimation</strong></p><h2>How to do it…</h2><ol><li>实现我们的banner</li></ol><pre><code class="language-swift">struct BannerView: View {
    let message: String
    var show: Bool
    
    var body: some View {
        Text(message)
            .font(.title)
            .frame(width:UIScreen.main.bounds.width - 20, height: 100)
            .foregroundColor(.white)
            .background(Color.green)
            .cornerRadius(10)
            .offset(y: show ? -UIScreen.main.bounds.height / 3 : -UIScreen.main.bounds.height)
            .animation(.interpolatingSpring(mass: 2.0,  stiffness: 100.0, damping: 10, initialVelocity: 0), value: show)
    }
}
</code></pre><ol start="2"><li>添加Banner和一个按钮到ContentView中</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var show = false
    
    var body: some View {
        VStack {
            BannerView(message: &quot;Hello world&quot;, show: show)
            Button {
                show.toggle()
            } label: {
                Text(show ? &quot;Hide&quot; : &quot;Show&quot;)
                    .padding()
                    .frame(width: 100)
                    .foregroundColor(.white)
                    .background(show ? .red : .blue)
                    .cornerRadius(10)
            }
        }
    }
}
</code></pre><p>最终结果:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9k8curm7j30c60p03yu.jpg" alt="image-20220111111402096"/></p><p>我们再复习一下动画的3个要素：</p><ul><li>触发器：我们的按钮</li><li>数据变化：show</li><li>UI变化：offset(y:)</li></ul><p>我们再来看看spring动画的一些参数：</p><ul><li><strong>mass</strong>：这是附着在弹簧上的物体的质量——它越大，它获得的惯性越大，所以它反弹得更多。</li><li><strong>stiffness</strong>：这是施加力时弹簧的抵抗力——阻力越大，弹簧的刚度越大。</li><li><strong>damping</strong>：这是弹簧抵抗变化的程度——阻力越大，弹簧的弹跳越小。</li><li><strong>initialVelocity</strong>：这是动画开始的初始速度。</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑054-自定义动画属性]]></title>
            <link>https://gouxin.fun/2021/12/27/SwiftUI专辑-054-自定义动画属性</link>
            <guid>/2021/12/27/SwiftUI专辑-054-自定义动画属性</guid>
            <pubDate>Mon, 27 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
上一篇文章中我们知道了，Swiftui能够对一些通用属性进行动画，比如：位置、颜色、大小等。</p><p>但如果我们想要动画的东西不属于framework的一部分呢？</p><p>在这篇文章中，我们将创建一个三角形，其高度等于宽度乘以一个比例。当我们点击三角形时，我们将该比例设置为一个随机数，从而改变高度。</p><p>我们如何让SwiftUI 能够对比例的变化进行动画呢？我们将看到所需的代码很简单，但底层引擎却相当复杂。</p><h2>Getting ready</h2><p>首先，创建一个新的项目：<strong>AnimateTriangleShape</strong></p><h2>How to do it…</h2><ol><li>首先，创建一个三角形<strong>Triangle</strong></li></ol><pre><code class="language-swift">struct Triangle: Shape {
    var multiplier: CGFloat
    func path(in rect: CGRect) -&gt; Path {
        Path { path in
            path.move(to: CGPoint(x: rect.minX, y: rect.maxY))
            path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
            path.addLine(to: CGPoint(x: rect.midX, y: rect.maxY - rect.width * multiplier))
            path.closeSubpath()
        }
    }
}
</code></pre><ol start="2"><li>将三角形添加到ContentView中</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var multiplier = 1.0
    var body: some View {
        Triangle(multiplier: multiplier)
            .fill(.red)
            .frame(width: 300, height: 300)
            .onTapGesture {
              
                withAnimation(.easeOut(duration: 1.0)) {
                    multiplier = .random(in: 0.3...1.5)
                }
            }
    }
}
</code></pre><ol start="3"><li>此时点击，虽然shape变化了，但是却没有动画，因为SwiftUI并不知道他应该animate哪个数据，因此我们添加一个<strong>animatableData</strong>到Triangle中, 让swiftui知道应该animate multiplier这个数据。</li></ol><pre><code class="language-swift">var animatableData: CGFloat {
    get { multiplier }
    set { multiplier = newValue }
}
</code></pre><p>此时点击，就能看到动画了</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy9jia1lgkj30c00oiglw.jpg" alt="image-20220111104856015"/></p><h2>How it works…</h2><p>SwiftUI只能对遵循了<strong>Animatable</strong>协议的组件进行动画。这意味着他应该拥有一个<strong>animatableData</strong>，SwiftUI从这个值里保存和获取动画的中间值。</p><p>我们可以在set方法里打印出中间值</p><pre><code class="language-swift">set {
    multiplier = newValue
    print(&quot;value: \(multiplier)&quot;)
}
</code></pre><p>另外还注意一下，我们使用的是<strong>withAnimation</strong>进行动画的。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑053-创建基本动画]]></title>
            <link>https://gouxin.fun/2021/12/26/SwiftUI专辑-053-创建基本动画</link>
            <guid>/2021/12/26/SwiftUI专辑-053-创建基本动画</guid>
            <pubDate>Sun, 26 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
我们来实现，将2个圆圈从顶部移动到底部。</p><h2>Getting ready</h2><p>首先，创建一个新的SwiftUI工程：<strong>BasicAnimations</strong></p><h2>How to do it…</h2><ol><li>首先，我们定义一个包含默认时间曲线的类型，供我们List选择</li></ol><pre><code class="language-swift">struct AnimationType {
    let name: String
    let animation: Animation
    static var all: [AnimationType]  = [
      .init(name: &quot;default&quot;, animation: .default),
      .init(name: &quot;easeIn&quot;, animation: .easeIn),
      .init(name: &quot;easeOut&quot;, animation: .easeOut),
      .init(name: &quot;easeInOut&quot;, animation: .easeInOut),
      .init(name: &quot;linear&quot;, animation: .linear),
      .init(name: &quot;spring&quot;, animation: .spring()),
    ]
}
</code></pre><ol start="2"><li>然后在ContentView中添加几个状态，供我们使用</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var onTop = false //是否在顶部，控制是从上到下，还是从下到上
    @State var showSelection = false //是否显示动画选择界面
  //当前选择的动画类型
    @State var type = AnimationType(name: &quot;default&quot;, animation: .default)

    var body: some View {
        Text(&quot;&quot;)
    }
}
</code></pre><ol start="3"><li>添加两个圆圈</li></ol><pre><code class="language-swift">var body: some View {
    VStack(spacing: 12) {
        GeometryReader { geometry in
            HStack {
                Circle()
                    .fill(.blue)
                    .frame(width: 80, height: 80)
                    .offset(y: onTop ? -geometry.size.height/2 : geometry.size.height/2)
                    .animation(.default, value: onTop)
                Spacer()
                Circle()
                    .fill(.red)
                    .frame(width: 80, height: 80)
                    .offset(y: onTop ? -geometry.size.height/2 : geometry.size.height/2)
                    .animation(type.animation, value: onTop)
            }.padding(.horizontal, 30)
        }
    }
}
</code></pre><ol start="4"><li>添加个actionsheet，让我们选择动画类型</li></ol><pre><code class="language-swift">var actionSheet: ActionSheet {
    ActionSheet(title: Text(&quot;Animations&quot;),
                message: nil,
                buttons: AnimationType.all.map{ type in
            .default(Text(type.name)) {
                self.type = type
            }
    } + [.destructive(Text(&quot;Cancel&quot;))])
}   
</code></pre><ol start="5"><li>在VStack中添加2个按钮，来触发动画，和选择动画类型</li></ol><pre><code class="language-swift">Button(&quot;Animate&quot;) {
    onTop.toggle()
}
Button(&quot;Choose Animation&quot;) {
    showSelection.toggle()
}.actionSheet(isPresented: $showSelection) {
    actionSheet
}
Text(&quot;Current: \(type.name)&quot;)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6eo50lgfj30bu0oiq39.jpg" alt="image-20220108174450179"/></p><h2>How it works…</h2><p>我们可以看到做动画有3步：</p><ul><li>某个触发动画的事件，比如我们的按钮点击</li><li>某个状态，我们根据这个状态修改数据，比如onTop</li><li>UI状态的改变，比如我们的offset(y:)</li></ul><p>有了这3点，我们添加一个 <strong>.animation()</strong>修饰符，SwiftUI就会在触发时完成动画。</p><p>如果你希望动画慢一点，好看清不同动画的区别，那么你可以设置speed</p><pre><code class="language-swift">.animation(Animation.default.speed(0.1), value: onTop)
</code></pre><h2>Animation的Api</h2><h3>Instance Methods</h3><pre><code class="language-swift">func delay(_ delay: Double) -&gt; Animation//延迟
func repeatCount(_ repeatCount: Int, autoreverses: Bool = true) -&gt; Animation//重复
func repeatForever(autoreverses: Bool = true) -&gt; Animation
func speed(_ speed: Double) -&gt; Animation
</code></pre><h3>Type Methods</h3><pre><code class="language-swift">//我们熟悉的时间曲线，动画时间是一个参数，并不是单独的修饰符
static func easeIn(duration: Double) -&gt; Animation
static func easeInOut(duration: Double) -&gt; Animation
static func easeOut(duration: Double) -&gt; Animation
static func interactiveSpring(response: Double = 0.15, dampingFraction: Double = 0.86, blendDuration: Double = 0.25) -&gt; Animation
static func interpolatingSpring(mass: Double = 1.0, stiffness: Double, damping: Double, initialVelocity: Double = 0.0) -&gt; Animation
static func linear(duration: Double) -&gt; Animation
static func spring(response: Double = 0.55, dampingFraction: Double = 0.825, blendDuration: Double = 0) -&gt; Animation
static func timingCurve(_ c0x: Double, _ c0y: Double, _ c1x: Double, _ c1y: Double, duration: Double = 0.35) -&gt; Animation
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑052-绘制饼状图]]></title>
            <link>https://gouxin.fun/2021/12/25/SwiftUI专辑-052-绘制饼状图</link>
            <guid>/2021/12/25/SwiftUI专辑-052-绘制饼状图</guid>
            <pubDate>Sat, 25 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
我们知道饼图是一种通过使用形成圆圈的切片来表示比例数值的方法。饼图由一个切片和一个圆组成, 在 SwiftUI 中实现它们非常简单。</p><p>本章将显示用饼状图显示三个不同欧洲城市的宠物数量。</p><h2>Getting ready</h2><p>首先，创建一个新的SwiftUI项目：<strong>PieChart</strong></p><h2>How to do it…</h2><ol><li>首先，定义数据结构</li></ol><pre><code class="language-swift">enum Animal: String {
   case cat
   case dog
   case fish
   case horse
   case hamster
   case rabbit
   case bird
   var color: Color {
       switch self {
       case .cat: return .red
       case .dog: return .blue
       case .fish: return .green
       case .horse: return .orange
       case .hamster: return .purple
       case .rabbit: return .gray
       case .bird: return .yellow
       }
   }
}

struct PetData {
    let value: Double
    let animal: Animal
    var color: Color {
        animal.color
    }
    var name: String {
        animal.rawValue.capitalized
    }
}

struct DataPoint: Identifiable {
    let id = UUID()
    let label: String
    let value: Double
    let color: Color
    var percentage = 0.0
    var startAngle = 0.0
    var formattedPercentage: String {
        String(format: &quot;%.2f %%&quot;, percentage * 100)
    }
}

struct DataPoints {
    var points = [DataPoint]()
    mutating func add(value: Double, label: String, color: Color) {
        points.append(DataPoint(label: label, value: value, color: color))
        let total = points.map(\.value).reduce(0.0,+)
        points = points.map {
            var point = $0
            point.percentage = $0.value / total
            return point
        }

        for i in 1..&lt;points.count {
            let previous =  points[i - 1]
            let angle = previous.startAngle + previous.value*360/total
            var current = points[i]
            current.startAngle = angle
            points[i] = current
        }
    }
}
</code></pre><ol start="2"><li>准备数据</li></ol><pre><code class="language-swift">struct DataSet {
    static let dublin: [PetData] = [
        .init(value: 2344553, animal: .cat),
        .init(value: 1934345, animal: .dog),
        .init(value: 323454, animal: .fish),
        .init(value: 403400, animal: .rabbit),
        .init(value: 1003445, animal: .horse),
        .init(value: 1600494, animal: .hamster),
    ]

    static let milan: [PetData] = [
        .init(value: 3344553, animal: .cat),
        .init(value: 2004345, animal: .dog),
        .init(value: 923454, animal: .fish),
        .init(value: 803400, animal: .rabbit),
        .init(value: 1642345, animal: .bird),
        .init(value: 804244, animal: .hamster),
    ]

    static let london: [PetData] = [
        .init(value: 3355553, animal: .cat),
        .init(value: 4235345, animal: .dog),
        .init(value: 1913454, animal: .fish),
        .init(value: 1103400, animal: .rabbit),
        .init(value: 683445, animal: .horse),
        .init(value: 3300494, animal: .hamster),
    ]
}
</code></pre><ol start="3"><li>定义饼的形状</li></ol><pre><code class="language-swift">struct PieSliceShape: InsettableShape {
    var percent: Double
    var startAngle: Angle
    var insetAmount: CGFloat = 0

    func inset(by amount: CGFloat) -&gt; some InsettableShape {
        var slice = self
        slice.insetAmount += amount
        return slice
    }

    func path(in rect: CGRect) -&gt; Path {
        Path { path in
            path.addArc(center: CGPoint(x: rect.size.width / 2, y: rect.size.width / 2), radius: rect.size.width / 2 - insetAmount, startAngle: startAngle, endAngle: startAngle + Angle(degrees: percent * 360), clockwise: false)
        }
    }
}

struct PieSlice: View {
    var percent: Double
    var degrees: Double
    var color: Color

    var body: some View {
        GeometryReader { geometry in
            PieSliceShape(percent: percent, startAngle: Angle(degrees: degrees))
                .strokeBorder(color, lineWidth:geometry.size.width/2)
                .rotationEffect(.degrees(-90))
               .aspectRatio(contentMode: .fit)
        }
    }
}
</code></pre><ol start="4"><li>定义整个饼图</li></ol><pre><code class="language-swift">struct PieChart: View {
    var dataPoints: DataPoints
    var body: some View {
        VStack(alignment: .leading, spacing: 30) {
            VStack(alignment: .leading) {
                ForEach(dataPoints.points) { p in
                    HStack(spacing: 16) {
                        Rectangle()
                       .foregroundColor(p.color)
                       .frame(width: 16, height: 16)
                        Text(&quot;\(p.label): \(p.formattedPercentage)&quot;)
                    }
                }
            }
            ZStack {
                ForEach(dataPoints.points) { point in
                  PieSlice(percent: point.percentage, degrees: point.startAngle, color: point.color)
                }
            }.aspectRatio(contentMode: .fill)
        }
    }
}
</code></pre><ol start="5"><li>显示数据</li></ol><pre><code class="language-swift">struct ContentView: View {
    var dataSet: [DataPoints] = [
        DataSet.dublin.reduce(into: DataPoints()) {
          $0.add(value: $1.value, label: $1.name, color: $1.color)
        },
        DataSet.milan.reduce(into: DataPoints()) {
            $0.add(value: $1.value, label: $1.name, color: $1.color)
        },
        DataSet.london.reduce(into: DataPoints()) {
            $0.add(value: $1.value, label: $1.name, color: $1.color)
        },
    ]

    @State var selectedCity = 0
    var body: some View {
        VStack (spacing: 50) {
            Text(&quot;Most Popular Pets&quot;)
                .font(.system(size: 32))

            Picker(selection: self.$selectedCity, label: Text(&quot;Most Popular Pets&quot;)) {
                Text(&quot;Dublin&quot;).tag(0)
                Text(&quot;Milan&quot;).tag(1)
                Text(&quot;London&quot;).tag(2)
            }.pickerStyle(SegmentedPickerStyle())
            PieChart(dataPoints: dataSet[selectedCity])
                .aspectRatio(1, contentMode: .fit)
            Spacer()
        }
        .padding(.horizontal, 20)
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy4fedd6c9j30ca0oqdgs.jpg" alt="image-20220107003859213"/></p><h2>How it works</h2><p>我们使用了<strong>InsettableShape</strong>， 这允许我们使用<strong>strokeBorder()</strong>而不是<strong>stroke()</strong>。之前我们已经介绍过他们的区别了：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy4fggol78j309q04paa0.jpg" alt="Figure_7.15_B17962"/></p><p>有了strokeBorder()，我们只要让border等于圆的半径，那么就能看到一块圆饼。</p><p>为了拿到圆的半径，我们使用了GeometryReader，能够通过geometry.size拿到大小。</p><p>使用rotationEffect，将绘制开始的位置变为中间，这样每个圆饼的中间都会是分割线。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑051-绘制柱状图]]></title>
            <link>https://gouxin.fun/2021/12/24/SwiftUI专辑-051-绘制柱状图</link>
            <guid>/2021/12/24/SwiftUI专辑-051-绘制柱状图</guid>
            <pubDate>Fri, 24 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
使用简单的形状，可以构建一些不错的功能。例如，只需使用一堆矩形，我们就可以创建一个柱状图。</p><p>本文，我们将创建一个条形图显示了三个欧洲城市的平均月降水量：都柏林、米兰和伦敦。</p><h2>Getting ready</h2><p>首先，创建一个新的项目：<strong>BarChart</strong>。</p><h2>How to do it…</h2><ol><li>定义数据model</li></ol><pre><code class="language-swift">enum Month: String, CaseIterable {
    case jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
}

struct MonthDataPoint: Identifiable {
    var id: String { month.rawValue }
    let month: Month
    let value: Double
    var name: String {
        month.rawValue.capitalized
    }
}
extension Array where Element == Double {
    func monthDataPoints() -&gt; [MonthDataPoint] {
        zip(Month.allCases, self)
            .map(MonthDataPoint.init)
    }
}

</code></pre><ol start="2"><li>准备数据</li></ol><pre><code class="language-swift">struct DataSet {
    static let dublin = [ 0.65, 0.50, 0.55, 0.55, 0.60, 0.65, 0.55, 0.75, 0.60, 0.80, 0.75, 0.75].monthDataPoints()
    static let milan = [0.65, 0.65, 0.80, 0.80, 0.95, 0.65,0.70, 0.95, 0.70, 1.00, 1.00, 0.60].monthDataPoints()
    static let london = [ 0.55, 0.40, 0.40, 0.45, 0.50, 0.45,0.45, 0.50, 0.50, 0.70, 0.60, 0.55,].monthDataPoints()
}
</code></pre><ol start="3"><li>定义我们的柱状图</li></ol><pre><code class="language-swift">struct BarView: View {
    var dataPoint: MonthDataPoint
    var body: some View {
        VStack {
            ZStack (alignment: .bottom) {
                Rectangle()
                    .fill(.blue)
                    .frame(width: 18, height: 180)
                Rectangle()
                    .fill(.white)
                    .frame(width: 18, height: dataPoint.value * 180.0)
            }
            Text(dataPoint.name)
                .font(.system(size: 11))
                .rotationEffect(.degrees(-45))
        }
    }
}

struct BarChartView: View {
    var dataPoints: [MonthDataPoint]
    var body: some View {
        HStack (spacing: 12) {
            ForEach(dataPoints) {
                BarView(dataPoint: $0)
            }
        }
    }
}
</code></pre><ol start="4"><li>用Picker将3个城市的数据显示出来</li></ol><pre><code class="language-swift">struct ContentView: View {
    let dataSet = [
        DataSet.dublin,
        DataSet.milan,
        DataSet.london,
    ]
    @State var selectedCity = 0
    var body: some View {
        VStack(spacing: 24) {
            Spacer()
            Text(&quot;Average Precipitation&quot;)
                .font(.system(size: 32))
            Picker(selection: self.$selectedCity, label: Text(&quot;Average Precipitation&quot;)) {
                Text(&quot;Dublin&quot;).tag(0)
                Text(&quot;Milan&quot;).tag(1)
                Text(&quot;London&quot;).tag(2)
            }.pickerStyle(SegmentedPickerStyle())
            BarChartView(dataPoints: dataSet[selectedCity])
            Spacer()
        }
        .padding(.horizontal, 10)
        .background( .mint, ignoresSafeAreaEdges: .vertical)
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy4es1j0byj30ca0p2gmj.jpg" alt="image-20220107001731926"/></p><h2>How it works…</h2><p>我们用一个ZStack和2个Rectangle做成了一个柱状图，一个空矩形 用于背景和一个矩形显示百分比。再将多个柱状图组合起来形成图表。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑050-使用渐变]]></title>
            <link>https://gouxin.fun/2021/12/23/SwiftUI专辑-050-使用渐变</link>
            <guid>/2021/12/23/SwiftUI专辑-050-使用渐变</guid>
            <pubDate>Thu, 23 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI 有几种渲染渐变的方式。渐变可用于填充 一个Shape，填充一个边框等。</p><p>本文，我们将了解我们可以在 SwiftUI 中使用哪些类型的渐变以及如何定义它们。</p><h2>Getting ready</h2><p>首先 ，创建一个SwiftUI工程：<strong>GradientViews</strong></p><h2>How to do it…</h2><p>SwiftUI有3中类型的渐变：</p><ul><li>Linear gradients</li><li>Radial gradients</li><li>Angular gradients</li></ul><ol><li>首先，我们先添加一个自定义样式, 方便我们之后使用</li></ol><pre><code class="language-swift">extension Text {
    func bigLight() -&gt; some View {
        font(.system(size: 80))
            .fontWeight(.thin)
            .multilineTextAlignment(.center)
            .foregroundColor(.white)
    }
}
</code></pre><ol start="2"><li>创建一个线性渐变View：</li></ol><pre><code class="language-swift">struct LinearGradientView: View {
    var body: some View {
        ZStack {
            LinearGradient(gradient: Gradient(colors:[.orange, .green, .blue, .black]), startPoint: .topLeading, endPoint: .bottomTrailing)
            Text(&quot;Linear Gradient&quot;)
                .bigLight()
        }
    }
}
</code></pre><ol start="3"><li>同理，在创建RadialGradientView</li></ol><pre><code class="language-swift">struct RadialGradientView: View {
    var body: some View {
        ZStack {
            RadialGradient(gradient:Gradient(colors:[.orange, .green,.blue, .black]), center: .center, startRadius: 20, endRadius: 500)
            Text(&quot;Radial Gradient&quot;)
                .bigLight()
        }
    }
}
</code></pre><ol start="4"><li>同理，再创建AngularGradientView</li></ol><pre><code class="language-swift">struct AngularGradientView: View {
    var body: some View {
        ZStack {
            AngularGradient(gradient: Gradient(colors: [.orange, .green,.blue, .black,.black, .blue,.green, .orange]),center: .center)
            Text(&quot;Angular Gradient&quot;)
                .bigLight()
        }
    }
}
</code></pre><ol start="5"><li>用Picker显示出来</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State private var selectedGradient = 0
    @ViewBuilder var content: some View {
        switch selectedGradient {
        case 0: LinearGradientView()
        case 1: RadialGradientView()
        default: AngularGradientView()
        }
    }
    var body: some View {
        ZStack(alignment: .top) {
            content.edgesIgnoringSafeArea(.all)
            Picker(selection: $selectedGradient, label: Text(&quot;Select Gradient&quot;)) {
                    Text(&quot;Linear&quot;).tag(0)
                    Text(&quot;Radial&quot;).tag(1)
                    Text(&quot;Angular&quot;).tag(2)
                }.pickerStyle(SegmentedPickerStyle())
                .padding(.horizontal, 32)
            }
    }
}
</code></pre><p>​	<img src="https://tva1.sinaimg.cn/large/008i3skNly1gy4e9kwec7j309q06ijrr.jpg" alt="Figure_7.12_B17962"/></p><h2>How it works…</h2><p>每种渐变都要color参数，提供渐变的颜色。还有些额外设置，详细的查看下Api文档。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑049-做一个Tic-Tac-Toe小游戏]]></title>
            <link>https://gouxin.fun/2021/12/22/SwiftUI专辑-049-做一个Tic-Tac-Toe小游戏</link>
            <guid>/2021/12/22/SwiftUI专辑-049-做一个Tic-Tac-Toe小游戏</guid>
            <pubDate>Wed, 22 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本章我们将用SwiftUI实现一个Tic-Tac-Toe小游戏。</p><p>如果不知道规则，可以网上搜索一下，简单来讲就是3子棋，3个连成线就获胜。</p><h2>Getting ready</h2><p>首先，我们新建一个项目：<strong>TicTacToe</strong></p><h2>How to do it…</h2><p>TicTacToe由三部分组成：</p><ul><li>棋盘</li><li>圈圈</li><li>叉叉</li></ul><ol><li>构建圈圈</li></ol><pre><code class="language-swift">struct Nought: View {
    var body: some View {
        Circle()
            .stroke(.red, lineWidth: 10)
    }
}
</code></pre><ol start="2"><li>构建叉叉</li></ol><pre><code class="language-swift">struct CrossShape: Shape {
    func path(in rect: CGRect) -&gt; Path {
        Path() { path in
            path.move(to: CGPoint(x: rect.minX, y: rect.minY))
            path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
            path.move(to: CGPoint(x: rect.maxX, y: rect.minY))
            path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        }
    }
}
struct Cross: View {
    var body: some View {
        CrossShape()
            .stroke(.green, style: StrokeStyle(lineWidth: 10, lineCap: .round, lineJoin: .round))
    }
}
</code></pre><ol start="3"><li>定义Cell来抽象每一个格子</li></ol><pre><code class="language-swift">struct Cell: View {
    enum CellType {
        case hidden
        case nought
        case cross
    }
    @State private var type: CellType = .hidden
    @Binding var isNextNought: Bool
    @ViewBuilder private var content: some View {
        switch type {
        case .hidden: Color.clear
        case .nought: Nought()
        case .cross: Cross()
        }
    }
    var body: some View {
        content
            .padding(20)
            .contentShape(Rectangle())
            .onTapGesture {
                guard type == .hidden else {
                    return
                }
                type = isNextNought ? .nought : .cross
                isNextNought.toggle()
            }
    }
}
</code></pre><ol start="4"><li>实现棋盘</li></ol><pre><code class="language-swift">struct GridShape: Shape {
    func path(in rect: CGRect) -&gt; Path {
        Path() { path in
            path.move(to: CGPoint(x: rect.width/3, y: rect.minY))
            path.addLine(to: CGPoint(x: rect.width/3, y: rect.maxY))
            path.move(to: CGPoint(x: 2*rect.width/3, y: rect.minY))
            path.addLine(to: CGPoint(x: 2*rect.width/3, y: rect.maxY))
            path.move(to: CGPoint(x: rect.minX, y: rect.height/3))
            path.addLine(to: CGPoint(x: rect.maxX, y: rect.height/3))
            path.move(to: CGPoint(x: rect.minX, y: 2*rect.height/3))
            path.addLine(to: CGPoint(x: rect.maxX, y: 2*rect.height/3))
        }
    }
}

struct Row: View {
    @Binding var isNextNought: Bool
    var body: some View {
        HStack {
            Cell(isNextNought: $isNextNought)
            Cell(isNextNought: $isNextNought)
            Cell(isNextNought: $isNextNought)
        }
    }
}
struct Grid: View {
    @State var isNextNought: Bool = false
    var body: some View {
        ZStack {
            GridShape().stroke(.blue, lineWidth: 15)
            VStack {
                Row(isNextNought: $isNextNought)
                Row(isNextNought: $isNextNought)
                Row(isNextNought: $isNextNought)
            }
        }.aspectRatio(contentMode: .fit)
    }
}
</code></pre><ol start="5"><li>在ContentView中使用</li></ol><pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        Grid().padding(.horizontal, 20)
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy4do2ix1sj30ce0p4my8.jpg" alt="image-20220106233906878"/></p><h2>How it works…</h2><p><strong>isNextNought</strong>变量定义 下一个将放置哪种类型的标记。它在<strong>Grid</strong>组件中设置为<strong>false</strong>，这意味着第一个标记将始终是<strong>Cross</strong>。当点击一个单元格时，<strong>isNextNought</strong>变量将被切换。</p><p>有趣的是，在为<strong>onTapGesture</strong>手势应用视图修饰符之前，我们必须设置一个<strong>contentShape()</strong>修饰符。之所以会这样，是因为默认的可点击区域是由组件的可见部分给出的，但是一开始，所有的单元格都是隐藏的，所以该区域是空的！</p><p>然后<strong>contentShape()</strong>修饰符定义可以检测到触摸的命中测试区域。在这种情况下，我们希望它占据整个区域，因此使用<strong>Rectangle</strong>，但我们可以使用<strong>Circle</strong>、<strong>Capsule</strong>，甚至自定义形状。</p><p>不过这个游戏还没有完全完成，还缺少判断赢的逻辑，感兴趣的可以自己补全。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑048-实现一个环形进度条]]></title>
            <link>https://gouxin.fun/2021/12/21/SwiftUI专辑-048-实现一个环形进度条</link>
            <guid>/2021/12/21/SwiftUI专辑-048-实现一个环形进度条</guid>
            <pubDate>Tue, 21 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本文我们将实现一个类似于Apple Watch上的环形进度条，并用Slider控制进度。</p><h2>Getting ready</h2><p>首先，创建一个新的SwiftUI项目：<strong>ProgressRings</strong></p><h2>How to do it…</h2><ol><li>首先，我们顶一个一个环形的shape: ProgressRing</li></ol><pre><code class="language-swift">struct ProgressRing: Shape {
    private let startAngle = Angle.radians(1.5 * .pi)
    @Binding var progress: Double
    func path(in rect: CGRect) -&gt; Path {
        Path() { path in
            path.addArc(center: CGPoint(x: rect.midX, y: rect.midY), radius: rect.width/2.0, startAngle: startAngle, endAngle: startAngle + Angle(radians: 2 * .pi * progress), clockwise: false)            
        }
    }
}
</code></pre><ol start="2"><li>创建一个ProgressRingsView，用来显示多个同心圆</li></ol><pre><code class="language-swift">struct ProgressRingsView: View {
    private let ringPadding = 5.0
    private let ringWidth = 40.0
    private var ringStrokeStyle: StrokeStyle {
        StrokeStyle(lineWidth: ringWidth, lineCap: .round, lineJoin: .round)
    }
    @Binding var progressExternal: Double
    @Binding var progressCentral: Double
    @Binding var progressInternal: Double
    var body: some View {
        ZStack {
            ProgressRing(progress: $progressInternal)
                .stroke(.blue, style: ringStrokeStyle)
                .padding(2*(ringWidth + ringPadding))
            ProgressRing(progress: $progressCentral)
                .stroke(.red, style: ringStrokeStyle)
                .padding(ringWidth + ringPadding)

            ProgressRing(progress: $progressExternal)
                .stroke(.green, style: ringStrokeStyle)
                .padding(ringWidth)
        }
    }
}
</code></pre><ol start="3"><li>在ContentView中创建最终的View，加上可调节进度的Slider</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State private var progressExternal = 0.3
    @State private var progressCentral = 0.7
    @State private var progressInternal = 0.5

    var body: some View {
        ZStack {
            ProgressRingsView(progressExternal: $progressExternal, progressCentral: $progressCentral, progressInternal: $progressInternal)
                .aspectRatio(contentMode: .fit)

            VStack(spacing: 10) {
                Spacer()
                Slider(value: $progressInternal, in: 0 ... 1, step: 0.01)
                Slider(value: $progressCentral, in: 0 ... 1, step: 0.01)
                Slider(value: $progressExternal, in: 0 ... 1, step: 0.01)
            }.padding(30)
        }
    }
}
</code></pre><p>最终：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy4cye6ryzj30by0p474t.jpg" alt="image-20220106231426582"/></p><h2>How it works…</h2><p><strong>ProgressRing</strong>只是简单的Path+arc，他暴露了progress供外部设置进度。</p><p>之后，我们ProgressRingsView中添加了3个同心圆。分别暴露@Binding供外部设置</p><p>最终我们在ContentView中加上了Slider，并调节进度。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑047-使用Canvas Api绘制]]></title>
            <link>https://gouxin.fun/2021/12/20/SwiftUI专辑-047-使用CanvasApi绘制</link>
            <guid>/2021/12/20/SwiftUI专辑-047-使用CanvasApi绘制</guid>
            <pubDate>Mon, 20 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
UIkit我们可以通过继承UIView，然后在drawRect中使用Core Graphic Api进行绘制。</p><p>SwiftUI通过<strong>Canvas</strong>实现这个功能，我们可以在Canvas中使用Core Graphic 进行绘制。</p><p>我们来实现一个绘图App。</p><h2>Getting ready</h2><p>首先，我们创建一个SwiftUI工程：<strong>Drawing</strong></p><h2>How to do it…</h2><ol><li>首先我们创建个Line数据结构, 并在ContentView中增加一个State</li></ol><pre><code class="language-swift">struct Line {
    var points: [CGPoint]
}
struct ContentView: View {
    @State var lines: [Line] = []
    var body: some View {
        
    }
}
</code></pre><ol start="2"><li>在body中，我们加入Canvas，能够将lines绘制出来</li></ol><pre><code class="language-swift">var body: some View {
  Canvas { ctx, size in
      for line in self.lines {
          var path = Path()
          path.addLines(line.points)
          ctx.stroke(path, with: .color(.red),style: .init(lineWidth: 5, lineCap: .round, lineJoin: .round))
      }
  }
}
</code></pre><ol start="3"><li>我们添加个手势，能够根据手势，更新lines</li></ol><pre><code class="language-swift">var body: some View {
        Canvas { ctx, size in
            for line in self.lines {
                var path = Path()
                path.addLines(line.points)
                ctx.stroke(path, with: .color(.red),style: .init(lineWidth: 5, lineCap: .round, lineJoin: .round))
            }
        }.gesture(DragGesture(minimumDistance: 0, coordinateSpace: .local).onChanged({ value in
            let position = value.location
            if value.translation == .zero {
                lines.append(Line(points: [position]))
            } else{
                guard let lastIdx = lines.indices.last else {
                    return
                }
                lines[lastIdx].points.append(position)
            }
        }))
    }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy4c3ggzlyj309q0l1aap.jpg" alt="aaaa"/></p><h2>How it works…</h2><p>整个app主要分为2部分：</p><ul><li>通过<strong>points</strong>数组进行绘制：Canvas提供了一个Context，我们能够在里面用CoreGraphic APi进行绘制，我们创建了一个Path，然后将Points传给path , 最后再stroken。</li><li>为每次手指的点移动都创建一个points数组保存。我们用了<strong>DrawGesture</strong>，并用onChange监听移动。如果<strong>translation</strong>为.zero，说明手指按下，因此我们需要添加一条新的Line到数组中。如果translation大于zero，说明手指在移动，此时我们需要更新line里面的points。</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑046-自定义shape中绘制曲线]]></title>
            <link>https://gouxin.fun/2021/12/19/SwiftUI专辑-046-自定义shape中绘制曲线</link>
            <guid>/2021/12/19/SwiftUI专辑-046-自定义shape中绘制曲线</guid>
            <pubDate>Sun, 19 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
上一篇文章中，我们介绍了如何绘制自定义shape，但只使用了直线。</p><p>本文将介绍如何绘制曲线。</p><p>我们来绘制一个心形。</p><h2>Getting ready</h2><p>首先创建一个SwiftUI项目：<strong>Heart</strong></p><h2>How to do it…</h2><ol><li>首先，我们创建一个extension，来快速获取矩形的1/4的位置。</li></ol><pre><code class="language-swift">extension CGRect {
    var quarterX: CGFloat {
        minX + size.height/4
    }

    var quarterY: CGFloat {
        minY + size.height/4
    }

    var threeQuartersX: CGFloat {
        minX + 3*size.height/4
    }

    var threeQuartersY: CGFloat {
        minY + 3*size.height/4
    }
}
</code></pre><ol start="2"><li>创建心形</li></ol><pre><code class="language-swift">struct Heart: Shape {
    func path(in rect: CGRect) -&gt; Path {
        Path() { path in
            path.move(to: CGPoint(x: rect.midX, y: rect.maxY))
            path.addCurve(to: CGPoint(x: rect.minX, y: rect.quarterY),
                          control1: CGPoint(x: rect.midX, y: rect.threeQuartersY),
                          control2: CGPoint(x: rect.minX, y: rect.midY))
            path.addArc(center: CGPoint(x: rect.quarterX, y: rect.quarterY),
                        radius: rect.size.width/4,
                        startAngle: .radians(.pi),
                        endAngle: .radians(0),
                        clockwise: false)
            path.addArc(center: CGPoint(x: rect.threeQuartersX, y: rect.quarterY),
                        radius: rect.size.width/4,
                        startAngle: .radians(.pi),
                        endAngle: .radians(0),
                        clockwise: false)
            path.addCurve(to: CGPoint(x: rect.midX, y: rect.maxY),
                          control1: CGPoint(x: rect.maxX, y: rect.midY),
                          control2: CGPoint(x: rect.midX, y: rect.threeQuartersY))
        }
    }
}
</code></pre><ol start="3"><li>显示</li></ol><pre><code class="language-swift">var body: some View {
    Heart()
        .fill(.red)
        .overlay(Heart().stroke(.orange, lineWidth: 10))
        .aspectRatio(contentMode: .fit)
        .padding(.horizontal, 20)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy46ccdjz7j308k0dewel.jpg" alt="image-20220106192538867"/></p><h2>How it works…</h2><p>我们首先定位到底部中央，然后沿着顺时针绘制。</p><p>我们可以看到<strong>arc()</strong> 函数有个 <strong>clockwise</strong> 参数。但是我们的clockwise设置为false，方向却是顺时针，有点奇怪，这是为什么呢？</p><p>这是因为SwiftUI和UIView一样，也是使用一个flipped coordinate system。所以SwiftUI中的顺时针，对用户来说就是逆时针。所以我们设置为false。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy46j7n3iyj30dw07zmxa.jpg" alt="Figure_7.8_B17962"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑045-绘制自定义shape]]></title>
            <link>https://gouxin.fun/2021/12/18/SwiftUI专辑-045-绘制自定义shape</link>
            <guid>/2021/12/18/SwiftUI专辑-045-绘制自定义shape</guid>
            <pubDate>Sat, 18 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
自定义shape也只是使用Path组件定义好形状，然后包裹成一个Shape就行了。</p><p>本章，我们将自定义一个菱形。</p><h2>Getting ready</h2><p>首先，创建一个SwiftUI工程：<strong>RhombusApp</strong></p><h2>How to do it…</h2><ol><li>创建菱形</li></ol><pre><code class="language-swift">struct Rhombus: Shape {
    func path(in rect: CGRect) -&gt; Path {
        Path() { path in
            path.move(to: CGPoint(x: rect.midX, y: rect.minY))
            path.addLine(to: CGPoint(x: rect.minX, y: rect.midY))
            path.addLine(to: CGPoint(x: rect.midX, y: rect.maxY))
            path.addLine(to: CGPoint(x: rect.maxX, y: rect.midY))
            path.closeSubpath()
        }
    }
}
</code></pre><ol start="2"><li>显示出来</li></ol><pre><code class="language-swift">var body: some View {
    Rhombus()
        .fill(.orange)
        .aspectRatio(0.7, contentMode: .fit)
        .padding(.horizontal, 10)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy45wby22pj30760dkt8q.jpg" alt="image-20220106191015673"/></p><h2>How it works…</h2><p>要创建自定义shape，你需要实现Shape协议</p><p>Shape协议需要实现<code>func path(in rect: CGRect) -&gt; Path </code>。</p><p>我们创建一个Path，在path的闭包中绘制图形。</p><p>注意绘制的坐标系的原点在左上角：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy45zj4zvoj306y0e00sz.jpg" alt="Figure_7.6_B17962"/></p><h2>Shape的Api</h2><h3>Defining a Shape’s Path</h3><pre><code class="language-swift">//上面演示过了，定义shape的path
func path(in rect: CGRect) -&gt; Path
//根据按百分比，截断path
func trim(from startFraction: CGFloat = 0, to endFraction: CGFloat = 1) -&gt; some Shape
</code></pre><p>我们来看看trim的demo</p><pre><code class="language-swift">var body: some View {
  //只要path的0-25%,所以得到的圆弧是1/4，在闭合path
    Circle().trim(from: 0, to: 0.25)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy6c735qsoj30d40b8a9z.jpg" alt="image-20220108161917454"/></p><h3>Transforming a Shape</h3><pre><code class="language-swift">func transform(_ transform: CGAffineTransform) -&gt; TransformedShape&lt;Self&gt;
func size(_ size: CGSize) -&gt; some Shape
func scale(_ scale: CGFloat, anchor: UnitPoint = .center) -&gt; ScaledShape&lt;Self&gt;
func rotation(_ angle: Angle, anchor: UnitPoint = .center) -&gt; RotatedShape&lt;Self&gt;
func offset(_ offset: CGSize) -&gt; OffsetShape&lt;Self&gt;
</code></pre><h3>Setting the Stroke Characteristics</h3><pre><code class="language-swift">func stroke&lt;S&gt;(_ content: S, lineWidth: CGFloat = 1) -&gt; some View where S : ShapeStyle
//StrokeStyle定义了linewidth，连接头的样式，虚线等
func stroke&lt;S&gt;(_ content: S, style: StrokeStyle) -&gt; some View where S : ShapeStyle
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑044-使用SwiftUI内置的Shape]]></title>
            <link>https://gouxin.fun/2021/12/17/SwiftUI专辑-044-使用SwiftUI内置的Shape</link>
            <guid>/2021/12/17/SwiftUI专辑-044-使用SwiftUI内置的Shape</guid>
            <pubDate>Fri, 17 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI有5个内置的shape:</p><ul><li>Rectangle</li><li>RoundedRectangle</li><li>Capsule</li><li>Circle</li><li>Ellipse</li></ul><p>我们也可以结合他们，创建更复杂的shape。</p><h2>Getting ready</h2><p>首先 ，我们新建一个SwiftUI工程<strong>BuiltInShapes</strong></p><h2>How to do it…</h2><ol><li>首先创建一个Vstack来显示我们的所有shape</li></ol><pre><code class="language-swift">var body: some View {
    VStack(spacing: 10){

    }.padding(.horizontal, 20)
}
</code></pre><ol start="2"><li>添加shape</li></ol><pre><code class="language-swift">var body: some View {
  VStack(spacing: 10){
      Rectangle().stroke(.orange, lineWidth: 15)
      RoundedRectangle(cornerRadius: 20).fill(.red)
      Capsule(style: .continuous).fill(.green).frame(height: 100)
      Capsule(style: .circular).fill(.green).frame(height: 100)
      Circle().stroke(.blue, lineWidth: 15)
      Ellipse().fill(.purple)
  }.padding(.horizontal, 20)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy451m4i7aj30bm0om0te.jpg" alt="image-20220106184041907"/></p><h2>How it works…</h2><p>代码比较简单，我们解释下capsule</p><p>capsule有两种圆角</p><ul><li>Continuous： 圆角是平滑过渡到横线的</li><li>Circular：不是平滑过渡，就是半圆</li></ul><p>然后再注意下stroke和stokeBorder的区别</p><p>Stroke: frame是stroke的中线</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy45delyw6j30wq0ecmxr.jpg" alt="image-20220106185204381"/></p><p>strokeBorder：在frame内部创建一个stroke，stroke的外边沿是frame。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy45flagd8j307q032a9v.jpg" alt="image-20220106185410521"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑043-显示popovers]]></title>
            <link>https://gouxin.fun/2021/12/16/SwiftUI专辑-043-显示popovers</link>
            <guid>/2021/12/16/SwiftUI专辑-043-显示popovers</guid>
            <pubDate>Thu, 16 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
弹出框是一种可以显示在屏幕上以提供有关特定项目的更多信息的视图。它们包括一个箭头，指向它们起源的位置。你可以点击任何其他屏幕区域以关闭弹出窗口。弹出框通常用于较大的屏幕，例如 iPad。</p><p>本文，我们将在 iPad 上创建并显示一个弹出框。</p><h2>Getting ready</h2><p>首先创建一个SwiftUI项目：<strong>DisplayingPopovers</strong></p><h2>How to do it</h2><ol><li>首先定义一个State控制是否显示popover</li></ol><pre><code class="language-swift">@State private var showPopover = false
</code></pre><ol start="2"><li>创建一个按钮，点击时显示Popover</li></ol><pre><code class="language-swift">var body: some View {
    Button(&quot;show popover&quot;) {
        self.showPopover = true
    }.popover(isPresented: $showPopover, arrowEdge: .bottom) {
        Text(&quot;Popover content displayed here&quot;)
            .font(.system(size: 40))
    }
}
</code></pre><ol start="3"><li>预览切换成iPad，或者直接在iPad模拟器上运行</li></ol><pre><code class="language-swift">static var previews: some View {
      ContentView()
          .previewDevice(&quot;iPad Pro (9.7-inch)&quot;)
  }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy38h48t3fj30b40fijrh.jpg" alt="008i3skNly1gy38aznqryj30o40xmdgp"/></p><h2>How it works</h2><p><strong>.popover()</strong>有4个参数：<strong>isPresented</strong>, <strong>attachmentAnchor</strong>, <strong>arrowEdge</strong>, 和 <strong>content</strong>.</p><p><strong>isPresented</strong>控制是否显示。</p><p><strong>attachmentAnchor</strong>设置弹窗锚点。</p><p><strong>arrowEdge</strong>控制弹窗的小箭头方向。</p><p><strong>content</strong>控制弹窗内容。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑042-显示context menus]]></title>
            <link>https://gouxin.fun/2021/12/15/SwiftUI专辑-042-显示contextmenus</link>
            <guid>/2021/12/15/SwiftUI专辑-042-显示contextmenus</guid>
            <pubDate>Wed, 15 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
context menus是一个弹出菜单，用于显示开发人员预期用户可能会执行的操作。context menus在 iOS 上是通过 3D Touch 触发和 macOS 上的右键单击触发。</p><p>context menus由一组在隐式<strong>HStack 中</strong>水平显示的按钮<strong>组成</strong>。</p><h2>Getting ready</h2><p>首先，创建一个新的SwiftUI项目：<strong>DisplayingContextMenus</strong></p><h2>How to do it</h2><ol><li>首先定义一个State</li></ol><pre><code class="language-swift">@State private var bulbColor = Color.red
</code></pre><ol start="2"><li>定义个Image</li></ol><pre><code class="language-swift">Image(systemName: &quot;lightbulb.fill&quot;)
      .font(.system(size: 60))
      .foregroundColor(self.bulbColor)
</code></pre><ol start="3"><li>添加contextMemu</li></ol><pre><code class="language-swift">var body: some View {
    Image(systemName: &quot;lightbulb.fill&quot;)
        .font(.system(size: 60))
        .foregroundColor(self.bulbColor)
        .contextMenu {
            Button(&quot;Yellow Bulb&quot;){
                self.bulbColor = Color.yellow
            }
            Button(&quot;Blue Bulb&quot;){
                self.bulbColor = Color.blue
            }
            Button(&quot;Green Bulb&quot;){
                self.bulbColor = Color.green
            }
        }
}
</code></pre><p>最终结果，长按图片:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy37vfiqnvj30d00qugm6.jpg" alt="image-20220105233301390"/></p><h2>How it works</h2><p><strong>.contextMenu()</strong> 修饰符可以添加到任何View上。</p><p>当我们长按View时，会弹出ContextMenu。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑041-显示sheets]]></title>
            <link>https://gouxin.fun/2021/12/14/SwiftUI专辑-041-显示sheets</link>
            <guid>/2021/12/14/SwiftUI专辑-041-显示sheets</guid>
            <pubDate>Tue, 14 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI使用sheets来present新的View(类似于UIKit的present功能)，允许你往下拖动，让弹出的View消失。</p><p>本章将演示如何present一个NavigationView。</p><h2>Getting ready</h2><p>首先，新建一个SwiftUI项目：<strong>PresentingSheets</strong>。</p><h2>How to do it</h2><ol><li>首先创建2个两个State</li></ol><pre><code class="language-swift">@State private var showSheet = false
@State private var sheetWithNav = false
</code></pre><ol start="2"><li>创建一个按钮，点击后显示sheet</li></ol><pre><code class="language-swift">var body: some View {
    VStack {
        Button(&quot;Display Sheet&quot;) {
            self.showSheet = true
        }.sheet(isPresented: $showSheet) {

        } content: {
            SheetView()
        }
    }
}
</code></pre><ol start="3"><li>实现SheetView</li></ol><pre><code class="language-swift">struct SheetView: View {
    var body: some View {
        Text(&quot;This is the sheet we want to display View&quot;)
    }
}
</code></pre><p>运行</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy2zzs3nuuj30iq11wgm6.jpg" alt="image-20220105190022691"/></p><ol start="4"><li>再创建一个按钮，点了显示带导航的sheet</li></ol><pre><code class="language-swift"> Button(&quot;SheetWithNavigationBar&quot;) {
      self.sheetWithNav = true
  }.sheet(isPresented: $sheetWithNav) {

  } content: {
      SheetWithNavView(sheetWithNav: $sheetWithNav)
  }
</code></pre><ol start="5"><li>实现我们的SheetWithNavView</li></ol><pre><code class="language-swift">struct SheetWithNavView: View {
  //注意是@Binding
    @Binding var sheetWithNav: Bool
    var body: some View {
        NavigationView {
            Text(&quot;Sheet with navigation&quot;)
                .navigationTitle(&quot;NaviagtionTitle&quot;)
                .navigationBarTitleDisplayMode(.inline)
                .navigationBarItems(trailing: Button(&quot;Done&quot;, action: {
                    self.sheetWithNav = false
                }))
        }
    }
}

struct SheetWithNavView_Previews: PreviewProvider {
    static var previews: some View {
      //我们可以直接设置@Binding的值：.constant(true)
        SheetWithNavView(sheetWithNav: .constant(true))
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy37cq8qwej30ji130755.jpg" alt="image-20220105231502701"/></p><p>ok，现在我们点击Done，界面就会消失</p><h2>How it works</h2><p>首先sheet绑定了是否展示isPresented，一个可选的onDismiss，一个要显示的View。</p><p>之后我们也演示了，如何通过传递绑定的isPresented，让弹出的View能够通过代码dismiss。</p><p>传递的时候，我们使用@Binding接受。</p><p>在preview时，对于@Binding的数据，我们可以通过.constant()来模拟，便于我们预览。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑040-显示confirmationDialog]]></title>
            <link>https://gouxin.fun/2021/12/13/SwiftUI专辑-040-显示confirmationDialog</link>
            <guid>/2021/12/13/SwiftUI专辑-040-显示confirmationDialog</guid>
            <pubDate>Mon, 13 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
Confirmation dialogs 是 iOS 15 开始出现的。</p><p>他和Actionsheet类似，不过Actionsheet已经被废弃了。</p><h2>Getting ready</h2><p>首先新建一个SwiftUI项目：<strong>PresentingConfirmationDialogs</strong></p><h2>How to do it</h2><ol><li>定义个State控制是否显示confirmationDialog</li></ol><pre><code class="language-swift">@State private var showDialog = false
var title  = &quot;Confirmation Dialog&quot;
</code></pre><ol start="2"><li>添加个按钮，点击后，显示confirmationDialog</li></ol><pre><code class="language-swift">var body: some View {
    Button(&quot;Present Confirmation Dialog&quot;) {
        showDialog = true
    }.confirmationDialog(title, isPresented: $showDialog) {
        Button(&quot;Dismiss Dialog&quot;, role: .destructive) {

        }
        Button(&quot;Save&quot;) {

        }
        Button(&quot;Cancel&quot;, role: .cancel) {

        }
        Button(&quot;Print something to console&quot;) {
            print(&quot;something&quot;)
        }
    } message: {
        Text(&quot;&quot;&quot;
             Use Dialogs to give users alternatives for
             completing a task
            &quot;&quot;&quot;)
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy2v9afnolj309q0lit94.jpg" alt="20220105161606"/></p><h2>How it works</h2><p>.confirmationDialog修饰符用于显示一个confirmationDialog。title用于显示title，第二个参数binding控制是否显示，actions控制action btn, message控制message的显示</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑039-添加action Button到alert中]]></title>
            <link>https://gouxin.fun/2021/12/12/SwiftUI专辑-039-添加actionButton到alert中</link>
            <guid>/2021/12/12/SwiftUI专辑-039-添加actionButton到alert中</guid>
            <pubDate>Sun, 12 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
上个例子显示了Alert的基本用法。我们只显示了一个Ok。如果我们想要多个Btn呢？</p><p>本文将介绍如何添加action button到alert中。</p><h2>Getting ready</h2><p>新建一个SwiftUI项目：<strong>AlertsWithActions</strong></p><h2>How to do it</h2><ol><li>添加2个State</li></ol><pre><code class="language-swift">@State private var changeText = false
@State private var displayedText = &quot;Tap to Change Text&quot;
</code></pre><ol start="2"><li>添加一个按钮</li></ol><pre><code class="language-swift">Button(displayedText){
    changeText = true
}
</code></pre><ol start="3"><li>添加alert</li></ol><pre><code class="language-swift">var body: some View {
    Button(displayedText) {
        changeText = true
    }.alert(&quot;Changing Text&quot;, isPresented: $changeText) {
        Button(&quot;Yea&quot;){
                displayedText = (displayedText == &quot;Stay Foolish&quot;) ? &quot;Stay Hungry&quot; : &quot;Stay Foolish&quot;
        }
        Button(&quot;Do nothing&quot;){}
    } message: {
        Text(&quot;Do you want to toggle the text?&quot;)
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy2tnyjnc0j30hi0vugm0.jpg" alt="image-20220105152126983"/></p><h2>How it works</h2><p>alert的actions闭包，可以在里面提供多个按钮，然后单独为每个按钮设置action。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑038-显示alerts]]></title>
            <link>https://gouxin.fun/2021/12/11/SwiftUI专辑-038-显示alerts</link>
            <guid>/2021/12/11/SwiftUI专辑-038-显示alerts</guid>
            <pubDate>Sat, 11 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
一种显示重要信息的常用View是：Alert。</p><p>iOS 13 和 14 显示Alert的方式被废弃了。iOS 15介绍了全新的显示alerts的方式。</p><p>我们两种都看一看。先看iOS15的，再看老版本的。</p><h2>Getting ready</h2><p>首先，新建个SwiftUI项目：<strong>PresentingAlerts</strong></p><h2>How to do it</h2><ol><li>创建一个State, 控制alert的显示和隐藏</li></ol><pre><code class="language-swift">@State private var showSubmitAlert = false
</code></pre><ol start="2"><li>添加一个Button，点击后，弹出alert</li></ol><pre><code class="language-swift">var body: some View {
    Button(&quot;show alert&quot;) {
        self.showSubmitAlert = true
    }.alert(&quot;Confirm Actions&quot;, isPresented: $showSubmitAlert) {
        Button(&quot;Ok&quot;, role: .cancel) {
            print(&quot;clicked ok&quot;)
        }
    } message: {
        Text(&quot;Are you sure you want to submit the form&quot;)
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy2slzd7mlj309q0k7t8u.jpg" alt="20220105144429"/></p><ol start="3"><li>再看看老的Alert是怎么用的</li></ol><pre><code class="language-swift">Button(&quot;show old alert&quot;) {
      self.showSubmitAlert = true
  }.alert(isPresented: $showSubmitAlert) {
      Alert(title: Text(&quot;Old Confirm Actions&quot;),
            message: Text(&quot;Are you sure you want to submit the old form&quot;),
            dismissButton: .default(Text(&quot;ok&quot;)))
  }
</code></pre><h2>How it works</h2><h3>iOS 15</h3><p>你通过<strong>.alert</strong> 修饰符，绑定到是否展示，然后提供title，message， actions。</p><h3>iOS 13 and 14</h3><p>你通过<strong>.alert</strong> 修饰符，绑定到是否展示，然后返回一个Alert。</p><p>在这个Alert中设置title， message 和actions</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑037-代码切换TabView的Tab]]></title>
            <link>https://gouxin.fun/2021/12/10/SwiftUI专辑-037-代码切换TabView的Tab</link>
            <guid>/2021/12/10/SwiftUI专辑-037-代码切换TabView的Tab</guid>
            <pubDate>Fri, 10 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
在上一篇文章中，我们介绍了如何点击底部tab，跳转不同界面。然而，我们有时候也想通过代码触发跳转。</p><p>本章，我们将使用一个tap gesture来从一个tab跳转到另一个tab。</p><h2>Getting ready</h2><p>首先创建一个新的SwiftUI项目：<strong>TabViewWithGestures</strong></p><h2>How to do it…</h2><ol><li>添加一个State记录当前选中的tab</li></ol><pre><code class="language-swift">@State private var tabSelected = 0
</code></pre><ol start="2"><li>添加UI</li></ol><pre><code class="language-swift">var body: some View {
        TabView(selection: $tabSelected) {
            Text(&quot;Left Tab. Click to switch to right&quot;)
                .onTapGesture {
                    self.tabSelected = 1
                }.tabItem {
                    Label(&quot;Left&quot;, systemImage: &quot;l.circle.fill&quot;)
                }.tag(0)
            Text(&quot;Right Tab. Click to switch to left&quot;)
                .onTapGesture {
                    self.tabSelected = 0
                }.tabItem {
                    Label(&quot;Right&quot;, systemImage: &quot;l.circle.fill&quot;)
                }.tag(1)
        }
    }

</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy24c173y7j30j012u3z9.jpg" alt="image-20220105004501937"/></p><h2>How it works…</h2><p>要想代码切换tab，我们首先得创建一个存储当前选中tab的State。然后作为TabView的selection参数。</p><p>我们添加.tag()修饰符来指定每个tab。要切换是，为State赋值为对应的tag即可。本例中，我们在onTapGesture中修改了state为第二个tab的tag，因此会自动切换到第二个tab。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑036-使用TabView]]></title>
            <link>https://gouxin.fun/2021/12/09/SwiftUI专辑-036-使用TabView</link>
            <guid>/2021/12/09/SwiftUI专辑-036-使用TabView</guid>
            <pubDate>Thu, 09 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
NavigationView比较适合有层次的数据，但不太适合不想关的数据。TabView就是用来组织这种数据的。</p><h2>Getting ready</h2><p>新建一个SwiftUI项目：<strong>UsingTabViews</strong></p><h2>How to do it…</h2><ol><li>新建一个<strong>HomeView</strong></li></ol><pre><code class="language-swift">let games = [&quot;Doom&quot;, &quot;Final F&quot;,&quot;Cyberpunk&quot;, &quot;avengers&quot;, &quot;animal trivia&quot;, &quot;sudoku&quot;, &quot;snakes and ladders&quot;, &quot;Power rangers&quot;, &quot;ultimate frisbee&quot;,&quot;football&quot;, &quot;soccer&quot;, &quot;much more&quot;]

struct HomeView: View {
    var body: some View {
        NavigationView {
            List {
                ForEach(games, id: \.self) { game in
                    Text(game).padding()
                }
            }.navigationBarTitle(&quot;Best Games for 2021&quot;, displayMode: .inline)
        }
    }
}
</code></pre><ol start="2"><li>新建一个<strong>CurrenciesView</strong></li></ol><pre><code class="language-swift">struct Currency: Identifiable {
    let id = UUID()
    var name: String
    var image: String
}

var currencies = [
    Currency(name: &quot;Dollar&quot;, image: &quot;dollarsign.circle.fill&quot;),
    Currency(name: &quot;Sterling&quot;, image: &quot;sterlingsign.circle.fill&quot;),
    Currency(name: &quot;Euro&quot;, image: &quot;eurosign.circle.fill&quot;),
    Currency(name: &quot;Yen&quot;, image: &quot;yensign.circle.fill&quot;),
    Currency(name: &quot;Naira&quot;, image: &quot;nairasign.circle.fill&quot;),
]
struct CurrenciesView: View {
    var body: some View {
        NavigationView {
            VStack {
                ForEach(currencies) { currency in
                    HStack {
                        Group {
                            Text(currency.name)
                            Spacer()
                            Image(systemName: currency.image)
                        }.font(Font.system(size: 40, design: .default))
                        .padding()
                    }
                }
            }.navigationBarTitle(&quot;Currencies&quot;)
        }
    }
}
</code></pre><ol start="3"><li>打开<strong>ContentView.swift</strong>，使用TabView</li></ol><pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        TabView {
            HomeView().tabItem {
                Label(&quot;Home&quot;, systemImage: &quot;house.fill&quot;)
            }
            CurrenciesView().tabItem {
                Label(&quot;Currencies&quot;, systemImage: &quot;coloncurrencysign.circle.fill&quot;)
            }
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gy23syy5yej30im132dh8.jpg" alt="image-20220105002641933"/></p><h2>How it works…</h2><p>我们使用TabView定义tab的内容。</p><p>使用<strong>.tabItem()</strong> 定义tabbar的内容。</p><p>ios14以后TabView还可以用作<strong>UIPageViewController</strong>。</p><pre><code class="language-swift">TabView {

}.tabViewStyle(.page)
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑035-使用Focus和Submit]]></title>
            <link>https://gouxin.fun/2021/12/08/SwiftUI专辑-035-使用Focus和Submit</link>
            <guid>/2021/12/08/SwiftUI专辑-035-使用Focus和Submit</guid>
            <pubDate>Wed, 08 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
如果用户必须手动单击每个字段，填写它，然后单击填写下一个，这可能会很乏味。一个更容易和更快的方法是使用键盘上的按钮从一个表单字段跳转到下一个。</p><p>本章，我们将创建一个地址表单，在各个字段之间轻松跳转。</p><h2>Getting ready</h2><p>创建一个新的SwiftUI项目：<strong>FocusAndSubmit</strong></p><h2>How to do it…</h2><ol><li>在ContentView中定义一个输入框类型枚举</li></ol><pre><code class="language-swift">struct ContentView: View {
    enum AddressField{
        case streetName
        case city
        case state
        case zipCode
    }
    var body: some View {
        Text(&quot;hello world&quot;)
    }
}
</code></pre><ol start="2"><li>添加一些State，准备和TextField绑定</li></ol><pre><code class="language-swift">@State private var streetName = &quot;&quot;
@State private var city = &quot;&quot;
@State private var state = &quot;&quot;
@State private var zipCode = &quot;&quot;
</code></pre><ol start="3"><li>添加一个<strong>@FocusState</strong>，控制那个输入框正在输入</li></ol><pre><code class="language-swift">@FocusState private var currentFocus: AddressField?
</code></pre><ol start="4"><li>构建UI</li></ol><pre><code class="language-swift">var body: some View {
    VStack {
        TextField(&quot;Address&quot;, text: $streetName)
            .focused($currentFocus, equals:.streetName)
            .submitLabel(.next)
        TextField(&quot;City&quot;, text: $city)
            .focused($currentFocus, equals: .city)
            .submitLabel(.next)
        TextField(&quot;State&quot;, text: $state)
            .focused($currentFocus, equals:.state)
            .submitLabel(.next)
        TextField(&quot;Zip code&quot;, text: $zipCode)
            .focused($currentFocus, equals:.zipCode)
            .submitLabel(.done)
    }
}
</code></pre><ol start="5"><li>添加<strong>.onSubmit</strong>到VStack, 在里面修改currentFocus，控制哪个输入框Foucus。</li></ol><pre><code class="language-swift">.onSubmit {
   switch currentFocus {
    case .streetName: currentFocus = .city
    case .city: currentFocus = .state
    case .state:currentFocus = .zipCode
    default:
        print(&quot;Thanks for providing your address&quot;)
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy237u8018j30j812m75q.jpg" alt="image-20220105000620065"/></p><p>当点击next时，下一个输入框会聚焦</p><h2>How it works…</h2><p><strong>@FocusState</strong>定义了Foucus的状态变化。</p><p>使用<strong>.focused(_ : equals:)</strong>将View和FoucusState绑定。当聚焦状态改变时，会更新FoucusState，更新FoucusState也会改变对应View的聚焦状态。</p><p>我们使用<strong>.submitLabel()</strong>来控制键盘右下角的submit按钮。当点击按钮时，会触发.onSubmit注册的回调。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑034-开启和禁用Form中的某些items]]></title>
            <link>https://gouxin.fun/2021/12/07/SwiftUI专辑-034-开启和禁用Form中的某些items</link>
            <guid>/2021/12/07/SwiftUI专辑-034-开启和禁用Form中的某些items</guid>
            <pubDate>Tue, 07 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
表单中的某些地方可能有额外的要求，例如最小文本长度或组合大写和小写字符。我们可能想要根据 用户的输入，禁用提交按钮，直到满足所有要求。</p><p>本章，我们将创建一个登录视图，只有当用户在用户名和密码字段中输入一些内容时，提交按钮才会启用。</p><h2>Getting ready</h2><p>新建要给SwiftUI项目<strong>FormFieldDisable</strong></p><h2>How to do it…</h2><ol><li>新建一个<strong>LoginView</strong>, 并添加一些状态</li></ol><pre><code class="language-swift">struct LoginView: View {
    @State private var username = &quot;&quot;
    @State private var password = &quot;&quot;
    var body: some View {
        Text(&quot;&quot;)
    }
}
</code></pre><ol start="2"><li>实现UI</li></ol><pre><code class="language-swift">VStack {
    Text(&quot;Dungeons and Wagons&quot;)
        .fontWeight(.heavy)
        .foregroundColor(.blue)
        .font(.largeTitle)
        .padding(.bottom, 30)
    Image(systemName: &quot;person.circle&quot;)
         .font(.system(size: 150))
         .foregroundColor(.gray)
         .padding(.bottom,40)
    Group{
        TextField(&quot;Username&quot;, text: $username)
        SecureField(&quot;Password&quot;, text: $password)
    }.padding().overlay(RoundedRectangle(cornerRadius: 10).stroke(Color.black, lineWidth: 2))
    Button {
        print(&quot;Login clicked&quot;)
    } label: {
        Text(&quot;Login&quot;)
            .padding()
            .background((username.isEmpty || password.isEmpty) ?.gray : Color.blue)
            .foregroundColor(Color.white)
            .clipShape(Capsule())            
    }.disabled(username.isEmpty || password.isEmpty)
  }
</code></pre><ol start="3"><li>添加到ContentView中</li></ol><pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        LoginView()
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxx7qu61rtj30c80p00t9.jpg" alt="image-20211231185513737"/></p><h2>How it works…</h2><p><strong>.disable（）</strong>可以让按钮不响应事件。</p><p>我们还介绍了Group，将样式同时应用于group中的多个view。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑033-在Form中显示隐藏sections]]></title>
            <link>https://gouxin.fun/2021/12/06/SwiftUI专辑-033-在Form中显示隐藏sections</link>
            <guid>/2021/12/06/SwiftUI专辑-033-在Form中显示隐藏sections</guid>
            <pubDate>Mon, 06 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
Form提供了一种从用户那里获取信息的方法。但是表格很长时，用户在完成时会感到气馁，提交表格的人很少 意味着您的调查数据更少，您的应用程序注册更少，或者提供您收集的任何数据的人更少。</p><p>本章，我们将学习如何根据用户的输入显示/隐藏Form的附加地址部分。</p><h2>Getting ready</h2><p>新建一个SwiftUI项目：<strong>SignUp</strong></p><h2>How to do it…</h2><ol><li>新建一个<strong>SignUpView</strong>，并添加state</li></ol><pre><code class="language-swift">struct SignUpView: View {
    @State private var fname = &quot;&quot;
    @State private var lname = &quot;&quot;
    @State private var street = &quot;&quot;
    @State private var city = &quot;&quot;
    @State private var zip = &quot;&quot;
    @State private var lessThanTwo = false
    @State private var username = &quot;&quot;
    @State private var password = &quot;&quot;
    var body: some View {
        Text(/*@START_MENU_TOKEN@*/&quot;Hello, World!&quot;/*@END_MENU_TOKEN@*/)
    }
}
</code></pre><ol start="2"><li>添加一个Form</li></ol><pre><code class="language-swift">var body: some View {
    NavigationView {
        Form {

        }.navigationTitle(&quot;Sign up&quot;)
    }
}
</code></pre><ol start="3"><li>添加一个section到Form里</li></ol><pre><code class="language-swift">Section(header: Text(&quot;Names&quot;)){
    TextField(&quot;First Name&quot;, text: $fname)
    TextField(&quot;Last Name&quot; , text: $lname)
}
</code></pre><ol start="4"><li>再添加一个section</li></ol><pre><code class="language-swift">Section(header: Text(&quot;Current Address&quot;)){
    TextField(&quot;Street Address&quot; , text: $street)
    TextField(&quot;City&quot; , text: $city)
    TextField(&quot;Zip&quot; , text: $zip)
}
</code></pre><ol start="5"><li>在zip后添加一个Toggle, 如果勾选了，才显示第三个section</li></ol><pre><code class="language-swift">Toggle(isOn: $lessThanTwo){
    Text(&quot;Have you lived here for 2+ years&quot;)
}
</code></pre><ol start="6"><li>添加第三个section，根据是否勾选显示和隐藏</li></ol><pre><code class="language-swift">if !lessThanTwo{
    Section(header: Text(&quot;Previous Address&quot;)) {
        TextField(&quot;Street Address&quot; , text: $street)
        TextField(&quot;City&quot; , text: $city)
        TextField(&quot;Zip&quot; , text: $zip)
    }
}
</code></pre><ol start="7"><li>在添加一个section</li></ol><pre><code class="language-swift">Section(header:Text(&quot;Create Account Info&quot;)) {
    TextField(&quot;Create Username&quot; , text: $username)
    SecureField(&quot;Password&quot;, text: $password)
}
</code></pre><ol start="8"><li>最后添加一个提交按钮</li></ol><pre><code class="language-swift">Button(&quot;Submit&quot;) {
    print(&quot;Form submit action here&quot;)
}
</code></pre><p>最终，当我们打开toggle时，不会显示不需要填写的section</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxx755o5a4j30af0l0gm2.jpg" alt="20211231183357"/></p><h2>How it works…</h2><p>我们使用<strong>if</strong>条件语句来显示或隐藏表单中的部分字段。例如，仅当<strong>lessThanTwo</strong>变量的值设置为<strong>true</strong>时，才会显示表单的<strong>Previous Address</strong>部分。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑032-预览mock数据]]></title>
            <link>https://gouxin.fun/2021/12/05/SwiftUI专辑-032-预览Mock数据</link>
            <guid>/2021/12/05/SwiftUI专辑-032-预览Mock数据</guid>
            <pubDate>Sun, 05 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
通常我们获取数据是通过 API 调用。但这可能很耗时，并很快成为瓶颈。更快的选择是仅在构建时提供一些mock数据。</p><p>本章我们将在<strong>Preview Content</strong>文件夹下存储一些json，来模拟Api调用。</p><h2>Getting ready</h2><p>首先新建一个SwiftUI项目<strong>UsingMockDataForPreviews</strong></p><h2>How to do it</h2><ol><li>首先准备一个json文件: insetsData.json</li></ol><pre><code class="language-swift">[
  {
      &quot;id&quot;: 1,
    &quot;imageName&quot;: &quot;honeybee&quot;,
    &quot;name&quot;: &quot;Honey bee&quot;,
    &quot;habitat&quot;: &quot;Tropical climates&quot;,
    &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Id volutpat lacus laoreet non curabitur gravida arcu ac. Felis imperdiet proin fermentum leo vel. Et netus et malesuada fames. Amet nisl suscipit adipiscing bibendum est ultricies integer.&quot;
  },
  {
      &quot;id&quot;: 2,
    &quot;imageName&quot;: &quot;greenbrownfly&quot;,
    &quot;name&quot;: &quot;Green Fly&quot;,
    &quot;habitat&quot;: &quot;warm and moist climates&quot;,
    &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Id volutpat lacus laoreet non curabitur gravida arcu ac. Felis imperdiet proin fermentum leo vel. Et netus et malesuada fames. Amet nisl suscipit adipiscing bibendum est ultricies integer.&quot;
  },
  {
      &quot;id&quot;: 3,
    &quot;imageName&quot;: &quot;greenbug&quot;,
    &quot;name&quot;: &quot;Green bug&quot;,
    &quot;habitat&quot;: &quot;orchards and gardens&quot;,
    &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Id volutpat lacus laoreet non curabitur gravida arcu ac. Felis imperdiet proin fermentum leo vel. Et netus et malesuada fames. Amet nisl suscipit adipiscing bibendum est ultricies integer.&quot;
  },
  {
      &quot;id&quot;: 4,
    &quot;imageName&quot;: &quot;blackbeatle&quot;,
    &quot;name&quot;: &quot;Black Beatle&quot;,
    &quot;habitat&quot;: &quot;Tropical climates&quot;,
    &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Id volutpat lacus laoreet non curabitur gravida arcu ac. Felis imperdiet proin fermentum leo vel. Et netus et malesuada fames. Amet nisl suscipit adipiscing bibendum est ultricies integer.&quot;
  },
  {
      &quot;id&quot;: 5,
    &quot;imageName&quot;: &quot;brownspider&quot;,
    &quot;name&quot;: &quot;Brown Spider&quot;,
    &quot;habitat&quot;: &quot;warm and moist climates&quot;,
    &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Id volutpat lacus laoreet non curabitur gravida arcu ac. Felis imperdiet proin fermentum leo vel. Et netus et malesuada fames. Amet nisl suscipit adipiscing bibendum est ultricies integer.&quot;
  },
  {
      &quot;id&quot;: 6,
    &quot;imageName&quot;: &quot;bluedragonfly&quot;,
    &quot;name&quot;: &quot;Blue Dragonfly&quot;,
    &quot;habitat&quot;: &quot;around lakes and streams&quot;,
    &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, consecte&quot;
  },
  {
      &quot;id&quot;: 7,
    &quot;imageName&quot;: &quot;brownblackbutterfly&quot;,
    &quot;name&quot;: &quot;Brown Black Butterfly&quot;,
    &quot;habitat&quot;: &quot;deciduous forests&quot;,
    &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Id volutpat lacus laoreet non curabitur gravida arcu ac. Felis imperdiet proin fermentum leo vel. Et netus et malesuada fames. Amet nisl suscipit adipiscing bibendum est ultricies integer.&quot;
  },
  {
      &quot;id&quot;: 8,
    &quot;imageName&quot;: &quot;grasshopper&quot;,
    &quot;name&quot;: &quot;Grasshopper&quot;,
    &quot;habitat&quot;: &quot;dry open habitat with lots of grass&quot;,
    &quot;description&quot;: &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Id volutpat lacus laoreet non curabitur gravida arcu ac. Felis imperdiet proin fermentum leo vel. Et netus et malesuada fames. Amet nisl suscipit adipiscing bibendum est ultricies integer.&quot;
  }
]
</code></pre><ol start="2"><li>创建一个model和json对应</li></ol><pre><code class="language-swift">struct Insect : Decodable, Identifiable{
    var id: Int
    var imageName: String
    var name:String
    var habitat:String
    var description:String
}

let testInsect = Insect(id: 1, imageName: &quot;grasshopper&quot;, name: &quot;grass&quot;, habitat: &quot;rocks&quot;, description: &quot;none&quot;)

</code></pre><ol start="3"><li>在<strong>ContentView.swift</strong>中增加UI代码,显示数据</li></ol><pre><code class="language-swift">struct ContentView: View {
    var insects:[Insect] = []
    var body: some View {
        NavigationView {
            List {
                ForEach(insects) { insect in
                    HStack {
                        Image(insect.imageName)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .clipShape(Rectangle())
                            .frame(width: 100, height: 80)
                        VStack(alignment: .leading) {
                            Text(insect.name).font(.title)
                            Text(insect.habitat)
                        }.padding(.vertical)
                    }
                }

            }.navigationBarTitle(&quot;Insects&quot;)
        }
    }
}
</code></pre><ol start="4"><li>在预览中传入mock数据</li></ol><pre><code class="language-swift">struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        ContentView(insects: Self.testInsects)
    }
    
    static var testInsects : [Insect]{
        guard let url = Bundle.main.url(forResource:&quot;insetsData&quot;, withExtension: &quot;json&quot;),
            let data = try? Data(contentsOf: url) else{
                return[]
        }
        let decoder  = JSONDecoder()
        let array = try?decoder.decode([Insect].self, from: data)
        return array ??  [testInsect]
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxx6iafb9cj30dk0qc0tt.jpg" alt="image-20211231181222575"/></p><h2>How it works</h2><p>在preview中，我们读取json文件，然后转成modle数组，得到mock数据。</p><p>然后将Mock数据传给View显示。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑031-预览UIKit]]></title>
            <link>https://gouxin.fun/2021/12/04/SwiftUI专辑-031-预览UIKit</link>
            <guid>/2021/12/04/SwiftUI专辑-031-预览UIKit</guid>
            <pubDate>Sat, 04 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
如果您喜欢轻松预览 UI 更改，但您的项目又只是UIkit，那么请放心 因为你也可以在构建 UIKit 应用程序时使用这个强大的功能。</p><p>本章，我们将学习如何将UIViewController和UIView包装到 SwiftUI 视图中，然后使用实时预览。</p><h2>Getting ready</h2><p>首先创建个普通storyboard工程：UIKitPreview</p><h2>How to do it</h2><ol><li>新建一个swift文件<strong>ViewControllerPreview</strong>, 遵循UIViewControllerRepresentable</li></ol><pre><code class="language-swift">import UIKit
import SwiftUI
struct ViewControllerPreview: UIViewControllerRepresentable {
    let viewControllerBuilder: () -&gt; UIViewController
    init(_ viewControllerBuilder: @escaping () -&gt; UIViewController) {
        self.viewControllerBuilder = viewControllerBuilder
    }

    func makeUIViewController(context: Context) -&gt; some UIViewController {
        return self.viewControllerBuilder()
    }
    func updateUIViewController(_ uiViewController: UIViewControllerType, context: Context) {
        
    }
}
</code></pre><ol start="2"><li>然后创建一个preview, 然后你就可以使用这个预览任何UIViewController了</li></ol><pre><code class="language-swift">struct ViewControllerPreview_Previews: PreviewProvider {
    static var previews: some View {
        ViewControllerPreview {
            MyViewController()
        }
    }
}
</code></pre><ol start="3"><li>写个viewcontroller</li></ol><pre><code class="language-swift">import SnapKit
class MyViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        self.setupView()
    }
    func setupView() {
        self.view.backgroundColor = UIColor.black.withAlphaComponent(0.5)
        self.contaienrView = UIView()
        self.contaienrView.backgroundColor = UIColor.white
        self.contaienrView.layer.cornerRadius = 8
        self.view.addSubview(self.contaienrView)
        self.contaienrView.snp.makeConstraints { make in
            make.center.equalToSuperview()
            make.width.equalTo(290)
            make.height.equalTo(162)
        }
        let textColor = UIColor(red: 0x27 / 255.0, green: 0x27 / 255.0, blue: 0x55 / 255.0, alpha: 1.0)
        self.titleLabel = UILabel()
        self.titleLabel.font = UIFont.systemFont(ofSize: 15)
        self.titleLabel.textColor = textColor
        self.titleLabel.text = &quot;是否清除所有收藏习题记录&quot;
        self.titleLabel.numberOfLines = 2
        self.contaienrView.addSubview(self.titleLabel)
        self.titleLabel.snp.makeConstraints { make in
            make.leading.equalToSuperview().offset(20)
            make.trailing.equalToSuperview().offset(-20)
            make.top.equalToSuperview().offset(20)
            make.height.equalTo(45)
        }
        
        self.descLabel = UILabel()
        self.descLabel.textColor = textColor.withAlphaComponent(0.5)
        self.descLabel.text = &quot;清除后当前科目无错题记录，此操作不可恢复&quot;
        self.descLabel.font = UIFont.systemFont(ofSize: 12)
        self.contaienrView.addSubview(self.descLabel)
        self.descLabel.snp.makeConstraints { make in
            make.leading.equalToSuperview().offset(20)
            make.trailing.equalToSuperview().offset(-20)
            make.top.equalTo(self.titleLabel.snp.bottom).offset(4)
            make.height.equalTo(20)
        }
        let sepColor = UIColor(red: 0xF0/255.0, green: 0xF0/255.0, blue: 0xF0/255.0, alpha: 1.0)
        self.hLine = UIView()
        self.hLine.backgroundColor = sepColor
        self.contaienrView.addSubview(self.hLine)
        self.hLine.snp.makeConstraints { make in
            make.leading.trailing.equalToSuperview()
            make.bottom.equalToSuperview().offset(-49)
            make.height.equalTo(1)
        }
        self.vLine = UIView()
        self.vLine.backgroundColor = sepColor
        self.contaienrView.addSubview(self.vLine)
        self.vLine.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.bottom.equalToSuperview()
            make.width.equalTo(1)
            make.height.equalTo(49)
        }
        
        self.clearBtn = UIButton(type: .custom)
        self.clearBtn.setTitle(&quot;清除&quot;, for: .normal)
        self.clearBtn.setTitleColor(textColor.withAlphaComponent(0.5), for: .normal)
        self.clearBtn.titleLabel?.font = UIFont.systemFont(ofSize: 15)
        self.contaienrView.addSubview(self.clearBtn)
        self.clearBtn.snp.makeConstraints { make in
            make.leading.bottom.equalToSuperview()
            make.trailing.equalTo(self.vLine.snp.leading)
            make.height.equalTo(49)
        }
        self.cancelBtn = UIButton(type: .custom)
        self.cancelBtn.setTitle(&quot;取消&quot;, for: .normal)
        self.cancelBtn.setTitleColor(UIColor(red: 0x33/255.0, green: 0x77/255.0, blue: 0xFF/255.0, alpha: 1.0), for: .normal)
        self.cancelBtn.titleLabel?.font = UIFont.systemFont(ofSize: 15, weight: .medium)
        self.contaienrView.addSubview(self.cancelBtn)
        self.cancelBtn.snp.makeConstraints { make in
            make.trailing.bottom.equalToSuperview()
            make.leading.equalTo(self.vLine.snp.trailing)
            make.height.equalTo(49)
        }
    }
    
    var contaienrView: UIView!
    var titleLabel: UILabel!
    var descLabel: UILabel!
    var hLine: UIView!
    var vLine: UIView!
    var clearBtn: UIButton!
    var cancelBtn: UIButton!
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxx5w8hc5aj30hc0zsdgi.jpg" alt="image-20211231175113346"/></p><h2>How it works</h2><p>如果你想在SwiftUI中预览UIViewController，那么需要包裹成<strong>UIViewControllerRepresentable</strong>。</p><p>要实现<strong>UIViewControllerRepresentable</strong>, 我们需要实现两个方法 <strong>makeUIViewController</strong> 和 <strong>updateUIViewController</strong>.</p><p>makeUIViewController返回UIViewController，你再这里初始化你的viewcontroller。</p><p><strong>updateUIViewController</strong>负责更新状态，我们demo中没有状态需要更新，就留空了。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑030-预览不同设备上的布局]]></title>
            <link>https://gouxin.fun/2021/12/03/SwiftUI专辑-030-预览不同设备上的布局</link>
            <guid>/2021/12/03/SwiftUI专辑-030-预览不同设备上的布局</guid>
            <pubDate>Fri, 03 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI允许我们通过.previewDevice()修饰符，在多种屏幕尺寸上、设备类型同时预览布局。</p><h2>Getting ready</h2><p>首先创建一个新项目：<strong>PreviewOnDifferentDevices</strong></p><h2>How to do it</h2><ol><li>添加一张图片到Preivew Content的xcassets中。</li><li>替换默认的Text为以下代码</li></ol><pre><code class="language-swift">struct ContentView: View {
    var body: some View {
          VStack{
            Image(&quot;friendship&quot;)
               .resizable()
               .aspectRatio(contentMode: .fit)
            Text(&quot;Importance of  Friendship&quot;).font(.title)
            Text(&quot;Friends helps us deal with stress and make better life choices&quot;)
                .multilineTextAlignment(.center).padding()
          }
    }
}
</code></pre><ol start="3"><li>修改preview的代码，在对个设备上同时预览</li></ol><pre><code class="language-swift">struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView()
                .previewDevice(.init(rawValue: &quot;iPhone 11 Pro Max&quot;))
                .previewDisplayName(&quot;Iphone 11 Pro Max&quot;)
            ContentView()
                .previewDevice(.init(rawValue: &quot;iPhone 8&quot;))
                .previewDisplayName(&quot;iPhone 8&quot;)
            ContentView()
                .previewLayout(.fixed(width: 568, height: 320))
                .previewDisplayName(&quot;Custom Size landscape&quot;)
            
        }
    }
}
</code></pre><p>最终结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw2mjewzwj30af0hh0t7.jpg" alt="20211230191108"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw2mqpkigj30af0jz74u.jpg" alt="20211230191123"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw2myjtu8j30af0710st.jpg" alt="20211230191135"/></p><h2>How it works</h2><p> <strong>.previewDevice()</strong>修饰符能够让你在特定设备上预览。</p><p>如果你不知道名字的话，可以通过模拟器来确定</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw2op9qhzj30jo0w2jub.jpg" alt="image-20211230191436168"/></p><p>如果要看横屏的话，可以通过自定义大小来查看:<strong>.previewLayout()</strong></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑029-预览View嵌入NavigationView]]></title>
            <link>https://gouxin.fun/2021/12/02/SwiftUI专辑-029-预览View嵌入NavigationView</link>
            <guid>/2021/12/02/SwiftUI专辑-029-预览View嵌入NavigationView</guid>
            <pubDate>Thu, 02 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
有些View自身并不包含NavigationView，但是他又属于NavigationView stack中的一部分。
这个时候我们要看导航栏的话，就需要运行App并导航到对应界面。
不过，预览提供了一种节省时间的方式来实时查看 UI 更改，而无需重新构建应用程序。</p><h2>Getting ready</h2><p>我们先创建一个SwiftUI工程：<strong>PreviewingInNavigationView</strong></p><h2>How to do it</h2><ol><li>替换默认的Text为以下代码</li></ol><pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: SecondView(someText: &quot;Sample text&quot;)) {
                    Text(&quot;Go to second view&quot;)
                        .foregroundColor(Color.white)
                        .padding()
                        .background(Color.black)
                        .cornerRadius(25)
                }

            }.navigationBarTitle(&quot;Previews&quot;, displayMode: .inline)
        }
    }
}
</code></pre><ol start="2"><li>实现报错的<strong>SecondView</strong></li></ol><pre><code class="language-swift">
struct SecondView: View {
    var someText: String
        var body: some View {
            Text(someText)
                .navigationBarTitle(&quot;Second View &quot;, displayMode: .inline)
        }
}

///这个preview，并没有看到设置的导航栏title, 我们需要运行后进入这个界面才能看到
struct SecondView_Previews: PreviewProvider {
    static var previews: some View {
        SecondView()
    }
}
</code></pre><ol start="3"><li>修改SecondView_Previews，嵌入NavigationView</li></ol><pre><code class="language-swift">struct SecondView_Previews: PreviewProvider {
    static var previews: some View {
        NavigationView {
            SecondView(someText: &quot;Testting&quot;)
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw231yqswj30dy0r8wew.jpg" alt="image-20211230185348484"/></p><h2>How it works</h2><p>处于导航栈里的界面的<strong>.navigationBarTitle()</strong>，预览是看不见，我们可以修改预览的代码，将其嵌入NavigationView就能看到了。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑028-预览动态字体dynamicTypeSize]]></title>
            <link>https://gouxin.fun/2021/12/01/SwiftUI专辑-028-预览动态字体dynamicTypeSize</link>
            <guid>/2021/12/01/SwiftUI专辑-028-预览动态字体dynamicTypeSize</guid>
            <pubDate>Wed, 01 Dec 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
您可能希望改进应用的一些功能以吸引更多的用户 。比如：用户可能喜欢的不同字体，这意味着要确保设计在不同字体大小下看起来不错。SwiftUI 预览非常适合此类情况。它们允许您立即预览新内容在不同动态字体大小下的外观。
我们来编写一个新闻类文章demo。</p><h2>Getting ready</h2><p>创建一个新的SwiftUI工程：<strong>DynamicTypeSizesPreview</strong>。</p><h2>How to do it</h2><p>一个新闻类文章应该包含一个图片，一个title，和一段描述。我们首选创建一个model来代表一个新闻，然后创建一个View来显示他，最后在不同大小的设备上预览。</p><ol><li>我们把两个图片放到Preview Content下的xcassets下</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvp1z7yt3j319u0ju76s.jpg" alt="image-20211230112258939"/></p><ol start="2"><li>新建一个文件<strong>Article</strong>，定义model</li></ol><pre><code class="language-swift">struct Article {
    var imageName:String
    var title: String
    var description: String
}
</code></pre><ol start="3"><li>在Article定义的下方，我们创建点数据用于预览</li></ol><pre><code class="language-swift">let sampleArticle1 = Article(imageName: &quot;reading&quot;, title: &quot;Love reading&quot;, description: &quot;Reading is essential to success&quot;)
let sampleArticle2 = Article(imageName: &quot;naptime&quot;, title: &quot;Nap time&quot;, description: &quot;Take naps when tired to improve performance&quot;)
</code></pre><ol start="4"><li>新建一个SwiftUI view： <strong>ArticleView</strong></li></ol><pre><code class="language-swift">struct ArticleView: View {
    var article: Article
    var body: some View {
        HStack {
            Image(article.imageName)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 150, height: 100)
                .clipShape(Ellipse())
            VStack {
                Text(article.title)
                    .font(.title)
                Text(article.description)
                    .padding()
            }
        }
    }
}
</code></pre><ol start="5"><li>preview中传入我们的demo数据</li></ol><pre><code class="language-swift">struct ArticleView_Previews: PreviewProvider {
    static var previews: some View {
        ArticleView(article: sampleArticle1)
    }
}
</code></pre><p>预览就得到：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvp9j8h0nj30pg0ao3z3.jpg" alt="image-20211230113015389"/></p><ol start="6"><li>换个预览数据</li></ol><pre><code class="language-swift">struct ArticleView_Previews: PreviewProvider {
    static var previews: some View {
        ArticleView(article: sampleArticle2)
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvpan0fcij30oi0bu3z6.jpg" alt="image-20211230113119106"/></p><ol start="7"><li>好了，我们将ArticleView添加到ContentView中</li></ol><pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        ArticleView(article: sampleArticle1)
    }
}
</code></pre><ol start="8"><li>在ContentView_Previews添加个Group同时预览多个View</li></ol><pre><code class="language-swift">struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView()
            ContentView().environment(\.dynamicTypeSize, .xSmall)
        }
    }
}
</code></pre><ol start="9"><li>现在我们显示了2个device，不过都是全屏，我们要查看全部的话，需要滚动很长，我们希望只包含View那么大</li></ol><pre><code class="language-swift">struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView()
            ContentView().environment(\.dynamicTypeSize, .xSmall)
        }.previewLayout(.sizeThatFits)
    }
}
</code></pre><ol start="10"><li>最后我们再添加一个ContentView</li></ol><pre><code class="language-swift">ContentView().environment(\.dynamicTypeSize, .accessibility5)
</code></pre><p>最终结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw12ct3bbj30gc0zk0uf.jpg" alt="image-20211230181829540"/></p><h2>How it works</h2><p>我们通过Group可以同时预览多个设备。</p><p>我们通过 <strong>.environment()</strong>的<strong>dynamicTypeSize</strong> 设置不同的值来预览不同dynamicTypeSize下的情况。</p><p>我们同时预览多个设备时，他们都是全屏，我们需要滚动才能查看全部，浪费时间。我们通过<strong>.previewLayout(.sizeThatFits)</strong>解决，这样每个预览都只有自身大小。</p><h2>关于Dynamic Type Sizes</h2><p>可查看<a href="https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/typography/#dynamic-type-sizes">官方文档</a></p><p>这个7个值分别对应iphone手机上的：设置-》辅助功能-》显示与文字大小-》更大字体中的7个字体大小。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw1h95t51j31590u0dhy.jpg" alt="image-20211230183251548"/></p><p>除了这7个值，还可以设置accessbility的5个值</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw1jd5fu1j314s0u0q4u.jpg" alt="image-20211230183453468"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑027-预览黑暗模式]]></title>
            <link>https://gouxin.fun/2021/11/30/SwiftUI专辑-027-预览黑暗模式</link>
            <guid>/2021/11/30/SwiftUI专辑-027-预览黑暗模式</guid>
            <pubDate>Tue, 30 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI内置支持黑暗模式。你只需要修改预览的设置，就能预览黑暗模式。
接下来我们将通过一个简单的例子演示一下。</p><h2>Getting ready</h2><p>创建个新的SwiftUI工程：<strong>DarkModePreview</strong></p><h2>How to do it</h2><p>自从 SwiftUI 出现以来，预览就存在一个问题，您无法在黑暗模式下预览任何视图，除非视图包含在<strong>NavigationView 中</strong>。这是一个功能还是一个错误？希望我们能在下一版 SwiftUI 中得到答案。</p><p>我们将在<strong>NavigationView 中</strong>包含一个<strong>Text</strong>，并在light和dark模式下预览它。步骤如下：</p><ol><li>打开ContentView.swift</li><li>添加一个环境变量</li></ol><pre><code class="language-swift">@Environment(\.colorScheme) var deviceColorScheme
</code></pre><ol start="3"><li>添加一个NavigationView</li></ol><pre><code class="language-swift">NavigationView {
    Text(deviceColorScheme == .dark ? &quot;Quick journey to the dark side&quot; : &quot;Back to the light&quot;)
}

</code></pre><ol start="4"><li>在<strong>Content_Previews</strong>中添加一个<strong>colorScheme</strong></li></ol><pre><code class="language-swift">struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        Group {
            ContentView().colorScheme(.dark)
            ContentView().colorScheme(.light)
        }
    }
}
</code></pre><p>此时能够在preview中查看到：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv451pn3bj30dm0qqdg3.jpg" alt="截屏2021-12-29 下午11.19.13"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxv4592ayej30dg0qwt93.jpg" alt="image-20211229231931515"/></p><h2>How it works</h2><p>在黑暗模式下预览内容的过程是不言自明的。预览显示来自<strong>ContentView</strong>视图的内容。如果未向预览提供配色方案，则使用<strong>.light</strong>作为默认配色方案。</p><p>为了在明暗模式下显示不同的文本，我们添加了一个<strong>deviceColorScheme</strong>环境变量。然后，我们在<strong>Text</strong>视图中使用三元运算符将其值更改<strong>为在</strong>检测到深色方案时显示<strong>Quick journey to the dark side</strong>，并在检测到浅色方案时 <strong>Back to the light</strong>。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑026-用DisclosureGroup显示隐藏内容]]></title>
            <link>https://gouxin.fun/2021/11/29/SwiftUI专辑-026-用DisclosureGroup显示隐藏内容</link>
            <guid>/2021/11/29/SwiftUI专辑-026-用DisclosureGroup显示隐藏内容</guid>
            <pubDate>Mon, 29 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
<strong>DisclosureGroup</strong>根据disclosure control状态来控制显示和隐藏的一个视图。</p><p>需要两个参数：标识其content的<strong>label</strong>， 以及控制content是可见还是隐藏的<strong>binding</strong>。</p><p>我们创建一个例子来仔细看看它是如何工作的。</p><h2>Getting ready</h2><p>首先，新建一个工程<strong>DisclosureGroups</strong></p><h2>How to do it…</h2><ol><li>首先，创建一个State</li></ol><pre><code class="language-swift">@State private var showplanets = true
</code></pre><ol start="2"><li>修改默认的Text为 <strong>List</strong> 和 <strong>DisclosureGroup</strong></li></ol><pre><code class="language-swift">List {
    DisclosureGroup(&quot;Planets&quot;, isExpanded: $showplanets) {
        Text(&quot;Mercury&quot;)
        Text(&quot;Venus&quot;)
    }
}
</code></pre><ol start="3"><li>再嵌套一个</li></ol><pre><code class="language-swift">var body: some View {
        List {
            DisclosureGroup(&quot;Planets&quot;, isExpanded: $showplanets) {
                Text(&quot;Mercury&quot;)
                Text(&quot;Venus&quot;)
                DisclosureGroup(&quot;Earth&quot;) {
                    Text(&quot;North America&quot;)
                    Text(&quot;South America&quot;)
                    Text(&quot;Europe&quot;)
                    Text(&quot;Africa&quot;)
                    Text(&quot;Asia&quot;)
                    Text(&quot;Antarctica&quot;)
                    Text(&quot;Oceania&quot;)
                }
            }
        }
    }
</code></pre><p>运行，最终结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxu08q6c3ij309q0l174f.jpg" alt="Simulator Screen Shot - iPhone 12 - 2021-12-29 at 00.18.08"/></p><h2>How it works…</h2><p>我们通过showplanets 控制<strong>DisclosureGroup</strong> content的显示和隐藏。</p><p><strong>DisclosureGroup</strong> 是能够嵌套的，用于显示多个层级。</p><p>DisclosureGroup也能脱离List单独使用。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑025-用List显示多层级列表]]></title>
            <link>https://gouxin.fun/2021/11/28/SwiftUI专辑-025-用List显示多层级列表</link>
            <guid>/2021/11/28/SwiftUI专辑-025-用List显示多层级列表</guid>
            <pubDate>Sun, 28 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
我们可以用展开收起的列表来展示层级。</p><h2>Getting ready</h2><p>首先，创建一个新项目：<strong>ExpandingLists</strong></p><h2>How to do it…</h2><ol><li>首先，定义一个多层数据结构</li></ol><pre><code class="language-swift">struct Backpack: Identifiable {
    let id = UUID()
    let name: String
    let icon: String
    var content: [Backpack]?
}
</code></pre><ol start="2"><li>准备数据</li></ol><pre><code class="language-swift">let dollar = Backpack(name: &quot;Dollar&quot;, icon: &quot;dollarsign.circle&quot;)
let yen = Backpack(name: &quot;Yen&quot;,icon: &quot;yensign.circle&quot;)
let currencies = Backpack(name: &quot;Currencies&quot;, icon: &quot;coloncurrencysign.circle&quot;, content: [dollar, yen])

let pencil = Backpack(name: &quot;Pencil&quot;,icon: &quot;pencil.circle&quot;)
let hammer = Backpack(name: &quot;Hammer&quot;,icon: &quot;hammer&quot;)
let paperClip = Backpack(name: &quot;Paperclip&quot;,icon: &quot;paperclip&quot;)
let glass = Backpack(name: &quot;Magnifying glass&quot;, icon: &quot;magnifyingglass&quot;)
let bin  = Backpack(name: &quot;Bin&quot;, icon: &quot;arrow.up.bin&quot;, content: [paperClip, glass])
let tools = Backpack(name: &quot;Tools&quot;, icon: &quot;folder&quot;, content: [pencil, hammer,bin])
</code></pre><ol start="3"><li>在contentView中定义数据</li></ol><pre><code class="language-swift">struct ContentView: View {
    let bagContents = [currencies,tools]
}
</code></pre><ol start="4"><li>显示数据</li></ol><pre><code class="language-swift">var body: some View {
    List(bagContents, children: \.content){ row in
        Image(systemName: row.icon)
        Text(row.name)
    }
}
</code></pre><p>最终结果:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtzpns2luj309q0l1t8v.jpg" alt="Simulator Screen Shot - iPhone 12 - 2021-12-28 at 23.57.21"/></p><h2>How it works…</h2><p>首先我们定义了<strong>Backpack</strong>，拥有嵌套结构，能表示多个层级。</p><p>我们显示List时，指定children为content字段。</p><pre><code class="language-swift">List(bagContents, children: \.content){ row in
    Image(systemName: row.icon)
    Text(row.name)
}
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑024-用ScrollViewReader控制滚动]]></title>
            <link>https://gouxin.fun/2021/11/27/SwiftUI专辑-024-用ScrollViewReader控制滚动</link>
            <guid>/2021/11/27/SwiftUI专辑-024-用ScrollViewReader控制滚动</guid>
            <pubDate>Sat, 27 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
<strong>ScrollViewReader</strong>允许你通过代码控制滚动到某个Index处，这个Index甚至可能在当前屏幕中并不可见。</p><p>比如：自动滚动到新添加的item，自动滚动到最近更新的item等等。</p><p>在本节中，我们将创建一个显示从 A 到 Q 的字符列表。屏幕顶部的按钮将在单击时以编程方式从列表顶部滚动到列表末尾。屏幕底部的另一个按钮将允许我们从底部向上滚动到列表中间。</p><h2>Getting ready</h2><p>首先新建一个swiftui项目<strong>ScrollViewReaders</strong></p><h2>How to do it…</h2><ol><li>首先创建一个数据结构：CharacterInfo</li></ol><pre><code class="language-swift">struct CharacterInfo: Identifiable {
    var name: String
    var id: Int
}
</code></pre><ol start="2"><li>准备数据</li></ol><pre><code class="language-swift"> let charArray = [
    CharacterInfo(name: &quot;a.circle.fill&quot;, id: 0),
    CharacterInfo(name: &quot;b.circle.fill&quot;, id: 1),
    CharacterInfo(name: &quot;c.circle.fill&quot;, id: 2),
    CharacterInfo(name: &quot;d.circle.fill&quot;, id: 3),
    CharacterInfo(name: &quot;e.circle.fill&quot;, id: 4),
    CharacterInfo(name: &quot;f.circle.fill&quot;, id: 5),
    CharacterInfo(name: &quot;g.circle.fill&quot;, id: 6),
    CharacterInfo(name: &quot;h.circle.fill&quot;, id: 7),
    CharacterInfo(name: &quot;i.circle.fill&quot;, id: 8),
    CharacterInfo(name: &quot;j.circle.fill&quot;, id: 9),
    CharacterInfo(name: &quot;k.circle.fill&quot;, id: 10),
    CharacterInfo(name: &quot;l.circle.fill&quot;, id: 11),
    CharacterInfo(name: &quot;m.circle.fill&quot;, id: 12),
    CharacterInfo(name: &quot;n.circle.fill&quot;, id: 13),
    CharacterInfo(name: &quot;o.circle.fill&quot;, id: 14),
    CharacterInfo(name: &quot;p.circle.fill&quot;, id: 15),
    CharacterInfo(name: &quot;q.circle.fill&quot;, id: 16),
]
</code></pre><ol start="3"><li>替换默认的Text为Scrollview和ScrollViewReader</li></ol><pre><code class="language-swift">var body: some View {
    ScrollView {
        ScrollViewReader { value in
            Button(&quot;go to q&quot;) {
                value.scrollTo(16)
            }.padding().background(Color.yellow)
        }
    }
}
</code></pre><ol start="4"><li>将列表加进去</li></ol><pre><code class="language-swift">var body: some View {
    ScrollView {
        ScrollViewReader { value in
            Button(&quot;go to q&quot;) {
                value.scrollTo(16)
            }.padding().background(Color.yellow)
            ForEach(charArray) { image in
                Image(systemName: image.name)
                    .id(image.id)
                    .font(.largeTitle)
                    .foregroundColor(Color.yellow)
                    .frame(width: 90, height: 90)
                    .background(Color.blue)
                    .padding()
            }
        }
    }
}
</code></pre><ol start="5"><li>再加个按钮，滚动到G</li></ol><pre><code class="language-swift">
var body: some View {
    ScrollView {
        ScrollViewReader { value in
            ....
            Button(&quot;Go to G&quot;) { 
                        value.scrollTo(6, anchor: .bottom)
                        }.padding().background(Color.yellow)            
        }
    }
}
</code></pre><p>最终结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtqebas96j309j0jh3yt.jpg" alt="20211228183732"/></p><h2>How it works…</h2><p> <strong>CharacterInfo</strong> 遵循<strong>Identifiable</strong> 协议，包含2个属性  <strong>name</strong> 和 <strong>id</strong>。 <strong>id</strong> 是必须的，<strong>ScrollViewReader</strong> 用这个来定位每个item。就行你的房间号一样，ScrollView知道该往什么地方滚动。</p><p>我们将ScrollViewReader嵌套在ScrollView中，这样就能够使用<strong>scrollTo()</strong> 方法。</p><p> <strong>scrollTo()</strong> 方法有个 <strong>anchor</strong> 参数，用来指定我们想滚动到的位置， 他是某个item的id 。第二个参数用来指定Item滚动到顶部、底部、还是中心等。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑023-LazyHGrid和LazyVGrid]]></title>
            <link>https://gouxin.fun/2021/11/26/SwiftUI专辑-023-LazyHGrid和LazyVGrid</link>
            <guid>/2021/11/26/SwiftUI专辑-023-LazyHGrid和LazyVGrid</guid>
            <pubDate>Fri, 26 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
和Lazy stack一样，lazy grid也使用lazy loading来显示一系列的items。items只会在即将出现在屏幕上时才会初始化。</p><p>从上到下的使用LazyVGrid， 从左到右的使用LazyHGrid。</p><h2>Getting ready</h2><p>我们创建一个新项目<strong>LazyGrids</strong></p><h2>How to do it…</h2><ol><li>首先在ContentView中创建LazyVGrid的布局信息， <strong>GridItem</strong>用来帮助配置lazy grid的布局</li></ol><pre><code class="language-swift">let coulumSpe = [GridItem(.adaptive(minimum: 100))]
</code></pre><ol start="2"><li>创建LazyHGrid的布局信息</li></ol><pre><code class="language-swift">let rowSpec = [GridItem(.flexible()),
                   GridItem(.flexible()),
                   GridItem(.flexible())]
</code></pre><ol start="3"><li>准备个颜色数组，之后用在item上</li></ol><pre><code class="language-swift">let colors: [Color] = [.green, .red, .yellow, .blue]
</code></pre><ol start="4"><li>替换原来的Text为VStack， ScrollView，<strong>LazyVGrid</strong></li></ol><pre><code class="language-swift">VStack {
  ScrollView {
      LazyVGrid(columns: coulumSpe, spacing: 20) {
          ForEach(1 ... 999, id: \.self) { index in
              Text(&quot;Item \(index)&quot;)
                  .padding(EdgeInsets(top: 30,leading: 15, bottom: 30, trailing: 15))
                  .background(colors[index % colors.count])
                  .clipShape(Circle())
                  .border(Color.red)
          }
      }
  }
}
</code></pre><ol start="5"><li>在来一个ScrollView显示LazyHGrid，注意调整scrollview方向</li></ol><pre><code class="language-swift">ScrollView(.horizontal) {
    LazyHGrid(rows: coulumSpe, spacing: 20) {
        ForEach(1 ... 999, id: \.self) { index in
            Text(&quot;Item \(index)&quot;)
                .foregroundColor(.white)
              .padding(EdgeInsets(top: 30,leading: 15, bottom: 30, trailing: 15))
                .background(colors[index % colors.count])
                .clipShape(Capsule())
        }
    }
}
</code></pre><p>最终结果:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtpcxubenj309o0jjt9q.jpg" alt="20211228180104"/></p><h2>How it works…</h2><p> lazy grid最基本的用法就是ScrollView中嵌套<strong>LazyVGrid</strong> 或者 <strong>LazyHGrid</strong></p><pre><code class="language-swift">ScrollView {
    LazyHGrid(columns: columnsSpec) {
        // Items to be displayed
    }
}
</code></pre><p>其中最重要的是要理解如何定义行和列。比如上面的，我们的<strong>LazyVGrid</strong>只定义了包含一个<strong>GridItem</strong>的数组，但是却显示了3列。这是怎么回事？原因在于<strong>GridItem</strong>是如何定义的。我们定义<strong>GridItem(.adaptive(minimum: 100))</strong>，就是告诉SwiftUI每个item至少100宽，然后一行尽可能多的放置Item，因此每一行的个数可能在横屏和竖屏下不一样。</p><p>如果你想指定每一行的个数，你可以使用 <strong>GridItem(.flexible())</strong>。就像我们上面定义的</p><pre><code class="language-swift">let rowSpec = [
    GridItem(.flexible()),
    GridItem(.flexible()),
    GridItem(.flexible())
]
</code></pre><p>添加3个flexible的GridItem会将可用 空间3等分。然后用那段空间显示，如果空间用不完，那么就是空白。</p><h2>Api详情</h2><h3>LazyVGrid</h3><pre><code class="language-swift">//注意有个pinnedViews，和LazyVStack一样，可以设置一直悬浮的header/footer
init(columns: [GridItem], alignment: HorizontalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), content: () -&gt; Content)
</code></pre><pre><code class="language-swift">LazyVGrid(columns: coulumSpe, spacing: 20, pinnedViews: .sectionHeaders) {
    Section(header: Text(&quot;this is section header&quot;)) {
        ForEach(1 ... 999, id: \.self) { index in
            Text(&quot;Item \(index)&quot;)
                .padding(EdgeInsets(top: 30,leading: 15, bottom: 30, trailing: 15))
                .background(colors[index % colors.count])
                .clipShape(Circle())
                .border(Color.red)
        }
    }
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtpsgjzngj30hg0j4abp.jpg" alt="image-20211228181716473"/></p><h3>LazyHGrid</h3><pre><code class="language-swift">//注意有个pinnedViews，和LazyVStack一样，可以设置一直悬浮的header/footer
init(rows: [GridItem], alignment: VerticalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), content: () -&gt; Content)
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑022-使用LazyHStack和LazyVStack]]></title>
            <link>https://gouxin.fun/2021/11/25/SwiftUI专辑-022-使用LazyHStack和LazyVStack</link>
            <guid>/2021/11/25/SwiftUI专辑-022-使用LazyHStack和LazyVStack</guid>
            <pubDate>Thu, 25 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI 2.0 引入了<strong>LazyHStack</strong>和<strong>LazyVStack</strong>。它们的使用类似于常规的<strong>HStack</strong>和<strong>VStack</strong>，但提供了延迟加载。仅在content在设备的屏幕上变得可见前，List才开始加载content，允许用户无缝地滚动浏览大型数据集，没有明显的 UI 延迟或较长的加载时间。让我们创建一个demo来看看它在实践中是如何工作的。</p><h2>Getting ready</h2><p>首先创建一个Swiftui工程：<strong>LazyStacks</strong></p><h2>How to do it…</h2><ol><li>首先我们创建一个Cell：ListRow，他会在初始化时打印一些信息</li></ol><pre><code class="language-swift">struct ListRow: View {
    let id: Int
    let type: String
    init(id: Int, type: String){
        print(&quot;Loading \(type) item \(id)&quot;)
        self.id = id
        self.type = type
    }

    var body: some View {
        Text(&quot;\(type) \(id)&quot;).padding()
    }
}
</code></pre><ol start="2"><li>添加VStack， ScrollView， LazyHStack</li></ol><pre><code class="language-swift">var body: some View {
    VStack {
        ScrollView(.horizontal) {
            LazyHStack {
                ForEach(1 ... 10000, id: \.self) { item in
                    ListRow(id: item, type:&quot;Horizontal&quot;)
                }
            }
        }.frame(height: 100, alignment: .center)
    }
}
</code></pre><ol start="3"><li>再添加一个ScrollView， LazyVStack</li></ol><pre><code class="language-swift">ScrollView {
    LazyVStack {
        ForEach(1 ... 10000, id: \.self) { item in
            ListRow(id: item, type: &quot;Vertical&quot;)
        }
    }.border(Color.blue)
}
</code></pre><p>运行</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtga3v1pej30a30jq0t7.jpg" alt="20211228124742"/></p><p>当我们滚动时，能在控制台看到对应的初始化信息。</p><h2>How it works…</h2><p>正如我们在本节的介绍中提到的，<strong>LazyHStack</strong>和<strong>LazyVStack</strong>视图相对于常规<strong>HStack</strong>和<strong>VStack</strong>视图的主要优点是前者在显示item之前才加载它们，而后者在运行时一次加载所有item。</p><p>我们在滚动时，看到控制台显示初始化log，这是延迟加载。只有即将显示在屏幕上的item才会被初始化。</p><h2>Api详情</h2><h3>LazyHStack</h3><pre><code class="language-swift">//注意比普通Stack多了个pinnedViews，你可以设置sectionHeader或者sectionFooter悬浮在顶部/底部
init(alignment: VerticalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), content: () -&gt; Content)
</code></pre><pre><code class="language-swift">ScrollView {
    LazyVStack(pinnedViews: .sectionHeaders) {
        Section(header: Text(&quot;this is section header&quot;)) {
            ForEach(1 ... 10000, id: \.self) { item in
                ListRow(id: item, type: &quot;Vertical&quot;)
            }
        }
    }
}.border(Color.blue)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtgonw9q4j30is0hsdgd.jpg" alt="image-20211228130214194"/></p><h3>LazyVStack</h3><pre><code class="language-swift">//类似
init(alignment: HorizontalAlignment = .center, spacing: CGFloat? = nil, pinnedViews: PinnedScrollableViews = .init(), content: () -&gt; Content)
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑021-使用可搜索列表]]></title>
            <link>https://gouxin.fun/2021/11/24/SwiftUI专辑-021-使用可搜索列表</link>
            <guid>/2021/11/24/SwiftUI专辑-021-使用可搜索列表</guid>
            <pubDate>Wed, 24 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
<strong>列表</strong>视图可以包含一个到无数个item。随着列表中item数的增加，我们通常会提供在列表中搜索特定item的能力。</p><p>本章，我们将介绍<strong>.searchable()</strong>修饰符并讨论如何使用它来搜索列表中的item。</p><h2>Getting ready</h2><p>首先，创建一个新的SwiftUI项目<strong>SearchableLists</strong></p><h2>How to do it…</h2><ol><li>准备数据</li></ol><pre><code class="language-swift">@State private var searchText = &quot;&quot;
let messages = [
    &quot;Dad, can you lend me money?&quot;,
    &quot;Nada. Does money grow on trees?&quot;,
    &quot;What is money made out of?&quot;,
    &quot;Paper&quot;,
    &quot;Where does paper come from?&quot;,
    &quot;Huh.....&quot;,
]
</code></pre><ol start="2"><li>添加NavigationView和List</li></ol><pre><code class="language-swift">var body: some View {
    NavigationView {
        List {
          TextField(&quot;search&quot;, text: $searchText)
            ForEach(searchResults, id: \.self) { msg in
                Text(msg)
            }
        }.navigationBarTitle(&quot;Order Number&quot;)
            .searchable(text: $searchText)
    }
}
</code></pre><ol start="3"><li>实现searchResults</li></ol><pre><code class="language-swift">var searchResults: [String] {
  if self.searchText.isEmpty {
      return self.messages
  } else {
      return self.messages.filter {
          $0.lowercased().contains(searchText.lowercased())
      }
  }
}
</code></pre><p>运行</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxtdmnfnjvj30iw0qcq40.jpg" alt="image-20211228111630217"/></p><h2>How it works…</h2><p><strong>searchText</strong>保存正在搜索的值并作为参数传递给<strong>.searchable</strong>修饰符。每次<strong>searchText</strong>的值更改时，都会计算计算属性<strong>searchResults</strong>。最后，在<strong>ForEach</strong>结构中使用<strong>searchResults</strong>的值来显示基于搜索文本的过滤项目列表。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑020-将集合绑定到List]]></title>
            <link>https://gouxin.fun/2021/11/23/SwiftUI专辑-020-将集合绑定到List</link>
            <guid>/2021/11/23/SwiftUI专辑-020-将集合绑定到List</guid>
            <pubDate>Tue, 23 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
在 SwiftUI 中一直可以编辑列表，但在 WWDC 2021 和 SwiftUI 3 之前，这样做非常 效率低下，因为 SwiftUI 不支持绑定到集合。让我们在集合上使用绑定并讨论它现在如何以及为什么更好地工作。</p><h2>Getting ready</h2><p>让我们创建一个新的SwiftUI项目<strong>EditableListsFields</strong></p><h2>How to do it…</h2><ol><li>首先创建一个数据结构<strong>TodoItem</strong></li></ol><pre><code class="language-swift">struct TodoItem: Identifiable {
    let id = UUID()
    var title: String
    init(_ someTitle:String){
        title = someTitle
    }
}
</code></pre><ol start="2"><li>然后添加一个State</li></ol><pre><code class="language-swift">@State var todos = [
      TodoItem(&quot;Eat&quot;),
      TodoItem(&quot;Sleep&quot;),
      TodoItem(&quot;Code&quot;)
]
</code></pre><ol start="3"><li>替换默认的Text为List</li></ol><pre><code class="language-swift">var body: some View {
    List($todos) { $todo in
        TextField(&quot;Number&quot;, text: $todo.title)
    }
}
</code></pre><p>运行</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxtctmjiuej30w80myq3n.jpg" alt="image-20211228104834018"/></p><h2>How it works…</h2><p>让我们先看看 在 SwiftUI 3 之前如何处理可编辑列表。 在 SwiftUI 3 之前，可编辑项目列表的代码将使用列表索引来创建到集合的绑定，如下所示：</p><pre><code class="language-swift">List(0..&lt;todos.count) { index in
  TextField(&quot;Todo&quot;, text: $todos[index].title)
}
</code></pre><p>这样的代码不仅速度慢，而且编辑单个项目会导致 SwiftUI 重新渲染整个元素<strong>列表</strong>，从而导致 UI 闪烁和更新缓慢。</p><p>使用 SwiftUI 3，我们可以将绑定传递给元素集合，SwiftUI 将在内部处理 绑定到闭包中指定的当前元素。由于我们的整个集合都符合<strong>Identifiable</strong>协议，因此我们的每个列表项都可以通过其<strong>id</strong>参数来唯一标识；因此，从列表中添加或删除项目不会更改列表项目索引，也不会导致整个列表重新呈现。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑019-添加sections到List中]]></title>
            <link>https://gouxin.fun/2021/11/22/SwiftUI专辑-019-添加sections到List中</link>
            <guid>/2021/11/22/SwiftUI专辑-019-添加sections到List中</guid>
            <pubDate>Mon, 22 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本章我们将用section实现一个静态List。</p><h2>Getting ready</h2><p>首先，我们新建一个SwiftUI项目<strong>ListWithSections</strong></p><h2>How to do it…</h2><ol><li>首先添加一个<strong>NavigationView</strong>，和List。</li></ol><pre><code class="language-swift">NavigationView {
    List {

    }.navigationTitle(&quot;Continents and Countries&quot;)
        .navigationBarTitleDisplayMode(.inline)                
}
</code></pre><ol start="2"><li>添加sections到List中</li></ol><pre><code class="language-swift"> List {
    Section(header: Text(&quot;Africa&quot;)) {
        Text(&quot;Nigeria&quot;)
        Text(&quot;Ghana&quot;)
        Text(&quot;Kenya&quot;)
        Text(&quot;Senegal&quot;)
    }
    Section(header: Text(&quot;Europe&quot;)) {
        Text(&quot;Spain&quot;)
        Text(&quot;France&quot;)
        Text(&quot;Sweden&quot;)
        Text(&quot;Finland&quot;)
        Text(&quot;UK&quot;)
    }
}
</code></pre><p>运行，我们将看到</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxrdcyfgwnj30jo0u4t9t.jpg" alt="image-20211226173605636"/></p><h2>How it works…</h2><p><strong>Section</strong>用来将items组合成group。</p><p>section可以通过一个可选的header，用于显示在group的顶部。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑018-移动List中的rows]]></title>
            <link>https://gouxin.fun/2021/11/21/SwiftUI专辑-018-移动List中的rows</link>
            <guid>/2021/11/21/SwiftUI专辑-018-移动List中的rows</guid>
            <pubDate>Sun, 21 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本章我们将实现一个List， 允许用户移动，重新组织rows。</p><h2>Getting ready</h2><p>首先创建一个新的SwiftUI项目<strong>MovingListRows</strong></p><h2>How to do it…</h2><ol><li>还是准备数据</li></ol><pre><code class="language-swift">@State var countries = [&quot;USA&quot;, &quot;Canada&quot;, &quot;England&quot;, &quot;Cameroon&quot;, &quot;South Africa&quot;, &quot;Mexico&quot; , &quot;Japan&quot;, &quot;South Korea&quot;]
</code></pre><ol start="2"><li>构建一个NavigationView, EditButton, List，只是ForEach的时候我们添加上<strong>onMove</strong></li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var countries = [&quot;USA&quot;, &quot;Canada&quot;, &quot;England&quot;, &quot;Cameroon&quot;, &quot;South Africa&quot;, &quot;Mexico&quot; , &quot;Japan&quot;, &quot;South Korea&quot;]
    var body: some View {
        NavigationView {
            List {
                ForEach(countries, id: \.self) { country in
                    Text(country)
                }.onMove(perform: self.moveRow)
            }.navigationTitle(&quot;Countries&quot;)
                .navigationBarTitleDisplayMode(.inline)
                .navigationBarItems(trailing: EditButton())
        }
    }
   
    private func moveRow(source: IndexSet, destination: Int){
            
    }
}
</code></pre><ol start="3"><li>实现moveRow</li></ol><pre><code class="language-swift">private func moveRow(source: IndexSet, destination: Int){   
  countries.move(fromOffsets: source, toOffset: destination)
}
</code></pre><p>当我们点击Edit时</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxrcp8ng6zj30ig0r03zb.jpg" alt="image-20211226171317473"/></p><h2>How it works…</h2><p>首先我们需要一个EditButton来进入编辑模式。</p><p>在ForEach时，我们提供onMove这个modifier，当我们移动时会触发对应回调。</p><p><strong>moveRow</strong>函数有两个参数，<strong>source</strong> 和<strong>destination</strong>。分别代表当前index和移动后的index。</p><p>在回调中，我们修改数据源移动数据位置。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑017-创建一个可编辑的List]]></title>
            <link>https://gouxin.fun/2021/11/20/SwiftUI专辑-017-创建一个可编辑的List</link>
            <guid>/2021/11/20/SwiftUI专辑-017-创建一个可编辑的List</guid>
            <pubDate>Sat, 20 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本章我们将演示，如何通过EditButton来让列表进入可编辑模式。</p><h2>Getting ready</h2><p>新建一个SwiftUI项目<strong>ListRowEdit</strong></p><h2>How to do it…</h2><p>我们将沿用上个例子的代码</p><ol><li>复制上个项目中ContentView中的代码过来</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var countries = [&quot;USA&quot;, &quot;Canada&quot;, &quot;England&quot;, &quot;Cameroon&quot;, &quot;South Africa&quot;, &quot;Mexico&quot; , &quot;Japan&quot;, &quot;South Korea&quot;]
    var body: some View {
        NavigationView {
            List {
                ForEach(countries, id: \.self) { country in
                    Text(country)
                }.onDelete(perform: self.deleteItem)
            }.navigationTitle(&quot;Countries&quot;)
                .navigationBarTitleDisplayMode(.inline)
        }
    }
   
    func deleteItem(at indexSet: IndexSet) {
        self.countries.remove(atOffsets: indexSet)
    }
}
</code></pre><ol start="2"><li>为navigation bar添加一个editButton</li></ol><pre><code class="language-swift">.navigationBarItems(trailing: EditButton())
</code></pre><ol start="3"><li>点击Edit按钮，进入编辑模式，点击“-” ，将出现delete按钮，选择delete，将删除Item</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxrcaycba8j30hi0j8q3g.jpg" alt="image-20211226165934238"/></p><h2>How it works…</h2><p><strong>.navigationBarItems(trailing: EditButton())</strong>在右上角增加了一个按钮。点击后，将在每个Cell前出现一个减号。点击减号，将出现delete按钮，选择delete将删除cell。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑016-从List中删除rows]]></title>
            <link>https://gouxin.fun/2021/11/19/SwiftUI专辑-016-从List中删除rows</link>
            <guid>/2021/11/19/SwiftUI专辑-016-从List中删除rows</guid>
            <pubDate>Fri, 19 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
之前我们已经知道了如何添加rows。
现在我们来学习一下如何用swipe手势删除rows。</p><h2>Getting ready</h2><p>首先，我们新建一个SwiftUI项目:<strong>ListRowDelete</strong></p><h2>How to do it…</h2><ol><li>首先，在ContentView中准备一点数据</li></ol><pre><code class="language-swift">@State var countries = [&quot;USA&quot;, &quot;Canada&quot;, &quot;England&quot;, &quot;Cameroon&quot;, &quot;South Africa&quot;, &quot;Mexico&quot; , &quot;Japan&quot;, &quot;South Korea&quot;]
</code></pre><ol start="2"><li>在body中显示出来，并加上<strong>onDelete</strong></li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var countries = [&quot;USA&quot;, &quot;Canada&quot;, &quot;England&quot;, &quot;Cameroon&quot;, &quot;South Africa&quot;, &quot;Mexico&quot; , &quot;Japan&quot;, &quot;South Korea&quot;]
    var body: some View {
        NavigationView {
            List {
                ForEach(countries, id: \.self) { country in
                    Text(country)
                }.onDelete(perform: self.deleteItem)
            }.navigationTitle(&quot;Countries&quot;)
                .navigationBarTitleDisplayMode(.inline)
        }
    }
  
    func deleteItem(at indexSet: IndexSet) {
        
    }
}
</code></pre><ol start="3"><li>实现deleteItem</li></ol><pre><code class="language-swift">private func deleteItem(at indexSet: IndexSet){
    self.countries.remove(atOffsets: indexSet)
}
</code></pre><p>最终结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxrbw8m86tj30jg0rsdgp.jpg" alt="image-20211226164525655"/></p><h2>How it works…</h2><p>我们看到了一个新的modifier: <strong>.onDelete</strong> 。他会在我们点击删除时，执行设置的回调。</p><p>本例中点击后会执行<strong>deleteItem</strong>。这个函数有一个<strong>IndexSet</strong>参数，他里面包含需要被删除的index。</p><p>然后我们修改数据源，移除这些Index。</p><p>当然，我们还可以通过添加<strong>EditButton</strong>来进入编辑模式，实现对rows的删除。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑015-添加rows到List中]]></title>
            <link>https://gouxin.fun/2021/11/18/SwiftUI专辑-015-添加rows到List中</link>
            <guid>/2021/11/18/SwiftUI专辑-015-添加rows到List中</guid>
            <pubDate>Thu, 18 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
用户对列表最常见的操作无外乎：增、删、改。
本章将介绍如何增加rows。</p><h2>Getting ready</h2><p>新建一个SwiftUI工程，叫做<strong>ListRowAdd</strong></p><h2>How to do it…</h2><p>让我们最顶部创建一个Button，用于往列表中加rows。</p><ol><li>在<strong>ContentView</strong>中创建一个数组</li></ol><pre><code class="language-swift">@State var numbers = [1,2,3,4]
</code></pre><ol start="2"><li>添加一个<strong>NavigationView</strong>和一个<strong>List</strong></li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var numbers = [1,2,3,4]
    var body: some View {
        NavigationView {
            List {
                ForEach(numbers, id: \.self) { number in
                    Text(&quot;\(number)&quot;)
                }
            }
        }
    }
}
</code></pre><ol start="3"><li>给List添加一个NavigationBarTitle</li></ol><pre><code class="language-swift">.navigationTitle(&quot;NumberList&quot;)
.navigationBarTitleDisplayMode(.inline)
</code></pre><ol start="4"><li>给navigation bar添加一个button</li></ol><pre><code class="language-swift">.navigationBarItems(trailing: Button(&quot;Add&quot;, action: self.addItemToRow))
</code></pre><ol start="5"><li>实现addItemToRow方法</li></ol><pre><code class="language-swift">private func addItemToRow() {
    self.numbers.append(Int.random(in: 5 ..&lt; 100))
}
</code></pre><p>最终，我们点击add时，能够看到新的cell。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxrb7om4nlj30im0nk3yw.jpg" alt="image-20211226162149439"/></p><h2>How it works…</h2><p>我们定义了一个State： numbers，然后使用ForEach，将numbers显示出来。</p><p>我们使用<strong>navigationBarTitle</strong>增加了一个navigationBar。</p><p>然后使用<strong>navigationbartItems</strong>在右边增加了一个按钮，并绑定点击事件。</p><p>我们在点击事件中，修改State：numbers。由于数据源变了，View自动刷新，将新添加的数字显示了出来。</p><p>上面的例子可能有点小问题，注意我们的ForEach中使用了<!-- -->\<!-- -->.self。而ForEach的id应该是唯一的，我们的随机数可能产生相同的数字，而相同的id可能导致一些异常行为。这里只是一个例子，我们只要记住id应该具有唯一性就好。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑014-List中使用自定义Cell]]></title>
            <link>https://gouxin.fun/2021/11/17/SwiftUI专辑-014-List中使用自定义Cell</link>
            <guid>/2021/11/17/SwiftUI专辑-014-List中使用自定义Cell</guid>
            <pubDate>Wed, 17 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
如果我们每次都要用到相同的Cell，而每次都重复写一些HStack肯定不是一个好的选择，此时我们可以把这些View封装成一个Cell，增加代码的可重用性。</p><h2>Getting ready</h2><p>首先，新建一个SwiftUI项目：<strong>CustomRows</strong></p><h2>How to do it…</h2><p>首先，把上个项目的代码复制过来。</p><ol><li>新建一个SwiftUI View文件<strong>WeatherRow</strong>，在这里定义cell</li></ol><pre><code class="language-swift">struct WeatherRow: View {
    var weather: WeatherInfo
    var body: some View {
        HStack {
            Image(systemName: weather.image)
                .frame(width: 50, alignment: .leading)
            Text(&quot;\(weather.temp)°F&quot;)
                .frame(width: 80, alignment: .leading)
            Text(weather.city)
        }
        .font(.system(size: 25))
        .padding()
    }
}
</code></pre><ol start="2"><li>如果你要预览的话，可以在<strong>WeatherRow_Previews</strong>增加点数据</li></ol><pre><code class="language-swift">struct WeatherRow_Previews: PreviewProvider {
    static var previews: some View {
        WeatherRow(weather: WeatherInfo(image: &quot;snow&quot;, temp: 5, city:&quot;New York&quot;))
    }
}
</code></pre><ol start="3"><li>修改ContentView.swift，使用我们的WeatherRow</li></ol><pre><code class="language-swift">List {
    ForEach(self.weatherData) { weather in
       WeatherRow(weather: weather)
    }
}.listStyle(.grouped)

</code></pre><p>最终得到同样的结果：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxraiqq2f9j30iq0wowfo.jpg" alt="image-20211226155748936"/></p><h2>How it works…</h2><p>我们将cell的代码单独抽离到WeatherRow中，其他地方如果需要相同的View，那么就可以直接使用WeatherRow了。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑013-创建static items List]]></title>
            <link>https://gouxin.fun/2021/11/16/SwiftUI专辑-013-创建static-items-List</link>
            <guid>/2021/11/16/SwiftUI专辑-013-创建static-items-List</guid>
            <pubDate>Tue, 16 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
<strong>List</strong> 和ScrollView类似，都是用来显示一个Items的集合。不同的是<strong>List</strong>更适合处理较大的数据集，因为它们不会将整个数据集加载到内存中。</p><p>本章，我们将会用static list来显示各个城市的天气信息。</p><h2>Getting ready</h2><p>新建一个SwiftUI工程：<strong>StaticList</strong>。</p><h2>How to do it…</h2><ol><li>首先创建一个数据结构来存储天气信息</li></ol><pre><code class="language-swift">struct WeatherInfo: Identifiable {
    var id = UUID()
    var image: String
    var temp: Int
    var city: String
}
</code></pre><ol start="2"><li>在ContenView中准备天气数据</li></ol><pre><code class="language-swift">let weatherData: [WeatherInfo] = [
    WeatherInfo(image: &quot;snow&quot;, temp: 5, city:&quot;NewYork&quot;),
    WeatherInfo(image: &quot;cloud&quot;, temp:5, city:&quot;KansasCity&quot;),
    WeatherInfo(image: &quot;sun.max&quot;, temp: 80, city:&quot;SanFrancisco&quot;),
    WeatherInfo(image: &quot;snow&quot;, temp: 5,city:&quot;Chicago&quot;),
    WeatherInfo(image: &quot;cloud.rain&quot;, temp: 49,city:&quot;Washington DC&quot;),
    WeatherInfo(image: &quot;cloud.heavyrain&quot;, temp: 60,city:&quot;Seattle&quot;),
    WeatherInfo(image: &quot;sun.min&quot;, temp: 75,city:&quot;Baltimore&quot;),
    WeatherInfo(image: &quot;sun.dust&quot;, temp: 65,city:&quot;Austin&quot;),
    WeatherInfo(image: &quot;sunset&quot;, temp: 78,city:&quot;Houston&quot;),
    WeatherInfo(image: &quot;moon&quot;, temp: 80,city:&quot;Boston&quot;),
    WeatherInfo(image: &quot;moon.circle&quot;, temp: 45,city:&quot;denver&quot;),
    WeatherInfo(image: &quot;cloud.snow&quot;, temp: 8,city:&quot;Philadelphia&quot;),
    WeatherInfo(image: &quot;cloud.hail&quot;, temp: 5,city:&quot;Memphis&quot;),
    WeatherInfo(image: &quot;cloud.sleet&quot;, temp:5,city:&quot;Nashville&quot;),
    WeatherInfo(image: &quot;sun.max&quot;, temp: 80, city:&quot;SanFrancisco&quot;),
    WeatherInfo(image: &quot;cloud.sun&quot;, temp: 5,city:&quot;Atlanta&quot;),
    WeatherInfo(image: &quot;wind&quot;, temp: 88, city:&quot;LasVegas&quot;),
    WeatherInfo(image: &quot;cloud.rain&quot;, temp: 60,city:&quot;Phoenix&quot;),
    ]
</code></pre><ol start="3"><li>添加List，用ForEach显示每个天气信息</li></ol><pre><code class="language-swift">List {
  ForEach(self.weatherData) { weather in
      HStack {
          Image(systemName: weather.image).frame(width: 50, alignment: .leading)
          Text(&quot;\(weather.temp)°F&quot;).frame(width: 80, alignment:.leading)
          Text(weather.city)
      }.font(.system(size: 25))
      .padding()
  }
}.listStyle(.grouped)
</code></pre><p>最终显示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxp3gwbp7wj30is0sejsg.jpg" alt="image-20211224182243081"/></p><h2>How it works…</h2><p>首先我们创建<strong>WeatherInfo</strong>结构体，并让其遵循<strong>Identifiable</strong>协议，这样使用ForEach的时候就不用指定id了。</p><p>然后每个item使用HStack来显示其中的内容。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑012-使用ScrollView]]></title>
            <link>https://gouxin.fun/2021/11/15/SwiftUI专辑-012-使用ScrollView</link>
            <guid>/2021/11/15/SwiftUI专辑-012-使用ScrollView</guid>
            <pubDate>Mon, 15 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
当要显示的内容无法放入其容器时, 你可以使用ScrollView。</p><p>滚动视图默认是垂直的，但也可以设置为水平的。</p><p>本章我们将学习如何创建水平和垂直的ScrollView</p><h2>Getting ready</h2><p>新建一个SwiftUI项目<strong>WeScroll</strong></p><h2>How to do it…</h2><p>我们将创建一个显示字母A-P的ScrollView。</p><ol><li>添加我们需要的字母到contentView中</li></ol><pre><code class="language-swift">let letters = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;]
</code></pre><ol start="2"><li>替换ContentView为以下内容</li></ol><pre><code class="language-swift">struct ContentView: View {
    let letters = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;h&quot;,&quot;i&quot;,&quot;j&quot;,&quot;k&quot;,&quot;l&quot;,&quot;m&quot;,&quot;n&quot;,&quot;o&quot;,&quot;p&quot;]
    var body: some View {
        VStack {
            ScrollView(.vertical, showsIndicators: true) {
                ForEach(self.letters, id: \.self) { letter in
                    Image(systemName: letter)
                        .font(.largeTitle)
                        .foregroundColor(.yellow)
                        .background(Color.blue)
                        .frame(width: 50, height: 50, alignment: .center)
                        .symbolVariant(.circle.fill)
                }
            }.frame(width: 50, height: 200, alignment: .center)
            
            ScrollView(.horizontal, showsIndicators: true) {
                HStack {
                    ForEach(self.letters, id: \.self) { letter in
                        Image(systemName: letter)
                            .font(.largeTitle)
                            .foregroundColor(.yellow)
                            .background(Color.blue)
                            .frame(width: 50, height: 50, alignment: .center)
                            .symbolVariant(.circle.fill)
                    }
                }
            }
        }
    }
}
</code></pre><p>最终得到</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxp2e0sd2pj30iu0rogmg.jpg" alt="image-20211224174523532"/></p><h2>How it works…</h2><p>默认情况下，ScrollView是垂直滚动的。</p><p>这里我们使用了ForEach来将我们的集合数据转化成Views。</p><p>我们给ForEach传递了2个参数，第一个是需要迭代的collection，第二个是id。id帮助我们区别每个item，他们应该是唯一的。因为我们集合中的每个字母是唯一的，因此可以使用.self作为id。</p><p>如果你的item遵循<strong>Identifiable</strong>协议，就不用提供id参数，会使用Identifiable的id作为id。</p><p>第二个scrollview指定了滚动方向为水平，要显示滚动条，要水平显示内容，我们用HStack让字母水平排列。</p><h2>Api详情</h2><h3>ScrollView</h3><h4>Creating a Scroll View</h4><pre><code class="language-swift">//可以水平，垂直，或者两个一起滚动。
init(_ axes: Axis.Set = .vertical, showsIndicators: Bool = true, content: () -&gt; Content)
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑011-iOS14以上的View和Controls]]></title>
            <link>https://gouxin.fun/2021/11/14/SwiftUI专辑-011-iOS14以上的View和Controls</link>
            <guid>/2021/11/14/SwiftUI专辑-011-iOS14以上的View和Controls</guid>
            <pubDate>Sun, 14 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本章我们将查看</p><ul><li><strong>ProgressView</strong></li><li><strong>ColorPicker</strong></li><li><strong>Link</strong></li><li><strong>Menu</strong></li></ul><p>ProgressView用于显示任务的完成程度。有两种类型的ProgressView：不确定的进度视图显示一个旋转的圆圈直到任务完成，而确定的进度视图显示一个被填满的bar，以显示任务的完成程度。</p><p>ColorPicker视图允许用户从多种颜色中进行选择。</p><p>Menu视图则显示一个items列表，用户可以从中选择以执行特定操作。</p><h2>Getting ready</h2><p>新建一个SwiftUI项目，<strong>MoreViewsAndControls</strong></p><h2>How to do it…</h2><ol><li>首先，添加一些状态</li></ol><pre><code class="language-swift">@State private var progress = 0.5
@State private var color  = Color.red
@State private var secondColor  = Color.yellow
@State private var someText = &quot;Initial value&quot;
</code></pre><ol start="2"><li>添加一个List， 在添加一个包含ProgressView的Section</li></ol><pre><code class="language-swift">List {
    Section(header: Text(&quot;ProgressViews&quot;)) {
        ProgressView(&quot;Indeterminate progressview&quot;)
        ProgressView(&quot;Downloading&quot;,value:progress, total:2)
        Button(&quot;More&quot;){
            if(progress &lt; 2){
                progress += 0.5
            }
        }
    }
}
</code></pre><ol start="3"><li>再添加另一个Section</li></ol><pre><code class="language-swift">    Section(header: Text(&quot;Labels&quot;)) {
    Label(&quot;Slow&quot;, image: &quot;tortoise.fill&quot;)
    Label {
        Text(&quot;Fast&quot;).font(.title)
    } icon: {
        Circle()
            .fill(.orange)
            .frame(width: 40, height: 20, alignment: .center)
            .overlay {
                Text(&quot;F&quot;)
            }
    }
}
</code></pre><ol start="4"><li>在添加2个Section，包含<strong>ColorPicker</strong>和Link</li></ol><pre><code class="language-swift">Section(header: Text(&quot;ColorPicker&quot;)) {
    ColorPicker(selection: $color) {
        Text(&quot;Pick my background&quot;).background(color).padding()
    }
    ColorPicker(&quot;Picker&quot;, selection: $secondColor)
}
Section(header: Text(&quot;Link&quot;)) {
  Link(&quot;Packt Publishing&quot;, destination: URL(string: &quot;https://www.baidu.com&quot;)!)
}
</code></pre><ol start="5"><li>再添加一个Section，包含TextEditor</li></ol><pre><code class="language-swift">Section(header: Text(&quot;TextEditor&quot;)) {
    TextEditor(text: $someText)
    Text(&quot;current editortext:\n\(someText)&quot;)
}
</code></pre><ol start="6"><li>再添加一个Section，包含Menu</li></ol><pre><code class="language-swift">Section(header: Text(&quot;Menu&quot;)) {
    Menu(&quot;Actions&quot;) {
        Button(&quot;set TextEditor text to &#x27;magic&#x27;&quot;) {
            someText = &quot;magic&quot;
        }
        Button(&quot;turn first color green&quot;) {
            color = .green
        }
        Menu(&quot;Actions&quot;) {
            Button(&quot;set TextEditor text to &#x27;number&#x27;&quot;) {
                someText = &quot;number&quot;
            }
            Button(&quot;turn first color red&quot;) {
                color = .red
            }
        }
    }
}
</code></pre><ol start="7"><li>最终，我们修改下List的显示样式</li></ol><pre><code class="language-swift">List {

...

}.listStyle(.grouped)
</code></pre><p>最终</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxp0p1v15rj30i6100406.jpg" alt="image-20211224164647811"/></p><h2>How it works…</h2><p>不确定进度的进度条，不需要参数</p><pre><code class="language-swift">ProgressView(&quot;Indeterminate progress view&quot;)
ProgressView()
</code></pre><p>确定进度的，需要提供，当前进度和总进度, 总进度不传的话默认为1.</p><pre><code class="language-swift">ProgressView(&quot;Downloading&quot;,value: progress, total:2)
</code></pre><p>Label显示一个text和icon，我们可以使用SF symbol。</p><p>ColorPicker能够让用户选择颜色</p><p>Link用于显示一个可以点击的链接</p><p><strong>Menu</strong>提供了弹窗供用户选择选项，可以添加多级，但不建议嵌套太深。</p><h2>Api详情</h2><h3>ProgressView</h3><h4>Creating Progress View</h4><pre><code class="language-swift">//不确定进度的
init(label: () -&gt; Label)
//确定进度的
init&lt;V&gt;(value: V?, total: V = 1.0, label: () -&gt; Label) where CurrentValueLabel == EmptyView, V : BinaryFloatingPoint
//通过config初始化，通常用在自定义style中
init(_ configuration: ProgressViewStyleConfiguration) where Label == ProgressViewStyleConfiguration.Label, CurrentValueLabel == ProgressViewStyleConfiguration.CurrentValueLabel
//比如
struct DarkBlueShadowProgressViewStyle: ProgressViewStyle {
    func makeBody(configuration: Configuration) -&gt; some View {
        ProgressView(configuration)
            .shadow(color: Color(red: 0, green: 0, blue: 0.6),
                    radius: 4.0, x: 1.0, y: 2.0)
    }
}
</code></pre><h4>Styling Progress Views</h4><pre><code class="language-swift">func progressViewStyle&lt;S&gt;(_ style: S) -&gt; some View where S : ProgressViewStyle
//直线
static var linear: LinearProgressViewStyle { get }
//运行看效果似乎是和不确定进度的那种小菊花一样，看不到进度的改变
static var circular: CircularProgressViewStyle { get }
</code></pre><h3>Label</h3><h4>Creating a Label from Text and an Image</h4><pre><code class="language-swift">//title + 本地image
init&lt;S&gt;(_ title: S, image name: String) where S : StringProtocol
</code></pre><h4>Creating a Label from Text and an SF Symbol</h4><pre><code class="language-swift">//title + sf symbol
init&lt;S&gt;(_ title: S, systemImage name: String) where S : StringProtocol
</code></pre><h4>Creating a Label from a Title and Icon</h4><pre><code class="language-swift">//title + Icon
init(title: () -&gt; Title, icon: () -&gt; Icon)
</code></pre><h4>Creating a Label from a Configuration</h4><pre><code class="language-swift">init(_ configuration: LabelStyleConfiguration)
//比如
struct RedBorderedLabelStyle: LabelStyle {
    func makeBody(configuration: Configuration) -&gt; some View {
        Label(configuration)
            .border(Color.red)
    }
}
</code></pre><h4>Styling Labels</h4><pre><code class="language-swift">func labelStyle&lt;S&gt;(_ style: S) -&gt; some View where S : LabelStyle
//只显示图片
static var iconOnly: IconOnlyLabelStyle { get }
//title + icon
static var titleAndIcon: TitleAndIconLabelStyle { get }
//只显示title
static var titleOnly: TitleOnlyLabelStyle { get }
</code></pre><h3>Link</h3><pre><code class="language-swift">// 显示的title 和跳转的url
init(destination: URL, label: () -&gt; Label)
</code></pre><h3>Menu</h3><h4>Creating a Menu from Content</h4><pre><code class="language-swift">//点击后出现content中的选项
init(content: () -&gt; Content, label: () -&gt; Label)
</code></pre><h4>Creating a Menu with a Primary Action</h4><pre><code class="language-swift">//普通点击会触发primaryAction，如果长按或者双击则显示content中的选项
init(content: () -&gt; Content, label: () -&gt; Label, primaryAction: @escaping () -&gt; Void)
</code></pre><h4>Creating a Menu from a Configuration</h4><pre><code class="language-swift">init(_ configuration: MenuStyleConfiguration)
//比如
struct RedBorderMenuStyle: MenuStyle {
    func makeBody(configuration: Configuration) -&gt; some View {
        Menu(configuration)
            .border(Color.red)
    }
}
</code></pre><h4>Styling a Menu</h4><pre><code class="language-swift">func menuStyle&lt;S&gt;(_ style: S) -&gt; some View where S : MenuStyle
//默认的
struct DefaultMenuStyle
//无边框button
struct BorderlessButtonMenuStyle
//有边框，只能macOS用
struct BorderedButtonMenuStyle
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑010-已有App中使用SwiftUI]]></title>
            <link>https://gouxin.fun/2021/11/13/SwiftUI专辑-010-已有App中使用SwiftUI</link>
            <guid>/2021/11/13/SwiftUI专辑-010-已有App中使用SwiftUI</guid>
            <pubDate>Sat, 13 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本章，我们将学习如何从 UIKit 视图跳转到 SwiftUI 视图，同时将文本传递给我们的 SwiftUI 视图。</p><h2>Getting ready</h2><p>新建一个普通Storyboard工程。</p><h2>How to do it…</h2><ol><li>选中Main.stroyboard。</li><li>选中<strong>ViewController</strong></li><li>在菜单中选择 <strong>Editor</strong> | <strong>Embed in</strong> | <strong>Navigation Controller</strong>.</li><li>选择右上角的+号，添加一个<strong>Hosting View Controller</strong>到storyboard里</li><li>添加一个Button到ViewController中，添加点击btn跳转到HostingViewController</li><li>拖动segue到ViewController中，取名为gotoSwiftUI</li></ol><pre><code class="language-swift">    @IBSegueAction func gotoSwiftUI(_ coder: NSCoder) -&gt; UIViewController? {
        return UIHostingController(coder: coder, rootView: rootView)
    }

</code></pre><ol start="7"><li>添加import SwiftUI</li></ol><pre><code class="language-swift">import SwiftUI
</code></pre><ol start="8"><li>在gotoSwiftUI中创建rootView</li></ol><pre><code class="language-swift">@IBSegueAction func gotoSwiftUI(_ coder: NSCoder) -&gt; UIViewController? {
  let greetings = &quot;Hello From UIKit&quot;
    let rootView = Greetings(textFromUIKit:greetings)
  return UIHostingController(coder: coder, rootView: rootView)
}
</code></pre><ol start="9"><li>新建一个SwiftUI View, 取名<strong>Greetings</strong></li><li>实现Greetings</li></ol><pre><code class="language-swift">struct Greetings: View {
    var textFromUIKit = &quot;&quot;
    var body: some View {
        Text(textFromUIKit)
    }
}
</code></pre><p>最终，点击button，就能够跳转到Greetings，并显示传过去的参数
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxozv4r4xzg30940ixdgz.gif" alt="Untitled"/></p><h2>How it works…</h2><p>为了在普通项目中显示SwiftUI，你需要将SwiftUI视图包裹到一个<strong>ViewController</strong> 或者 <strong>InterfaceController</strong>中。</p><p>我们添加了<strong>UIHostingController</strong>作为SwiftUI的容器。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑009-SwiftUI中使用UIKit]]></title>
            <link>https://gouxin.fun/2021/11/12/SwiftUI专辑-009-SwiftUI中使用UIKit</link>
            <guid>/2021/11/12/SwiftUI专辑-009-SwiftUI中使用UIKit</guid>
            <pubDate>Fri, 12 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI 是 在 WWDC 2019 上宣布 的，仅适用于运行 iOS 13 及更高版本的设备。由于其相对不成熟，与 UIKit 相比，SwiftUI 可能缺乏广泛的 API 支持。例如，截至 2021 年 7 月，只能使用 UIKit 的<strong>UIImagePickerController</strong>选择图片和视频。因此，需要在 SwiftUI 中实现某些 UIKit API。</p><p>本章，我们将看看如何在 SwiftUI 中使用 UIKit API。我们将创建一个包装<strong>UIActivityIndicatorView</strong>的View，然后在 SwiftUI 中显示一个ActivityIndicator。</p><h2>Getting ready</h2><p>新建一个SwiftUI工程，叫做<strong>UIKitToSwiftUI</strong></p><h2>How to do it…</h2><p>我们能够通过<strong>UIViewRepresentable</strong>协议来在SwiftUI中显示UIKit View。</p><ol><li>新建文件，选择<code>Swift File</code>，命名<strong>ActivityIndicator</strong></li><li>替换<strong>import Foundation</strong>为<strong>import SwiftUI</strong></li></ol><pre><code class="language-swift">import SwiftUI
</code></pre><ol start="3"><li>修改<strong>ActivityIndicator</strong>遵循<strong>UIViewRepresentable</strong>协议</li></ol><pre><code class="language-swift">struct ActivityIndicator: UIViewRepresentable {
    var animating: Bool
    func updateUIView(_ activityIndicator: UIActivityIndicatorView, context: Context) {
        if self.animating {
            activityIndicator.startAnimating()
        } else {
            activityIndicator.stopAnimating()
        }
    }

    func makeUIView(context: Context) -&gt; UIActivityIndicatorView {
        return UIActivityIndicatorView()
    }
}
</code></pre><ol start="4"><li>打开ContentView.swift，使用我们刚刚的<strong>ActivityIndicator</strong></li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var animated = false
    var body: some View {
        VStack {
            ActivityIndicator(animating: animated)                
            HStack {
                Toggle(isOn: $animated) {
                    Text(&quot;Toggle Activity&quot;)
                }
            }
        }
    }
}
</code></pre><p>最终结果：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxoxubn99dj30eq0uaglt.jpg" alt="image-20211224150803446"/></p><h2>How it works…</h2><p>我们通过实现<strong>UIViewRepresentable</strong>协议来将UIKit View包裹为一个SwiftUI View。</p><p>在 <strong>ActivityIndicator.swift</strong> 文件中，我们实现了一个 struct， 遵循<strong>UIViewRepresentable</strong>协议。</p><p>协议要求我们实现 <strong>makeUIView</strong> 和 <strong>updateUIView</strong> 这两个函数。</p><p> <strong>makeUIView</strong> 负责创建和准备View</p><p> <strong>updateUIView</strong> 负责当animation改变时更新 <strong>UIView</strong>。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑008-使用SF Symbols显示简单图形]]></title>
            <link>https://gouxin.fun/2021/11/11/SwiftUI专辑-008-使用SFSymbols显示简单图形</link>
            <guid>/2021/11/11/SwiftUI专辑-008-使用SFSymbols显示简单图形</guid>
            <pubDate>Thu, 11 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SF Symbols提供了超过3200种Symbols。</p><p>你可以在官网下载macOS app：<a href="https://developer.apple.com/sf-symbols/">SF-Symbols-3.dmg</a>，然后再App上浏览各种SF symbols。</p><p>本章我们将在label和Image中使用SF symbols，并使用modifier来修改symbles。</p><h2>Getting ready</h2><p>首先，新建一个SwiftUI项目<strong>UsingSFSymbols</strong>。</p><h2>How to do it…</h2><ol><li>打开ContentView.swift，替换默认的Text为以下代码</li></ol><pre><code class="language-swift">VStack {
    HStack {
        Image(systemName: &quot;c&quot;)
        Image(systemName: &quot;o&quot;)
        Image(systemName: &quot;o&quot;)
        Image(systemName: &quot;k&quot;)
    }.symbolVariant(.circle.fill)
        .foregroundStyle(.yellow, .blue)
        .font(.title)
}
</code></pre><ol start="2"><li>再添加一个HStack</li></ol><pre><code class="language-swift">HStack {
    Image(systemName: &quot;b.circle.fill&quot;)
    Image(systemName: &quot;o.circle.fill&quot;).foregroundColor(.red)
    Image(systemName: &quot;o.circle.fill&quot;).imageScale(.large)
    Image(systemName: &quot;k.circle.fill&quot;).accessibilityIdentifier(&quot;letter k&quot;)
}.symbolVariant(.circle.fill)
    .foregroundColor(Color.blue)
    .font(.title)
    .padding()

</code></pre><ol start="3"><li>再添加一个HStack</li></ol><pre><code class="language-swift">HStack{
    Image(systemName: &quot;allergens&quot;)
    Image(systemName: &quot;ladybug&quot;)
}.symbolVariant(.fill)
    .symbolRenderingMode(.multicolor)
    .font(.largeTitle)
</code></pre><ol start="4"><li>最后，我们再添加一个Toggle</li></ol><pre><code class="language-swift">Toggle(isOn: $wifi_on) {
    Label(&quot;Wifi&quot;, systemImage: &quot;wifi&quot;)
}.foregroundStyle(wifi_on ? .blue : .secondary)
    .padding()
</code></pre><p>最终结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxos6im5lzj30e20tgdgd.jpg" alt="image-20211224115211366"/></p><h2>How it works…</h2><p>SF Symbols 定义了一些变体，比如<code>enclosed</code>,<code>fill</code>,<code>slash</code>。这些不同的变体能够传达不同的信息，比如Wi-Fi symbol 加上slash，能够表达wifi不可用。</p><p>在我们的第一个HStack中，我们使用了 <strong>.symbolVariant(.fill.circle)</strong> 来将 <strong>.fill</strong> 和 <strong>.circle</strong> 应用到HStack中的所有items上。这也能通过如下代码实现：</p><pre><code class="language-swift">HStack{         
    Image(systemName: &quot;c.circle.fill&quot;)
  Image(systemName: &quot;o.circle.fill &quot;)
  Image(systemName: &quot;o.circle.fill &quot;)
  Image(systemName: &quot;k.circle.fill &quot;)     
}
</code></pre><p>然而，这个代码不太灵活，我们可能只需要<strong>.circle</strong> 或者 <strong>.fill</strong> ，或者都不需要。</p><p>我们也注意到了 <strong>HStack</strong> 中的 .<strong>foregroundStyle(...)</strong> 。他能接受1个、2个或者3个参数，分别设置primary, secondary, 和 tertiary colors。有的symbols可能会同时包含这3种颜色，或者primary+secondary，或者primary+tertiary。</p><p>第二个HStack也有 <strong>.symbolVariant</strong> , 不过只有1个变体。同时我们看到了一个新的modifier: <strong>.symbolRenderingMode()</strong>。Rendering modes能够控制颜色如何应用到symbols上。multicolor rendering mode 将symbols渲染为多层样式。 添加 <strong>.multicolor</strong> rendering mode足够展示symbol的默认layer colors了。 其他的 rendering modes 有 <strong>hierarchical</strong>, <strong>monochrome</strong>, 和 <strong>palette</strong>。</p><p>最终, 我们创建了一个wifi toggle，我们可以根据wifi的状态来改变symbol的颜色。</p><h2>SymbolVariants</h2><p>来看看当前都有些什么SymbolVariants</p><pre><code class="language-swift">//没有Variant
static let none: SymbolVariants
//圆圈
static let circle: SymbolVariants
//正方形
static let square: SymbolVariants
//长方形
static let rectangle: SymbolVariants
//填充
static let fill: SymbolVariants
//斜线
static let slash: SymbolVariants
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxox68hj1kj30ro0hcmy0.jpg" alt="image-20211224144455426"/></p><pre><code class="language-swift">VStack(spacing: 20) {
    HStack(spacing: 20) {
        Image(systemName: &quot;flag&quot;)
        Image(systemName: &quot;heart&quot;)
        Image(systemName: &quot;bolt&quot;)
        Image(systemName: &quot;star&quot;)
    }
    HStack(spacing: 20) {
        Image(systemName: &quot;flag&quot;)
        Image(systemName: &quot;heart&quot;)
        Image(systemName: &quot;bolt&quot;)
        Image(systemName: &quot;star&quot;)
    }
    .symbolVariant(.circle)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxox6vslhjj30cc068glk.jpg" alt="image-20211224144532250"/></p><pre><code class="language-swift">VStack(spacing: 20) {
    HStack(spacing: 20) {
        Image(systemName: &quot;flag&quot;)
        Image(systemName: &quot;heart&quot;)
        Image(systemName: &quot;bolt&quot;)
        Image(systemName: &quot;star&quot;)
    }
    HStack(spacing: 20) {
        Image(systemName: &quot;flag&quot;)
        Image(systemName: &quot;heart&quot;)
        Image(systemName: &quot;bolt&quot;)
        Image(systemName: &quot;star&quot;)
    }
    .symbolVariant(.square)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxox7xnvpoj30ce06o3yg.jpg" alt="image-20211224144633286"/></p><pre><code class="language-swift">VStack(spacing: 20) {
    HStack(spacing: 20) {
        Image(systemName: &quot;plus&quot;)
        Image(systemName: &quot;minus&quot;)
        Image(systemName: &quot;xmark&quot;)
        Image(systemName: &quot;checkmark&quot;)
    }
    HStack(spacing: 20) {
        Image(systemName: &quot;plus&quot;)
        Image(systemName: &quot;minus&quot;)
        Image(systemName: &quot;xmark&quot;)
        Image(systemName: &quot;checkmark&quot;)
    }
    .symbolVariant(.rectangle)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxox8j77c0j30d6068t8m.jpg" alt="image-20211224144707529"/></p><pre><code class="language-swift">VStack(spacing: 20) {
    HStack(spacing: 20) {
        Image(systemName: &quot;flag&quot;)
        Image(systemName: &quot;heart&quot;)
        Image(systemName: &quot;bolt&quot;)
        Image(systemName: &quot;star&quot;)
    }
    HStack(spacing: 20) {
        Image(systemName: &quot;flag&quot;)
        Image(systemName: &quot;heart&quot;)
        Image(systemName: &quot;bolt&quot;)
        Image(systemName: &quot;star&quot;)
    }
    .symbolVariant(.fill)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxox9cavv8j30cc064t8m.jpg" alt="image-20211224144754740"/></p><pre><code class="language-swift">VStack(spacing: 20) {
    HStack(spacing: 20) {
        Image(systemName: &quot;flag&quot;)
        Image(systemName: &quot;heart&quot;)
        Image(systemName: &quot;bolt&quot;)
        Image(systemName: &quot;star&quot;)
    }
    HStack(spacing: 20) {
        Image(systemName: &quot;flag&quot;)
        Image(systemName: &quot;heart&quot;)
        Image(systemName: &quot;bolt&quot;)
        Image(systemName: &quot;star&quot;)
    }
    .symbolVariant(.slash)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxoxa340ljj30cw06swef.jpg" alt="image-20211224144836914"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑007-使用ViewBuilder来分离展示]]></title>
            <link>https://gouxin.fun/2021/11/10/SwiftUI专辑-007-使用ViewBuilder来分离展示</link>
            <guid>/2021/11/10/SwiftUI专辑-007-使用ViewBuilder来分离展示</guid>
            <pubDate>Wed, 10 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
Apple对ViewBuilder的定义是: 一个自定义参数, 能够从闭包中构建Views。</p><p>我们可以将公共View抽离出来，以ViewBuilder作为参数，来实现差异。</p><p>本章，我们将创建一个SwiftUI View：<strong>BlueCircle</strong>，它会在content的右边放置一个blue circle。</p><h2>Getting ready</h2><p>首先，创建一个SwiftUI工程：<strong>UsingViewBuilder</strong>。</p><h2>How to do it…</h2><ol><li>新建文件</li><li>选择SwiftUI View</li><li>取名<strong>BlueCircle</strong></li><li>删除<strong>BlueCircle_Previews</strong></li><li>添加代码</li></ol><pre><code class="language-swift">struct BlueCircle&lt;Content: View&gt;: View {
    let content: Content
    
    init(@ViewBuilder content: () -&gt; Content) {
        self.content = content()
    }
    
    var body: some View {
        HStack {
            content
            Spacer()
            Circle().fill(Color.blue).frame(width: 20, height: 30)
        }.padding()
    }
}
</code></pre><ol start="6"><li>打开ContentView，使用BlueCircle</li></ol><pre><code class="language-swift">struct ContentView: View {
    var body: some View {
        BlueCircle {
            Text(&quot;some text here&quot;)
            Rectangle().fill(Color.red).frame(width: 40, height: 40)
        }
        BlueCircle {
            Text(&quot;hello world&quot;)
        }
    }
}
</code></pre><p>最终得到结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxoqchw6tej30hi0z0q3f.jpg" alt="image-20211224104842400"/></p><h2>ViewBuilder</h2><pre><code class="language-swift">@resultBuilder struct ViewBuilder
static func buildBlock&lt;Content&gt;(_ content: Content) -&gt; Content where Content : View
static func buildBlock&lt;C0, C1&gt;(_ c0: C0, _ c1: C1) -&gt; TupleView&lt;(C0, C1)&gt; where C0 : View, C1 : View
....
//我们可以看到ViewBuilder支持的最大参数为C0到C9,总共10个View
//这也是为什么当我们添加超过10个子View后会报错的原因，此时我们需要用Group来减少直接子View的数量
static func buildBlock&lt;C0, C1, C2, C3, C4, C5, C6, C7, C8, C9&gt;(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -&gt; TupleView&lt;(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)&gt; where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View, C6 : View, C7 : View, C8 : View, C9 : View
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑006-自定义ViewModifier]]></title>
            <link>https://gouxin.fun/2021/11/09/SwiftUI专辑-006-自定义ViewModifier</link>
            <guid>/2021/11/09/SwiftUI专辑-006-自定义ViewModifier</guid>
            <pubDate>Tue, 09 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
SwiftUI为你提供了自定义modifiers的能力。
你可以使用自定义modifiers将多个modifiers合成一个。
本章我们将创建一个自定义modifier，他能够为TextView添加圆角和背景。</p><h2>Getting ready</h2><p>新建一个SwiftUI工程<strong>UsingViewModifiers</strong>。</p><h2>How to do it…</h2><ol><li>修改<strong>ContentView</strong>中的text为<strong>Perfect</strong>。</li></ol><pre><code class="language-swift">Text(&quot;Perfect&quot;)
</code></pre><ol start="2"><li>在<strong>ContentView.swift</strong>中，新建一个struct，遵循<strong>ViewModifier</strong>，接受一个参数<strong>Color</strong>。</li></ol><pre><code class="language-swift">struct BackgroundStyle: ViewModifier {
    var bgColor: Color
    func body(content: Content) -&gt; some View{
        content
        .frame(width:UIScreen.main.bounds.width * 0.3)
        .foregroundColor(Color.black)
        .padding()
        .background(bgColor)
        .cornerRadius(CGFloat(20))
    }
}
</code></pre><ol start="3"><li>为Text添加一个<strong>modifier</strong>。</li></ol><pre><code class="language-swift">Text(&quot;Perfect&quot;).modifier(BackgroundStyle(bgColor:.blue))
</code></pre><ol start="4"><li>当然，如果你不想用<strong>modifier</strong>, 可以添加一个extension。</li></ol><pre><code class="language-swift">extension View {
    func backgroundStyle(color: Color) -&gt; some View{
        self.modifier(BackgroundStyle(bgColor: color))
    }
}
</code></pre><ol start="5"><li>将我们的modifier修改为刚刚的extension</li></ol><pre><code class="language-swift">Text(&quot;Perfect&quot;).backgroundStyle(color: Color.red)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxo31sxp0vj30fg0v80t3.jpg" alt="image-20211223212239097"/></p><h2>How it works…</h2><p>一个 <strong>ViewModifier</strong>通过修改原来修饰的View来创建一个新的View  。</p><p>通过通过遵循ViewModifier协议来创建一个自定义modifier。</p><p>通过.modifier()来应用我们自定义的modifier。</p><p>通过extension来添加更方便的Api。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑005-各种pickers]]></title>
            <link>https://gouxin.fun/2021/11/08/SwiftUI专辑-005-各种pickers</link>
            <guid>/2021/11/08/SwiftUI专辑-005-各种pickers</guid>
            <pubDate>Mon, 08 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
pickers是用来提供给用户选择某个值的。
本文将介绍以下的pickers</p><ul><li><strong>Picker</strong></li><li><strong>Toggle</strong></li><li><strong>Slider</strong></li><li><strong>Stepper</strong></li><li><strong>DatePicker</strong></li><li><strong>ColorPicker</strong></li></ul><h2>Getting ready</h2><p>首先，新建一个SwiftUI工程，叫做<strong>PickersApp</strong>。</p><h2>How to do it…</h2><ol><li>在<strong>ContentView.swift</strong>创建好State，以绑定各个pickers的value。</li></ol><pre><code class="language-swift">@State var choice = 0
@State var showText = false
@State var transitModes = [&quot;Bike&quot;, &quot;Car&quot;, &quot;Bus&quot;]
@State var sliderVal: Float = 0
@State var stepVal = 0
@State var gameTime = Date()
</code></pre><ol start="2"><li>在Body中加入一个<code>Form</code>、<code>Section</code>、<code>Picker</code>。</li></ol><pre><code class="language-swift">struct ContentView: View {
    @State var choice = 0
    @State var showText = false
    @State var transitModes = [&quot;Bike&quot;, &quot;Car&quot;, &quot;Bus&quot;]
    @State var sliderVal: Float = 0
    @State var stepVal = 0
    @State var gameTime = Date()
    
    var body: some View {
        Form {
            Section {
                Picker(&quot;Transit Modes&quot;, selection: $choice) {
                    ForEach(0..&lt;transitModes.count) { index in
                        Text(&quot;\(self.transitModes[index])&quot;)
                    }
                }.pickerStyle(.segmented)
                Text(&quot;Current choice: \(self.transitModes[choice])&quot;)
            }
        }
    }
}
</code></pre><ol start="3"><li>再添加一个section，加入<code>Toggle</code></li></ol><pre><code class="language-swift">Section {
    Toggle(isOn: $showText) {
        Text(&quot;Show Text&quot;)
    }
    if showText {
        Text(&quot;The Text toggle is on&quot;)
    }
}
</code></pre><ol start="4"><li>再添加一个section，加入<code>Slider</code></li></ol><pre><code class="language-swift">Section {
    Slider(value: $sliderVal, in: 0...10, step: 0.001)
    Text(&quot;Slider current value\(sliderVal, specifier: &quot;%.1f&quot;)&quot;)
}
</code></pre><ol start="5"><li>再添加一个section，加入<code>Stepper</code></li></ol><pre><code class="language-swift">Section {
    Stepper(&quot;Stepper&quot;, value: $stepVal, in: 0...5)
    Text(&quot;Stepper current value\(stepVal)&quot;)
}
</code></pre><ol start="6"><li>再添加一个section，加入<code>DatePicker</code></li></ol><pre><code class="language-swift"> Section {
    DatePicker(&quot;Please select a date&quot;, selection: $gameTime)
}
</code></pre><ol start="7"><li>再添加一个section，加入<code>DatePicker</code>,再限制下时间范围</li></ol><pre><code class="language-swift">Section {
  DatePicker(&quot;select a date&quot;, selection: $gameTime, in: Date()...)
}
</code></pre><p>最终如下</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnlz3hh9zj30i80xuaba.jpg" alt="image-20211223113151810"/></p><h2>How it works…</h2><p><code>Picker</code>是用来从一组值中选择某一个的，设置style为Segmented就得到了一个UIKit的SegmentView。</p><p><code>Toggle</code>控制开和关，当前状态存储在binding的vlaue中。</p><p><code>Slider</code>需要3个参数: </p><ul><li><strong>value</strong>: 当前值</li><li><strong>in</strong>： slider的范围</li><li><strong>step</strong>： 步进的值</li></ul><p><code>Stepper</code>也同Slider一样需要那3个参数。</p><p>最后演示了一下DatePicker的使用，注意binding的类型是date。</p><blockquote><p>picker的style会根据他的容器不同而不同。比如在Form或者List中的picker会和在VStack中的不一样。</p><p>我们可以通过<code>.pickerStyle</code>来修改默认style。</p></blockquote><h2>Api详情</h2><h3>Picker</h3><h4>Creating a Picker</h4><pre><code class="language-swift">///SelectionValue遵循Hashable， Content和Label都遵循View
init(selection: Binding&lt;SelectionValue&gt;, content: () -&gt; Content, label: () -&gt; Label)
</code></pre><blockquote><p>注意Picker的每个选项都需要带上tag，而且tag的值和类型要和Binding的变量一样。</p></blockquote><pre><code class="language-swift">enum Flavor: String, CaseIterable {
    case chocolate
    case vanilla
    case strawberry
}
struct ContentView: View {
    @State var selectedFlavor: Flavor = .chocolate
    var body: some View {
        Form {
            Section {
                Picker(&quot;Flaver&quot;, selection: $selectedFlavor) {
                   //注意需要标上tag，而且类型需要和Binding的一样
                    Text(&quot;\(Flavor.chocolate.rawValue)&quot;).tag(Flavor.chocolate)
                    Text(&quot;\(Flavor.vanilla.rawValue)&quot;).tag(Flavor.vanilla)
                    Text(&quot;\(Flavor.strawberry.rawValue)&quot;).tag(Flavor.strawberry)
                }.pickerStyle(.segmented)
                Text(&quot;Current Flaver: \(selectedFlavor.rawValue)&quot;)
            }    
        }
    }
}
</code></pre><p>可能有人就有疑问了，为什么在<code>how to do</code>那里的Picker的例子就没有打tag呢？</p><p>因为ForEach会自动为你打tag，这个tag的值是遵循了<code>Identifiable</code>协议的对象的id字段。所以之前的那个例子不用显示的带上tag。如果我们要改写上面的例子用ForEach实现呢？</p><pre><code class="language-swift">///遵循Identifiable协议
enum Flavor: String, CaseIterable, Identifiable {
    case chocolate
    case vanilla
    case strawberry
    var id: Flavor { self }
}
struct ContentView: View {
    @State var selectedFlavor: Flavor = .chocolate
    var body: some View {
        Form {
            Section {
                Picker(&quot;Flaver&quot;, selection: $selectedFlavor) {
                    // 不用显示的打tag，默认用id作为tag，id和Binding都是Flavor类型的
                    // 当然，如果你愿意，也可以自己显示的指定tag
                                        ForEach(Flavor.allCases) { flavor in
                        Text(&quot;\(flavor.rawValue)&quot;)
                    }
                }.pickerStyle(.segmented)
                Text(&quot;Current Flaver: \(selectedFlavor.rawValue)&quot;)
            }    
        }
    }
}
</code></pre><h4>Styling Pickers</h4><pre><code class="language-swift">/// 设置picker的样式
func pickerStyle&lt;S&gt;(_ style: S) -&gt; some View where S : PickerStyle
</code></pre><pre><code class="language-swift">//segment样式
static var segmented: SegmentedPickerStyle { get }
</code></pre><pre><code class="language-swift">//类似于UIPicker的那种滚轮样式
static var wheel: WheelPickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnr4e090vj30ge0cowek.jpg" alt="image-20211223142959083"/></p><pre><code class="language-swift">//macOS上的勾选样式
static var radioGroup: RadioGroupPickerStyle { get }
</code></pre><pre><code class="language-swift">//菜单，类似于UIPopoverController，点了出现小弹窗，包含所有选项
static var menu: MenuPickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnr2qhu8rj30hs0am74h.jpg" alt="image-20211223142823304"/></p><pre><code class="language-swift">//所有选项都同时显示出来，
static var inline: InlinePickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnr1g1v55j30hi0aw74g.jpg" alt="image-20211223142709578"/></p><h3>Toggle</h3><h4>Creating a Toggle</h4><pre><code class="language-swift">init(isOn: Binding&lt;Bool&gt;, label: () -&gt; Label)
...
</code></pre><h4>Creating a Toggle from a Configuration</h4><pre><code class="language-swift">//通常用在自定义ToggleStyle中
init(_ configuration: ToggleStyleConfiguration)
</code></pre><p>举个例子</p><pre><code class="language-swift">struct RedBorderToggleStyle: ToggleStyle {
    func makeBody(configuration: Configuration) -&gt; some View {
        Toggle(configuration)//通过cinfiguration初始化
            .padding()
            .border(Color.red)
    }
}

Toggle(isOn: $showText) {
      Text(&quot;Show Text&quot;)
}.toggleStyle(RedBorderToggleStyle())
</code></pre><h4>Styling a Toggle</h4><pre><code class="language-swift">func toggleStyle&lt;S&gt;(_ style: S) -&gt; some View where S : ToggleStyle
</code></pre><p>下面是一些默认的style</p><pre><code class="language-swift">/// switch样式
static var `switch`: SwitchToggleStyle { get }
</code></pre><pre><code class="language-swift">/// label作为btn, on的时候，背景设为tintColor
static var button: ButtonToggleStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnrhzplnnj30ps0fcgm1.jpg" alt="image-20211223144303808"/></p><pre><code class="language-swift">/// 勾选框，只有macOS有
static var checkbox: CheckboxToggleStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnrj91cugj30ho04i749.jpg" alt="image-20211223144416027"/></p><h3>Slider</h3><pre><code class="language-swift">/**
value : binding的值
bounds: 值的范围
step: 步进的大小
label: 描述的view
minimumValueLabel
maximumValueLabel最大和最小端的view
*/
init&lt;V&gt;(value: Binding&lt;V&gt;, in bounds: ClosedRange&lt;V&gt;, step: V.Stride = 1, label: () -&gt; Label, minimumValueLabel: () -&gt; ValueLabel, maximumValueLabel: () -&gt; ValueLabel, onEditingChanged: @escaping (Bool) -&gt; Void = { _ in }) where V : BinaryFloatingPoint, V.Stride : BinaryFloatingPoint
</code></pre><h3>Stepper</h3><h4>Creating a Stepper</h4><pre><code class="language-swift">/**
value : binding的值
bounds: 值的范围
step: 步进的大小
label: 描述的view
*/
init&lt;V&gt;(value: Binding&lt;V&gt;, in bounds: ClosedRange&lt;V&gt;, step: V.Stride = 1, label: () -&gt; Label, onEditingChanged: @escaping (Bool) -&gt; Void = { _ in }) where V : Strideable
</code></pre><h4>Creating a Stepper with Specified Increment and Decrement Behavior</h4><pre><code class="language-swift">// 不在和某个value绑定，将两个按钮的事件暴露出来，提供给你自定义你的逻辑
init(label: () -&gt; Label, onIncrement: (() -&gt; Void)?, onDecrement: (() -&gt; Void)?, onEditingChanged: @escaping (Bool) -&gt; Void = { _ in })
</code></pre><h3>DatePicker</h3><h4>Creating a Date Picker</h4><pre><code class="language-swift">init(selection: Binding&lt;Date&gt;, displayedComponents: DatePicker&lt;Label&gt;.Components = [.hourAndMinute, .date], label: () -&gt; Label)
/// 可以指定range, start...end
init(selection: Binding&lt;Date&gt;, in range: ClosedRange&lt;Date&gt;, displayedComponents: DatePicker&lt;Label&gt;.Components = [.hourAndMinute, .date], label: () -&gt; Label)
/// 可以指定range, start...
init(selection: Binding&lt;Date&gt;, in range: PartialRangeFrom&lt;Date&gt;, displayedComponents: DatePicker&lt;Label&gt;.Components = [.hourAndMinute, .date], label: () -&gt; Label)
/// 可以指定range, ...end
init(selection: Binding&lt;Date&gt;, in range: PartialRangeThrough&lt;Date&gt;, displayedComponents: DatePicker&lt;Label&gt;.Components = [.hourAndMinute, .date], label: () -&gt; Label)
</code></pre><h4>Setting Date Picker Components</h4><pre><code class="language-swift">//设置显示的components
static let date: DatePickerComponents// 年月日
static let hourAndMinute: DatePickerComponents//小时，分钟
</code></pre><h4>Styling Date Pickers</h4><pre><code class="language-swift">///设置picker样式
func datePickerStyle&lt;S&gt;(_ style: S) -&gt; some View where S : DatePickerStyle
</code></pre><pre><code class="language-swift">static var wheel: WheelDatePickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnss4kk3mj30ga0ce74g.jpg" alt="image-20211223152724050"/></p><pre><code class="language-swift">/// macOS上特有的，类似于Stepper
static var stepperField: StepperFieldDatePickerStyle { get }
/// macOS上特有的
static var field: FieldDatePickerStyle { get }
</code></pre><pre><code class="language-swift">static var graphical: GraphicalDatePickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnstx1k4wj30h00hoaak.jpg" alt="image-20211223152907356"/></p><pre><code class="language-swift">///component以文本格式显示
static var compact: CompactDatePickerStyle { get }
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnsx112spj30gu04y3yg.jpg" alt="image-20211223153206130"/></p><h3>ColorPicker</h3><p>选择颜色</p><pre><code class="language-swift">///绑定Color
init(selection: Binding&lt;Color&gt;, supportsOpacity: Bool = true, label: () -&gt; Label)
///绑定CGColor
init(selection: Binding&lt;CGColor&gt;, supportsOpacity: Bool = true, label: () -&gt; Label)
</code></pre><pre><code class="language-swift">ColorPicker(selection: $color) {
    Text(&quot;选择颜色&quot;)
}
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxnt5817uvj30gm03cwec.jpg" alt="image-20211223153959117"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑004-Button以及跳转]]></title>
            <link>https://gouxin.fun/2021/11/07/SwiftUI专辑-004-Button以及跳转</link>
            <guid>/2021/11/07/SwiftUI专辑-004-Button以及跳转</guid>
            <pubDate>Sun, 07 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本章将介绍如何使用各种Button和如何跳转。</p><ul><li>Button</li><li>EditButton</li><li>PasteButton</li><li>NavigationView</li><li>NavigationLink</li></ul><h2>Getting ready</h2><p>首先，新建一个<strong>ButtonsApp</strong>的SwiftUI工程。</p><h2>How to do it…</h2><ol><li>新建文件</li><li>模板选择<strong>SwiftUI View</strong></li><li>输入名称<strong>ButtonView</strong></li><li>重复上面步骤，创建<strong>EditButtonView</strong></li><li>重复上面步骤，创建<strong>PasteButtonView</strong></li><li>重复上面步骤，创建<strong>MenuButtonView</strong>，(<strong>MenuButton</strong>已经弃用了，使用<strong>Menu</strong>)</li><li>打开<strong>ContentView.swift</strong>，在body中添加一个<strong>NavigationView</strong></li></ol><pre><code class="language-swift">NavigationView {
    VStack {
        NavigationLink(destination: ButtonView()) {
            Text(&quot;Buttons&quot;).padding()
        }
        NavigationLink(destination: EditButtonView()) {
            Text(&quot;EditButtons&quot;).padding()
        }
        NavigationLink(destination: MenuButtonView()) {
            Text(&quot;MenuButtons&quot;).padding()
        }
        NavigationLink(destination: PasteButtonView()) {
            Text(&quot;PasteButtons&quot;).padding()
        }
        NavigationLink(destination:
            Text(&quot;Very long text that should not be displayed in a single line because it is not good design&quot;)
                .padding()
                .navigationBarTitle(Text(&quot;Detail&quot;))
        ) {
            Text(&quot;details about text&quot;).padding()
        }
}.navigationBarTitle(Text(&quot;Main View&quot;), displayMode:.inline)

</code></pre><p>最终显示如下：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxmozc7y7pj30ci0oyjrs.jpg" alt="image-20211222163022220"/></p><ol start="8"><li>打开<strong>EditButtonView.swift</strong>，添加下面的代码，实现<strong>EditButton</strong>。</li></ol><pre><code class="language-swift">struct EditButtonView: View {
    @State private var animals = [&quot;Cats&quot;, &quot;Dogs&quot;, &quot;Goats&quot;]
    var body: some View {
        NavigationView {
            List {
                ForEach(animals, id: \.self) { animal in
                    Text(animal)
                }.onDelete(perform: removeAnimal)
            }
        }.navigationBarItems(trailing: EditButton())
        .navigationBarTitle(Text(&quot;EditButtonView&quot;), displayMode: .inline)
    }
    
    func removeAnimal(at offsets: IndexSet){
        animals.remove(atOffsets: offsets)
    }
}
</code></pre><p>最终得到，点击右上角的Edit按钮，List会进入编辑状态。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxmpcje8g3j305k0bedfr.jpg" alt="20211222164221"/></p><ol start="9"><li>打开<strong>MenuButtonView.swift</strong>， 添加以下代码</li></ol><pre><code class="language-swift">var body: some View {
    Text(&quot;MenuButtons are currently available on MacOS currently&quot;)
  .padding()
  .navigationBarTitle(&quot;MenuButtons&quot;, displayMode:.inline)

/*
MenuButton(&quot;country +&quot;) {
Button(&quot;USA&quot;) { print(&quot;Selected USA&quot;) }.background(Color.accentColor)
Button(&quot;India&quot;) { print(&quot;Selected India&quot;) }
}
*/
}

</code></pre><ol start="10"><li>打开<strong>PasteButtonView.swift</strong>，添加以下代码</li></ol><pre><code class="language-swift">struct PasteButtonView: View {
    var body: some View {
        VStack {
            Text(&quot;PasteButton controls how you paste in macOS but is not available in iOS. For more information, check the \&quot;See also\&quot; section of this recipe&quot;)
                .padding()
        }.navigationBarTitle(&quot;PasteButton&quot;, displayMode: .inline)
    }
}
</code></pre><h2>How it works…</h2><p><strong>NavigationLink</strong>必须放在<strong>NavigationView</strong>里使用。</p><p> <strong>NavigationLink</strong> 需要两个参数<strong>destination</strong> 和 <strong>label</strong>。<strong>destination</strong>代表点击后跳转的View。<strong>label</strong>代表显示的内容。</p><p><code>.navigationBarTitle</code>modifier给ContentView界面添加了个title。第一个参数指定title的内容，第二个参数指定title显示的模式。.inline代表在标准的navigationBar中显示。</p><p>其他几个界面也有指定<code>.navigationBarTitle</code>，但是在preview中不会显示，在运行时才会显示。</p><p><strong>EditButton</strong>和<strong>List</strong>一起使用，让List可编辑。我们之后再学习List。</p><p><strong>MenuButtons</strong>和<strong>PasteButtons</strong>只能在macOS中使用。MenuButtons已被弃用，可以不用看了。</p><p>PasteButton可参考官方文档中的例子。</p><h2>API详情</h2><h3>Button</h3><h4>Creating a Button</h4><pre><code class="language-swift">// action是点击时触发的方法， label控制显示内容
init(action: @escaping () -&gt; Void, label: () -&gt; Label)
init(_ titleKey: LocalizedStringKey, action: @escaping () -&gt; Void)
</code></pre><h4>Creating a Button with a Role</h4><pre><code class="language-swift">//多了个ButtonRole，用于描述Button语意，SwiftUI会根据语意添加样式，比如取消，是红色的。
init(role: ButtonRole?, action: @escaping () -&gt; Void, label: () -&gt; Label)
</code></pre><h4>Creating a Button from a Configuration</h4><pre><code class="language-swift">///通过config初始化
init(_ configuration: PrimitiveButtonStyleConfiguration)
</code></pre><h4>Setting a Border Shape</h4><pre><code class="language-swift">///设置border样式，
// capsule : 胶囊形状，  rounded rectangle： 圆角矩形，可自定义圆角大小
func buttonBorderShape(_ shape: ButtonBorderShape) -&gt; some View
</code></pre><h4>Styling Button Appearance</h4><pre><code class="language-swift">/// 设置样式，创建自定义样式
func buttonStyle&lt;S&gt;(_ style: S) -&gt; some View where S : ButtonStyle
</code></pre><p>举个例子</p><pre><code class="language-swift">struct RedborderStyle: PrimitiveButtonStyle {
    func makeBody(configuration: Configuration) -&gt; some View {
        configuration.label.padding().border(Color.red)
    }
}

struct ButtonView: View {
    var body: some View {
        Button(&quot;你好&quot;) {
            print(&quot;hello&quot;)
        }.buttonStyle(RedborderStyle())
    }
}
</code></pre><h3>NavigationView</h3><p>用于创建类似于UINavigationController的导航。</p><h4>Creating a Navigation View</h4><pre><code class="language-swift">init(content: () -&gt; Content)
</code></pre><h4>Styling Navigation Views</h4><pre><code class="language-swift">func navigationViewStyle&lt;S&gt;(_ style: S) -&gt; some View where S : NavigationViewStyle
</code></pre><h4>Adding Titles</h4><pre><code class="language-swift">//导航栏标题
func navigationTitle(_ titleKey: LocalizedStringKey) -&gt; some View
//subtitle，只有macOS才有
func navigationSubtitle&lt;S&gt;(_ subtitle: S) -&gt; some View where S : StringProtocol
...
</code></pre><h4>Managing Navigation Bars</h4><pre><code class="language-swift">//隐藏navigationbar
func navigationBarHidden(_ hidden: Bool) -&gt; some View
func navigationBarBackButtonHidden(_ hidesBackButton: Bool) -&gt; some View
///显示模式，inline: 正常大小导航栏居中， large：大的导航栏，居左
func navigationBarTitleDisplayMode(_ displayMode: NavigationBarItem.TitleDisplayMode) -&gt; some View
</code></pre><h3>NavigationLink</h3><p>控制navigation跳转的view。点击后会跳转到destination。当然除了，手动触发，也能够通过代码触发跳转。代码跳转有两种方式，一种是通过isActive，一种是通过tag+selection。</p><h4>Presenting a Destination View</h4><pre><code class="language-swift">init(destination: () -&gt; Destination, label: () -&gt; Label)
init&lt;S&gt;(_ title: S, destination: () -&gt; Destination) where S : StringProtocol
</code></pre><h4>Presenting a Destination View with Programmatic Activation</h4><pre><code class="language-swift">///提供isActive，这样可以通过代码来跳转
init&lt;S&gt;(_ title: S, isActive: Binding&lt;Bool&gt;, destination: () -&gt; Destination) where S : StringProtocol
...
</code></pre><p>举个例子, 下面的点击两个按钮都能跳转到对应View。</p><pre><code class="language-swift">struct ContentView: View {
    @State var showEditBtnScreen = false
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: EditButtonView(), isActive: $showEditBtnScreen) {
                    Text(&quot;EditButtons&quot;).padding()
                }
                Button(&quot;设置active跳转&quot;) {
                    showEditBtnScreen = true
                }
            }.navigationBarTitle(Text(&quot;Main View&quot;), displayMode: .inline)
        }
    }
}
</code></pre><h4>Presenting a Selectable Destination View</h4><pre><code class="language-swift">///通过给每个Link一个tag，然后通过设置selection为对应tag，控制跳转
init&lt;S, V&gt;(_ title: S, tag: V, selection: Binding&lt;V?&gt;, destination: () -&gt; Destination) where S : StringProtocol, V : Hashable
...
</code></pre><p>举个例子</p><pre><code class="language-swift">struct ContentView: View {
    enum Screens {
        case editButtonScreen
        case memuButtonScreen
    }    
    @State var currentScreen: Screens?
    var body: some View {
        NavigationView {
            VStack {
                NavigationLink(destination: EditButtonView(), tag: Screens.editButtonScreen, selection: $currentScreen) {
                    Text(&quot;EditButtons&quot;).padding()
                }
                NavigationLink(destination: MenuButtonView(), tag: Screens.memuButtonScreen, selection: $currentScreen) {
                    Text(&quot;MenuButtons&quot;).padding()
                }
                Button(&quot;设置selection跳转&quot;) {
                    currentScreen = .memuButtonScreen
                }
            }.navigationBarTitle(Text(&quot;Main View&quot;), displayMode: .inline)
        }
    }
}
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑003-使用Image]]></title>
            <link>https://gouxin.fun/2021/11/06/SwiftUI专辑-003-使用Image</link>
            <guid>/2021/11/06/SwiftUI专辑-003-使用Image</guid>
            <pubDate>Sat, 06 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
这一章，我们将介绍如何添加Image到View中。</p><h2>Getting ready</h2><p>新建一个SwiftUI工程，叫做<strong>ImageApp</strong></p><h2>How to do it…</h2><p>首先让我们添加一些图片到Assert中，然后我们再介绍一些modifier来修改图片样式。</p><ol><li>替换Text为VStack</li><li>从<a href="https://github.com/PacktPublishing/SwiftUI-Cookbook-2nd-Edition/tree/main/Resources/Chapter01/recipe3%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87">https://github.com/PacktPublishing/SwiftUI-Cookbook-2nd-Edition/tree/main/Resources/Chapter01/recipe3下载图片</a></li><li>拖动图片到Asserts中</li><li>添加一个<code>Image</code>到<code>VStack中</code></li></ol><pre><code class="language-swift">Image(&quot;dogs1&quot;)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlubi8eadj30d40ou3zy.jpg" alt="image-20211221224926711"/></p><ol start="5"><li>添加一个<code>.resizable()</code>modifier, 他能让SwiftUI调整图片大小以适应可以用空间。</li></ol><pre><code class="language-swift">Image(&quot;dogs1&quot;)
.resizable()
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlucuqitnj30cy0ootae.jpg" alt="image-20211221225044534"/></p><ol start="6"><li>我们看到图片被压缩了，继续添加一个<code>.aspectRatio</code></li></ol><pre><code class="language-swift">Image(&quot;dogs1&quot;)
    .resizable()
    .aspectRatio(contentMode: .fit)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlufwjo2cj30cc0o8dgm.jpg" alt="image-20211221225341902"/></p><ol start="7"><li>继续添加 <strong>dog-and-nature</strong>到<code>VStack</code>中</li></ol><pre><code class="language-swift">Image(&quot;dog-and-nature&quot;)
    .resizable()
    .aspectRatio(contentMode: .fit)
    .frame(width:300, height:200)
    .clipShape(Circle())
    .overlay(Circle().stroke(Color.blue, lineWidth: 6))
    .shadow(radius: 10)
</code></pre><ol start="8"><li>我们写个工具方法来获取UIImage</li></ol><pre><code class="language-swift">func getImageFromUIImage(image:String) -&gt; UIImage {
    guard let img = UIImage(named: image) else {
        fatalError(&quot;Unable to load image&quot;)
    }
    return img
}
</code></pre><ol start="9"><li>然后使用UIImage来加载图片</li></ol><pre><code class="language-swift">Image(uiImage: getImageFromUIImage(image:&quot;dog2&quot;))
    .resizable()
    .frame(width: 200, height: 200)
    .aspectRatio(contentMode: .fit)
</code></pre><ol start="10"><li>最终效果</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlumbs7t0j30cq0pa0u9.jpg" alt="image-20211221225942417"/></p><h2>How it works…</h2><p>添加<code>Image</code>到View上时，<code>Image</code>默认显示原始尺寸。图片可能大了，也可能小了。</p><p>要让<code>Image</code>适应屏幕大小，我们需要添加<code>.resizable</code>modifier。这会让<code>Image</code>缩放以占满可用空间。</p><p>为了解决缩放的拉伸问题，我们可以使用<code>.aspectRatio</code>modifier。</p><p>但aspectFill时，图片可能超出范围，我们可以用<code>.clip()</code>裁减掉</p><p>如果我们要限制图片大小固定为某个值，可以使用<code>.frame</code>modifier。</p><p>如果想裁剪图片为某个形状，可以使用<code>.clipShape</code>modifier。</p><p>我们还可以使用<code>.overlay</code>和<code>.shadow</code>来添加边框和阴影。</p><p>注意modifer的顺序比较重要，不同顺序的组合可能得到不一样的结果。</p><h2>Image</h2><p>我们可以中资源中创建Image</p><ul><li>从bundle中的资源文件创建</li><li>从UIImage/NSImage创建</li><li>从CGImage创建</li><li>从SF Symbols创建</li></ul><h3>Creating an Image</h3><pre><code class="language-swift">//通过name初始化，bundle为nil默认为main bundle
init(_ name: String, bundle: Bundle? = nil)

</code></pre><h3>Creating an Image for Use as a Control</h3><pre><code class="language-swift">//和上面的类似， label用作accessibility
init(_ name: String, bundle: Bundle? = nil, label: Text)
init(_ cgImage: CGImage, scale: CGFloat, orientation: Image.Orientation = .up, label: Text)
</code></pre><h3>Creating an Image for Decorative Use</h3><pre><code class="language-swift">///创建装饰性的image，不会有accessibility
init(decorative name: String, bundle: Bundle? = nil)
init(decorative cgImage: CGImage, scale: CGFloat, orientation: Image.Orientation = .up)
</code></pre><h3>Creating a System Symbol Image</h3><pre><code class="language-swift">init(systemName: String)
</code></pre><h3>Creating an Image from a System Representation</h3><pre><code class="language-swift">///通过平台对应的Image初始化
init(uiImage: UIImage)
init(nsImage: NSImage)
</code></pre><h3>Resizing and Scaling Images</h3><pre><code class="language-swift">/// 拉伸，EdgeInsets中间的区域不拉伸，四周拉伸，ResizingMode制定了拉伸方式
func resizable(capInsets: EdgeInsets = EdgeInsets(), resizingMode: Image.ResizingMode = .stretch) -&gt; Image
</code></pre><h3>Specifying Image Rendering Behavior</h3><pre><code class="language-swift">///设置symble image的render方式
func symbolRenderingMode(_ mode: SymbolRenderingMode?) -&gt; Image
//两种mode: original:图片本色 temple: 将所有不透明的颜色渲染为forgroundColor。
func renderingMode(_ renderingMode: Image.TemplateRenderingMode?) -&gt; Image
///渲染那种需要插值的图片，指定插值质量
func interpolation(_ interpolation: Image.Interpolation) -&gt; Image
///是否开启反锯齿
func antialiased(_ isAntialiased: Bool) -&gt; Image
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlvhx2yyuj30yq0jqwgq.jpg" alt="image-20211221233014594"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑002-处理文本]]></title>
            <link>https://gouxin.fun/2021/11/05/SwiftUI专辑-002-处理文本</link>
            <guid>/2021/11/05/SwiftUI专辑-002-处理文本</guid>
            <pubDate>Fri, 05 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
文本是任何App的一个基础。
本章我们将介绍：</p><ul><li><strong>Text</strong></li><li><strong>TextField</strong></li><li><strong>SecureField</strong></li><li><strong>TextEditor</strong></li></ul><h2>准备</h2><p>创建一个名为<strong>FormattedText</strong>的新 SwiftUI 项目。</p><h2>怎么做…</h2><p>首先将Text用VStack包裹一下</p><pre><code class="language-swift">struct ContentView: View {
var body: some View {
        VStack{
            Text(&quot;Hello World&quot;)
        }
    }
}
</code></pre><p>然后添加一个fontWeight modifier。</p><pre><code class="language-swift">Text(&quot;Hello World&quot;).fontWeight(.medium)
</code></pre><p>添加两个个state</p><pre><code class="language-swift">@State var password = &quot;&quot;
@State var someText = &quot;&quot;
</code></pre><p>添加一个Text和SecureField, 用Text显示SecureField的输入</p><pre><code class="language-swift">SecureField(&quot;Enter a password&quot;, text: $password).padding()
Text(&quot;password entered: \(password)&quot;).italic()
</code></pre><p>添加一个Text和TextField，用Text显示TextField的输入</p><pre><code class="language-swift">TextField(&quot;Enter some text&quot;, text: $someText).padding()
Text(&quot;\(someText)&quot;).font(.largeTitle).underline()
</code></pre><p>再尝试一下其他modifier</p><pre><code class="language-swift">Text(&quot;Changing text color and make it bold&quot;).foregroundColor(Color.blue).bold()
Text(&quot;Use kerning to change space between lines of text&quot;).kerning(7)
Text(&quot;Changing baseline offset&quot;).baselineOffset(100)
Text(&quot;Strikethrough&quot;).strikethrough()
Text(&quot;This is a multiline text implemented in SwiftUI. The trailing modifier was added to the text. This text also implements multiple modifiers&quot;)
    .background(Color.yellow)
    .multilineTextAlignment(.trailing)
    .lineSpacing(10)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj3txyjzfj30cu0qgjsg.jpg" alt="image-20211219140147411"/></p><h2>How it works…</h2><p>Text有关于font，spacing等相关的Modifier。TextFiled和SecureField都需要一个<code>State</code>来存储输入，我们可以使用<code>@State</code>来声明一个<code>State</code>。SwiftUI会在<code>State</code>改变时，自动刷新UI。</p><p>我们通过$来绑定<code>State</code>。</p><pre><code class="language-swift">  TextField(&quot;Enter some text&quot;, text: $someText)     
</code></pre><h2>There&#x27;s more…</h2><p>我们继续添加Text，当子视图超过10个时，就会报错。原来是SwiftUI只支持最大10个子视图。所以此时，我们需要使用<code>Group</code>来分割我们的子视图。</p><h2>详细介绍</h2><h3>Text</h3><p>用于显示1行或者多行的只读文本。</p><h4>Creating a Text View from a String</h4><pre><code class="language-swift">//国际化
init(_ key: LocalizedStringKey, tableName: String? = nil, bundle: Bundle? = nil, comment: StaticString? = nil)
//普通字符串，无国际化
init&lt;S&gt;(_ content: S) where S : StringProtocol
//富文本
init(_ attributedContent: AttributedString)
</code></pre><h4>Creating a Text View for a Date</h4><pre><code class="language-swift">// 显示某个时间范围3:09-3.10 PM
init(_ dates: ClosedRange&lt;Date&gt;)
init(_ interval: DateInterval)
// 显示日期, 按照style
init(_ date: Date, style: Text.DateStyle)
</code></pre><h4>Creating a Text View with Formatting</h4><p>显示非string对象, 需要你的type遵循FormatStyle协议。</p><pre><code class="language-swift">init&lt;F&gt;(_ input: F.FormatInput, format: F) where F : FormatStyle, F.FormatInput : Equatable, F.FormatOutput == String
init&lt;Subject&gt;(_ subject: Subject, formatter: Formatter) where Subject : ReferenceConvertible
init&lt;Subject&gt;(_ subject: Subject, formatter: Formatter) where Subject : NSObject
</code></pre><p>我们也可以实现自己的formater。比如我们要格式化日期为yyyy-MM-dd。但默认Date.FormatStyle提供的似乎不够用，我们可以实现自己的formater。</p><pre><code class="language-swift">struct YYYYMMddDateStyle: FormatStyle {
    typealias FormatInput = Date
    typealias FormatOutput = String
    
    static let dateFormater: DateFormatter = {
        let formater = DateFormatter()
        formater.dateFormat = &quot;yyyy-MM-dd&quot;
        return formater
    }()
    func format(_ value: Date) -&gt; String {
        return YYYYMMddDateStyle.dateFormater.string(from: value)
    }
}
/// 扩展一下FormatStyle，这样就有提示了
extension FormatStyle where Self == YYYYMMddDateStyle {
    static var yyyyMMddDateStyle:YYYYMMddDateStyle { return .init() }
}

//使用
struct ContentView: View {
    var body: some View {
        Text.init(Date(), format: .yyyyMMddDateStyle)
    }
}
</code></pre><h4>Creating a Text View from an Image</h4><p>将图片包裹为Text，适合和其他Text拼接。</p><pre><code class="language-swift">init(_ image: Image)
</code></pre><p>例子:</p><pre><code class="language-swift">struct ContentView: View {
    @State var password = &quot;&quot;
    @State var someText = &quot;Initial text&quot;
    var body: some View {
            Text(&quot;hello&quot;) + Text(Image(&quot;my-img-name&quot;)) + Text(&quot;world&quot;)
    }
}            
</code></pre><h4>Choosing a Font</h4><p>字体相关：</p><pre><code class="language-swift">func font(Font?) -&gt; Text
func fontWeight(Font.Weight?) -&gt; Text
</code></pre><h4>Styling the View’s Text</h4><p>文本样式</p><pre><code class="language-swift">func foregroundColor(Color?) -&gt; Text
func bold() -&gt; Text
func italic() -&gt; Text
func strikethrough(Bool, color: Color?) -&gt; Text
func underline(Bool, color: Color?) -&gt; Text
func monospacedDigit() -&gt; Text
func kerning(CGFloat) -&gt; Text
func tracking(CGFloat) -&gt; Text
func baselineOffset(CGFloat) -&gt; Text
func textCase(Text.Case?) -&gt; some View
</code></pre><h4>Fitting Text into Available Space</h4><p>缩放相关:</p><pre><code class="language-swift">func allowsTightening(Bool) -&gt; some View//是否允许缩放两个字符间的间距
func minimumScaleFactor(CGFloat) -&gt; some View//缩放字体
func truncationMode(Text.TruncationMode) -&gt; some View//截断
</code></pre><h4>Handling Multiline Text</h4><p>处理多行文本</p><pre><code class="language-swift">func lineLimit(Int?) -&gt; some View
func lineSpacing(CGFloat) -&gt; some View
func multilineTextAlignment(TextAlignment) -&gt; some View
</code></pre><h4>其他</h4><p>还有些voiceover和accessbility相关的功能，可以暂时忽略</p><h3>TextField</h3><p>输入框。</p><h4>Creating a Text Field with a String Value</h4><p>textfield和string绑定。需要3个东西： title, binding和prompt。</p><pre><code class="language-swift">init(_ titleKey: LocalizedStringKey, text: Binding&lt;String&gt;, prompt: Text?)
init&lt;S&gt;(_ title: S, text: Binding&lt;String&gt;, prompt: Text?) where S : StringProtocol
init(text: Binding&lt;String&gt;, prompt: Text? = nil, label: () -&gt; Label)
</code></pre><p>注意title和prompt的区别。</p><pre><code class="language-swift">Form {
    TextField(text: $username, prompt: Text(&quot;Required&quot;)) {
        Text(&quot;Username&quot;)
    }
    SecureField(text: $password, prompt: Text(&quot;Required&quot;)) {
        Text(&quot;Password&quot;)
    }
}
</code></pre><p>在macOS上：前面的文字是title/label。placeholder是prompt。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj9ltz1ppj30qi05m74e.jpg" alt="image-20211219172142715"/></p><p>在ios上，不会单独显示label，如果提供了prompt，则用prompt作为placeholder，没有提供则用title/label作为placeholder。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gxj9nghei6j30og094q2x.jpg" alt="image-20211219172316635"/></p><h4>Creating a Text Field with an Arbitrary Value</h4><p>TextField并不一定只能binding到String，可以Binding到任何类型，只是需要一个ParseableFormatStyle 或者 Formatter。</p><pre><code class="language-swift">init&lt;F&gt;(_ titleKey: LocalizedStringKey, value: Binding&lt;F.FormatInput&gt;, format: F, prompt: Text? = nil) where F : ParseableFormatStyle, F.FormatOutput == String
init&lt;S, F&gt;(_ title: S, value: Binding&lt;F.FormatInput&gt;, format: F, prompt: Text? = nil) where S : StringProtocol, F : ParseableFormatStyle, F.FormatOutput == String
init&lt;F&gt;(value: Binding&lt;F.FormatInput&gt;, format: F, prompt: Text? = nil, label: () -&gt; Label) where F : ParseableFormatStyle, F.FormatOutput == String
init&lt;V&gt;(_ titleKey: LocalizedStringKey, value: Binding&lt;V&gt;, formatter: Formatter, prompt: Text?)
init&lt;S, V&gt;(_ title: S, value: Binding&lt;V&gt;, formatter: Formatter, prompt: Text?) where S : StringProtocol
init&lt;V&gt;(value: Binding&lt;V&gt;, formatter: Formatter, prompt: Text? = nil, label: () -&gt; Label)
</code></pre><p>我们来举个例子，将一个Person绑定到TextField。TextField显示<code>firstName lastName</code>。</p><p>先定义Person</p><pre><code class="language-swift">struct Person {
    var firstName = &quot;&quot;
    var lastName = &quot;&quot;
}
</code></pre><p>定义解析策略，负责将String解析成Person</p><pre><code class="language-swift">/// 解析，负责将string解析成自定义类型
struct PersonParseStrategy: ParseStrategy {
    typealias ParseInput = String
    typealias ParseOutput = Person
    func parse(_ value: String) throws -&gt; Person {
        var components = value.components(separatedBy: &quot; &quot;)
        if components.isEmpty {
            return Person()
        } else if components.count == 1 {
            return Person(firstName: components[0], lastName: &quot;&quot;)
        } else {
            let firstName = components[0]
            components.removeFirst()
            let lastName = components.joined(separator: &quot; &quot;)
            return Person(firstName: firstName, lastName: lastName)
        }
    }
}
</code></pre><p>定义FormatStyle，负责将Person格式化为String</p><pre><code class="language-swift">/// formater, 负责将自定义类型解析成textfield的显示
struct PersonNameFormatStyle: ParseableFormatStyle {
    typealias Strategy = PersonParseStrategy
    typealias FormatInput = Person
    typealias FormatOutput = String
    var parseStrategy = PersonParseStrategy()
    func format(_ value: Person) -&gt; String {
        return &quot;\(value.firstName) \(value.lastName)&quot;
    }
}
@available(iOS 15.0, *)
extension ParseableFormatStyle where Self == PersonNameFormatStyle {
    static var personNameFormatStyle: PersonNameFormatStyle { .init() }
}
</code></pre><p>使用</p><pre><code class="language-swift">struct ContentView: View {
    @State var person = Person()
    var body: some View {
    TextField(&quot;请输入姓名&quot;, value: $person, format: .personNameFormatStyle, prompt: nil)
        Text(&quot;firstName:\(person.firstName) lastName:\(person.lastName)&quot;)
    }
}       
</code></pre><h4>Creating a Text Field with an Arbitrary Optional</h4><p>和上面的类似，只是支持Optional</p><pre><code class="language-swift">init&lt;F&gt;(_ titleKey: LocalizedStringKey, value: Binding&lt;F.FormatInput?&gt;, format: F, prompt: Text? = nil) where F : ParseableFormatStyle, F.FormatOutput == String
....省略
</code></pre><h4>Styling Text Fields</h4><p>设置text field的style</p><pre><code class="language-swift">func textFieldStyle&lt;S&gt;(_ style: S) -&gt; some View where S : TextFieldStyle
</code></pre><p>举例</p><pre><code class="language-swift">TextField(&quot;请输入姓名&quot;, value: $person, format: .personNameFormatStyle, prompt: nil)
.textFieldStyle(.roundedBorder)
</code></pre><h4>常用的UITextFieldDelegate对比</h4><p>.editingChanged</p><pre><code class="language-swift">TextField(&quot;&quot;, text: $password)
   .onChange(of: password) { newValue in
        password = Format(password)
   }
</code></pre><p>.editingDidBegin / .editingDidEnd</p><pre><code>@FocusState var isFocused: Bool
TextField(&quot;&quot;, text: $password)
    .focused($isFocused)                
    .onChange(of: isFocused) { newValue in
       print(&quot;current foucus state \(newValue)&quot;)
    }
</code></pre><p>textShouldReturn</p><pre><code class="language-swift">TextField(&quot;&quot;, text: $password)
   .onSubmit {
       print(&quot;clicked return btn&quot;)
   }
</code></pre><h3>SecureField</h3><p>只能binding到string，不能像TextField一样可以绑定任何值。</p><p>没有显示真实输入密码的功能。要实现眼睛功能，只有用TextField和SecureField一起。</p><h4>Creating a Secure Text Field</h4><p>和texfiled类似</p><pre><code class="language-swift">init&lt;S&gt;(_ title: S, text: Binding&lt;String&gt;, prompt: Text?) where S : StringProtocol
</code></pre><h4>Configuring Text Entry</h4><pre><code class="language-swift">func keyboardType(_ type: UIKeyboardType) -&gt; some View //键盘类型
func disableAutocorrection(_ disable: Bool?) -&gt; some View //自动修正
func textInputAutocapitalization(_ autocapitalization: TextInputAutocapitalization?) -&gt; some View //自动首字母大小写
//设置文本类型，系统会根据类型为输入提供建议
func textContentType(_ textContentType: UITextContentType?) -&gt; some View
</code></pre><h3>TextEditor</h3><p>显示和编辑多行较长的文本</p><h4>Creating a Text Editor</h4><pre><code class="language-swift">init(text: Binding&lt;String&gt;)
</code></pre><h4>Styling the View’s Text</h4><pre><code class="language-swift">func font(_ font: Font?) -&gt; some View
func foregroundColor(_ color: Color?) -&gt; some View
func multilineTextAlignment(_ alignment: TextAlignment) -&gt; some View
func lineSpacing(_ lineSpacing: CGFloat) -&gt; some View
func allowsTightening(_ flag: Bool) -&gt; some View
</code></pre><h4>Managing Text Entry</h4><pre><code class="language-swift">func textInputAutocapitalization(_ autocapitalization: TextInputAutocapitalization?) -&gt; some View
func disableAutocorrection(_ disable: Bool?) -&gt; some View
func keyboardType(_ type: UIKeyboardType) -&gt; some View
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[SwiftUI专辑001-layout相关控件]]></title>
            <link>https://gouxin.fun/2021/11/04/SwiftUI专辑-001-layout相关控件</link>
            <guid>/2021/11/04/SwiftUI专辑-001-layout相关控件</guid>
            <pubDate>Thu, 04 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerimg"/>
本文将介绍用于布局相关的一些控件</p><ul><li>VStack</li><li>HStack</li><li>ZStack</li><li>Spacer</li><li>Divider</li></ul><h2>准备</h2><p>先创建一个叫做<code>TheStacks</code>的SwiftUI工程。</p><h2>写代码</h2><p>修改ContentView里的body为以下代码, 然后resume Preview：</p><pre><code class="language-swift">VStack {
            Text(&quot;VStack Item 1&quot;)
            Text(&quot;VStack Item 2&quot;)
            Text(&quot;VStack Item 3&quot;)
        }.background(Color.blue)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9ytz8862j302s05h3yb.jpg" alt="008i3skNly1gx9ys9dvjmj30do0qwmxn"/></p><p>然后我们在添加一些Divider和Spacer。</p><pre><code class="language-swift">VStack {
            Text(&quot;VStack Item 1&quot;)
            Text(&quot;VStack Item 2&quot;)
            Spacer()
            Divider().background(Color.white)
            Text(&quot;VStack Item 3&quot;)            
        }.background(Color.blue)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9z4p6o9kj304608it8l.jpg" alt="image-20211211162833693"/></p><p>我们再在<code>item 3</code>之后加一个HStack和ZStack。</p><pre><code class="language-swift">VStack {
            Text(&quot;VStack Item 1&quot;)
            Text(&quot;VStack Item 2&quot;)
            Spacer()
            Divider().background(Color.white)
            Text(&quot;VStack Item 3&quot;)
            HStack {
                Text(&quot;Item 1&quot;)
                Divider().background(Color.black)
                Text(&quot;HStack Item 2&quot;)
                Divider().background(Color.black)
                Spacer()
                Text(&quot;HStack Item 3&quot;)
            }.background(Color.red)
            ZStack {
                Text(&quot;ZStack Item 1&quot;).padding().background(Color.green).opacity(0.8)
                Text(&quot;ZStack Item 2&quot;).padding().background(Color.green).offset(x: 80, y: -400)
            }
        }.background(Color.blue)
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx9za4cl4zj305k0b8mx9.jpg" alt="截屏2021-12-11 下午4.33.17"/></p><h2>这是怎么工作的？</h2><p>一个新的SwiftUI工程默认是以一个居中的Text开始的。</p><p><code>body</code>返回一个<code>View</code>。</p><p>如果要添加竖直排列的其他View，我们用VStack替换掉默认的Text，然后添加内容。</p><p>SwiftUI的Stack使用如下步骤来决定如何显示它的内容(详细可参考WWDC2019:利用SwiftUI构建自定义视图)：</p><ol><li>Figure out its internal spacing and subtract that from the size proposed by its parent view.(确定子视图的大小，从父视图提供的大小中减去子视图)</li><li>Divide the remaining space into equal parts.(将剩余空间按剩余子视图数量等分)</li><li>Process the size of its least flexible view.(处理 least flexibl的视图，确定其大小)</li><li>Divide the remaining unclaimed space by the unallocated space, and then repeat <em>Step 2</em>.（用剩余空间减去其大小，再重复步骤2）</li><li>The stack then aligns its content and chooses its own size to exactly enclose its children.( stack对其他的内容，确定其自身大小，其大小是刚好包裹子视图)</li></ol><p>添加<strong>Spacer</strong>可以强制View使用最大的空间。这是因为<strong>Spacer()</strong>是最flexible的视图，它在显示所有其他视图之后填充剩余空间。</p><p><strong>Divider</strong>用来画一个占满parent宽度的水平线，这也是为什么我们加了<strong>Divider</strong>后，蓝色背景会撑满屏幕宽度。默认<strong>Divider</strong>没有颜色，我们可以通过<code>.background(Color)</code>modifier来设置。</p><p>modifier是一系列可以应用到View上的方法，换句话说：他将某些改动设置到View上，然后返回新的View。</p><p>常用的<strong>.background(Color. black)</strong>, <strong>.padding()</strong>, and <strong>.offsets(…)</strong>都是modifier。</p><p><strong>HStack</strong>和<strong>VStack</strong>类似，不过他是水平从左到右显示他的内容。添加<strong>Spacer</strong>到<strong>HStack</strong>中，会让它填满水平空白区域，<strong>Divider</strong>也是竖直向下的。</p><p><strong>ZStack</strong>和<strong>HStack</strong> 、 <strong>VStack</strong> 类似，不过是重叠他的content在已有的item上。</p><h2>There&#x27;s more…</h2><p>你还可以使用<strong>.frame</strong> modifier来调整component的width和height。</p><pre><code class="language-swift">.frame(
  maxWidth: .infinity,
    maxHeight: .infinity,
    alignment: .topLeading
)
</code></pre><h2>SwiftUI 中布局的工作原理</h2><p>详细可参考WWDC2019:利用SwiftUI构建自定义视图</p><h3>Hello world布局</h3><p>我们先来看一个Hello world的例子。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfshsh127j30zc0jqjsj.jpg" alt="image-20211216171253892"/></p><p>这里有3个View：</p><ul><li>Text: 大小由文本决定</li><li>ContentView：大小由children决定，所以上图中ContentView的大小刚好包裹Text</li><li>RootView：屏幕减去safeArea的区域，你可以通过<code>.edgesIgnoringSafeArea(.all)</code>modifier来修改这个行为，这样就是整个屏幕。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfsmiww1yj30z40juabb.jpg" alt="image-20211216171729871"/></p><p>我们把任何带有<code>var body: some View</code>的视图成为<code>中性视图(Layout Neutral)</code>，他的边界是由他的<code>body</code>决定的，因此我们上面才说ContentView的大小和Text是一致的。</p><p>我们再来看看布局过程：</p><ul><li>RootView：嘿，我有整个安全区域那么大，你需要多大的空间？</li><li>ContentView：好的，但是我是中性视图，我得问下我的body。Text你好，我有整个安全区域那么大，你需要多少空间？</li><li>Text：好的，我的文本是Helloworld，我只需要100 * 20那么大。</li><li>ContentView：好的，我是中性视图，你多大我就多大，RootView，我只需要100 * 20那么大。</li><li>RootView：好的，我还有很多剩余空间，我默认会把你放到我的center那里。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxftfq527nj30z80jyjsz.jpg" alt="image-20211216174533016"/></p><p>总结下布局过程：</p><ol><li>Parent为children提供一个size</li><li>Children确定自己的大小</li><li>Parent将children放到自己的坐标系中</li><li>屏幕像素是整数，但大小是小数，处理小数大小，会round到最近的整数</li></ol><h3>更复杂的例子</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxftngd4c6j30ze0jmdh9.jpg" alt="image-20211216175258340"/></p><ul><li>RootView：嘿，我有整个安全区域那么大，你需要多大的空间？</li><li>Toast：好的，但是我是中性视图，我得问下我的body。Background你好，我有整个安全区域那么大，你需要多少空间？</li><li>Background: 好的，但是我也是中性视图。Padding你好，我有整个安全区域那么大，你需要多少空间？</li><li>Padding：好的。Text你好，我有整个安全区域减去10 padding那么多空间，你需要多少空间？</li><li>Text：我需要100* 100 。</li><li>Padding: 好的, Background，我只需要110* 110</li><li>Background: 好的，我还有子视图Color，我得问下他，Color你好，我有110 * 110, 那么大，你需要多少。</li><li>Color：我也需要110 * 110</li><li>Background：好的，Toast，我只需要110 *110</li><li>Toast: 好的,RootView，我也只需要110* 110</li><li>RootView: 好的，我还有很多剩余空间，我默认会把你放到我的center那里。</li></ul><h3>再来一个简单但重要的例子</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfu70mnauj30yo0jkaau.jpg" alt="image-20211216181143533"/></p><p>SwiftUI中除非你指定图片是可缩放的，否则图片的size就是图片本身的大小。</p><p>现在我想让图片是30x30，我们加个frame modifier。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfu8csg25j30yq0j8myk.jpg" alt="image-20211216181304205"/></p><p>你会在图片周围发现一个30x30的框，这和我们刚刚说的图片大小不可改矛盾了么？</p><p>frame并不是约束，而是modifier，modifier返回的是一个新的view。所以你加了frame modifier后，30x30实际上是新的view。Image还是20x20。</p><h3>再看看Stack的布局原理</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfugngw30j30yw0jadhj.jpg" alt="image-20211216182102883"/></p><p>我们首先得注意到，SwiftUI并不是直接吧Stack堆砌在一起，而是在他们之间留有adaptive space。这是SwiftUI将apple 人性化设计指南的一些规则默认应用到了SwiftUI的结果，他们希望你能通过最简单的代码，也能产生漂亮的结果。如果你不希望有这些space，可以在Stack初始化的参数中指定spacing为0。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuirdcufj30yo0ig0u2.jpg" alt="image-20211216182304331"/></p><pre><code class="language-swift">VStack(spacing: 0) {
            Text(&quot;hello world111&quot;).background(Color.red)
            Image(&quot;question-circle&quot;).background(Color.green)
        }
</code></pre><p>现在我们来分析下Stack是如何工作的？我们看个例子。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuo84px1j30yu0ja0u9.jpg" alt="image-20211216182819005"/></p><ol><li>首先Parent告诉HStack建议的size</li><li>HStack先减去spacing(如果没指定，是有默认space的，上面说过)，得到剩余空间<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfurqbo6vj30gq06g3yi.jpg" alt="image-20211216183141238"/></li><li>因为HStack有3个children，所以将剩余空间3等分<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuswb3oxj30eu06eweh.jpg" alt="image-20211216183248259"/></li><li>找出least flexible的子视图，其中图片是least flexible的，因为他的size是固定的。所以剩余空间减去图片size<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuw0e4s0j30f605sdfu.jpg" alt="image-20211216183548332"/></li><li>重复上面过程。目前有2个children。所以2等分<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfuwzhgh5j30ek0680ss.jpg" alt="image-20211216183644570"/></li><li>两个优先级一样，因此处理第一个，先把一半的size分配给<code>Delicious</code>。但<code>Delicious</code>说，太多了，我要不了这么多，我只要这么多size。<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfv27t0v9j30de058dfv.jpg" alt="image-20211216184145585"/></li><li>再重复上面的过程，得到最新的剩余空间<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfv3agfbhj30gm05q3yk.jpg" alt="image-20211216184248523"/></li><li>把剩下的所有空间分配给<code>Avocado Toast</code>。<code>Avocado Toast</code>说，太多了，我用不完这么多空间。于是<code>Avocado Toast</code>刚好能显示完，整个HStack的size会比Parent提供的小一些。</li><li>水平方向的size确定了，然后确定竖直方向的。竖直方向按照HStack的<code>alignment</code>参数对其，然后size刚好能包裹整个Hstack。</li><li>至此整个Hstack的大小就完全确定了。</li></ol><p>再来看看，如果第8步中剩余空间不够<code>Avocado Toast</code>显示了，那么<code>Avocado Toast</code>会被截断</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfvc8au0yj30fa05eq32.jpg" alt="image-20211216185124090"/></p><p>但是如果我们想尽可能不截断<code>Avocado Toast</code>,优先截断<code>Delicios</code>，要怎么做呢？我们可以指定优先级。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfvfor138j30g0094q36.jpg" alt="image-20211216185442941"/></p><p>在有优先级的情况下，SwiftUI会先给所有低优先级的视图预留最小size，然后把剩余空间分配给高优先级视图：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfvhkjb9qj30fg07w0sw.jpg" alt="image-20211216185632384"/></p><h3>Alignment</h3><h4>alignmentGuide</h4><p>还记得我们第9步中说到<code>alignment</code>么？这里再多说一点其中的基线对其<code>lastTextBaseline</code>。有时候我们可能对默认基线对其不满意， 我们可以通过<code>alignmentGuide</code>自定义对其位置:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfvr2ju9hj30xo0hejtx.jpg" alt="image-20211216190539364"/></p><p><code>.alignmentGuide(.lastTextBaseline) { d in d[.bottom] * 0.975 }</code>的意思是对于<code>lastTextBaseline</code>这种对其方式，他的对其位置是在<code>.bottom</code>的0.927处</p><h4>自定义对其方式</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfw0hw2bxj30mg05gt8x.jpg" alt="image-20211216191443420"/></p><p>考虑下我们要将星星，和<code>Avocado Toast</code>对其。啥？他们不是在两个不同的VStack中么？没关系我们可以自定义对其方式，让他们对其。</p><p>首先，自定义一种对其方式<code>midStartAndTitle</code>：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfw3fdbzoj30re0ekwfx.jpg" alt="image-20211216191732259"/></p><p>使用新的对其方式</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxfwc8fjwmj30xu0iy40z.jpg" alt="image-20211216192559807"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[一个简单的StringKeyChain]]></title>
            <link>https://gouxin.fun/2021/11/03/一个简单的StringKeyChain</link>
            <guid>/2021/11/03/一个简单的StringKeyChain</guid>
            <pubDate>Wed, 03 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerimg]]></description>
            <content:encoded><![CDATA[<p><img src="./B6086038-32F7-48AE-AC07-DBAE5C0F21D7.png" alt="headerimg"/></p><p>一个简单的<code>StringKeyChain</code>封装，存储/获取字符串到keychain中。通常用于生成设备的唯一id。</p><pre><code class="language-swift">class StringKeyChain {
    static func save(value: String, key: String) {
        let data = value.data(using: .utf8)!
        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,
                                    kSecAttrAccount as String: key,
                                    kSecValueData as String: data]
        SecItemDelete(query as CFDictionary)
        let status = SecItemAdd(query as CFDictionary, nil)
        if status != errSecSuccess {
            print(&quot;keychain save error&quot;)
        }
    }

    static func getValue(key: String) -&gt; String? {
        let query: [String: Any] = [kSecClass as String: kSecClassGenericPassword,
                                    kSecAttrAccount as String: key,
//                                    kSecAttrService as String: key,
//                                    kSecAttrAccessible as String: kSecAttrAccessibleAfterFirstUnlock,
                                    kSecMatchLimit as String: kSecMatchLimitOne,
                                    kSecReturnData as String: kCFBooleanTrue!]

        var retrivedData: AnyObject?

        _ = SecItemCopyMatching(query as CFDictionary, &amp;retrivedData)

        guard let data = retrivedData as? Data else { return nil }
        return String(data: data, encoding: .utf8)
    }
}


</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何用XcodeKit编写一个XcodeExtension?]]></title>
            <link>https://gouxin.fun/2021/11/02/如何用XcodeKit编写一个XcodeExtension</link>
            <guid>/2021/11/02/如何用XcodeKit编写一个XcodeExtension</guid>
            <pubDate>Tue, 02 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[HEADer]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="HEADer"/>
Xcode提供了XcodeKit，来允许我们编写Xcode的扩展。但是这个Extension功能有限，只能处理当前打开的文件的源码。
我们可以用来：格式化、自动生成代码等。
常用的Extension有XCFormat，可以格式化Swift和OC代码，可以在AppStore中下载。
整体开发插件的功能还是比较简单，我们从头演示一个移除一行开头的数字的插件。</p><h2>创建Xcode Extension工程</h2><h3>创建一个macOS工程</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6clhtzij313a0do0u1.jpg" alt="image-20211129180100344"/></p><p>这个macOS工程，对应从App Store下载完Extension后，在桌面上生成的那个App。你可以在这个App中做Extension设置相关的界面。</p><h3>新建一个Xcode Source Editor Extention Target</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6l504ldj313y0cydh7.jpg" alt="截屏2021-11-29 下午6.09.11"/></p><h3>运行Extension Target</h3><p>点击运行Extension Target，选择Xcode，此时会打开一个灰色的Xcode。</p><p>打开我们的插件的macOS工程。</p><p>选择<code>Editor</code>菜单，底部就出现了我们的自定义菜单。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6wlndiej30tq05ct95.jpg" alt="image-20211129182015367"/></p><p>如果菜单没有出现，那么请修改一下Extension Target中XcodeKit的链接方式，选择<code>Embed &amp; Sign</code>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww6xtzyhhj319u0k2gnk.jpg" alt="image-20211129182127182"/></p><h2>Xcode Source Editor Extention</h2><p>默认的<code>Xcode Source Editor Extention</code>会为你生成两个文件：</p><ul><li><code>SourceEditorExtension</code>:  这个文件定义你小菜单中的内容和extension启动时的回调。</li><li><code>SourceEditorCommand</code>: 是小菜单中的命令对应的实现类。</li></ul><h3>小菜单的定义</h3><p>小菜单的定义有两种方式，一种是通过<code>SourceEditorExtension</code>的代码定义。一种是通过<code>Info.plist</code>定义。代码定义的优先级更高，会覆盖Info.plist中的定义。</p><h4>在Info.plist中定义</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww78nx1j2j318i0ceq5g.jpg" alt="image-20211129183151859"/></p><p>每个命令就是小菜单中的一个命令对应。</p><ul><li>XCSourceEditorCommandClassName： 这个命令对应的实现类。格式是moduleName + 实现类的类名： <code>$(PRODUCT_MODULE_NAME).YourImplClassName</code>。</li><li>XCSourceEditorCommandIdentifier：你的这个命令的一个唯一id。格式是bundleId +一个字符串： <code>$(PRODUCT_BUNDLE_IDENTIFIER).SourceEditorCommand</code></li><li>XCSourceEditorCommandName：菜单中出现的命令的名字</li></ul><h4>在SourceEditorExtension中定义小菜单</h4><pre><code class="language-swift">class SourceEditorExtension: NSObject, XCSourceEditorExtension {
    
    /*
    func extensionDidFinishLaunching() {
        // If your extension needs to do any work at launch, implement this optional method.
    }
    */
    
    
    var commandDefinitions: [[XCSourceEditorCommandDefinitionKey: Any]] {
        // If your extension needs to return a collection of command definitions that differs from those in its Info.plist, implement this optional property getter.
        let command: [XCSourceEditorCommandDefinitionKey: Any] = [
            //格式moduleName.命令实现类的类名
            .classNameKey: &quot;GxEditorToolsExtension.SourceEditorCommand&quot;,
            //格式bundleId.自定义字符串
            .identifierKey: &quot;com.haixue.GxXcodeEditorTools.GxEditorToolsExtension.removeLinePrefixNum&quot;,
            //自定义名称
            .nameKey: &quot;我的小菜单&quot;
        ]
        return [command]
    }
    
}

</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gww7hohzb6j30ok05gaag.jpg" alt="image-20211129184031347"/></p><h3>命令的实现</h3><p>实现类都遵循<code>XCSourceEditorCommand</code>协议。</p><p>当我们点击小菜单，会通过command的<code>XCSourceEditorCommandClassName</code>找到对应的实现类。调用实现类的<code>func perform(...)</code>方法。</p><p>我们看到新建项目默认为我们生成了一个command模板SourceEditorCommand。</p><pre><code class="language-swift">class SourceEditorCommand: NSObject, XCSourceEditorCommand {
    
    func perform(with invocation: XCSourceEditorCommandInvocation, completionHandler: @escaping (Error?) -&gt; Void ) -&gt; Void {
        // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.
        
        completionHandler(nil)
    }
    
}
</code></pre><h3>实现我们自己的命令</h3><pre><code class="language-swift">import Foundation
import XcodeKit

class RemoveLinePrefixNumCommand: NSObject, XCSourceEditorCommand {
    
    func perform(with invocation: XCSourceEditorCommandInvocation, completionHandler: @escaping (Error?) -&gt; Void ) -&gt; Void {
        // Implement your command here, invoking the completion handler when done. Pass it nil on success, and an NSError on failure.
        let lines = invocation.buffer.lines
        let result = lines.map { &quot;\($0)&quot; }.map{ self.removePrefixNum(str: $0) }
        invocation.buffer.lines.removeAllObjects()
        invocation.buffer.lines.addObjects(from: result)        
        completionHandler(nil)
    }
    
    func removePrefixNum(str: String) -&gt; String {
        var chars: [Character] = []
        //空格和数字
        let sets: Set&lt;Character&gt; = [&quot; &quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;]
        var shouldCheck = true
        for c in str {
            if shouldCheck {
                if sets.contains(c) {
                    chars.append(&quot; &quot;)
                } else {
                    chars.append(c)
                    shouldCheck = false
                }
            } else{
                chars.append(c)
            }
        }
        return String(chars)
    }
}

</code></pre><pre><code class="language-objective-c">//可以看到invocation有用的也只有一个Buffer对象
@interface XCSourceEditorCommandInvocation : NSObject
/** The identifier of the command the user invoked. */
@property (readonly, copy) NSString *commandIdentifier;
/** The buffer of source text on which the command can operate. */
@property (readonly, strong) XCSourceTextBuffer *buffer;
@property (copy) void (^cancellationHandler)(void);
@end
</code></pre><pre><code class="language-objective-c">///buffer，又只能操作tab、lines、selections。
@interface XCSourceTextBuffer : NSObject

@property (readonly, copy) NSString *contentUTI;
@property (readonly) NSInteger tabWidth;
@property (readonly) NSInteger indentationWidth;
@property (readonly) BOOL usesTabsForIndentation;

@property (readonly, strong) NSMutableArray &lt;NSString *&gt; *lines;
@property (readonly, strong) NSMutableArray &lt;XCSourceTextRange *&gt; *selections;
@property (copy) NSString *completeBuffer;
@end
</code></pre><p>xcodeKit只能操作文本，像语法解析等都得借助别的工具来实现。</p><h3>调试</h3><p>在工程中打上断点，点击运行。</p><p>在灰色xcode中打开我们工程，点击小菜单。就会进入我们断点。</p><h3>集成到Xcode的Editor菜单</h3><p>进入<strong>系统偏好设置</strong>--<strong>扩展</strong>，选中我们的插件钩上即可</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwwg9umm74j30xw0oc0uo.jpg" alt="image-20211129234423601"/></p><h3>制作安装包</h3><p><code>archive</code> ，然后选择copy app，得到一个.app</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwghg4w4tj311q0lydgo.jpg" alt="image-20211129235140936"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwgj43el5j30t20jsac5.jpg" alt="image-20211129235317200"/></p><p>新建一个文件夹，将.app和应用程序的提升文件一起放入，重命名提升文件为Application。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwgkqyjeaj30f405s3yh.jpg" alt="image-20211129235452152"/></p><p>打开磁盘工具</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwglezhl6j30li0ti75q.jpg" alt="image-20211129235529816"/></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gwwglrcau8j30v4084ab6.jpg" alt="image-20211129235549564"/></p><p>选择刚刚的文件夹，就制作成了dmg。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何查看iOS、iPadOS系统版本占比？]]></title>
            <link>https://gouxin.fun/2021/11/01/如何查看ios和ipados当前系统版本占比</link>
            <guid>/2021/11/01/如何查看ios和ipados当前系统版本占比</guid>
            <pubDate>Mon, 01 Nov 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[header]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="header"/>
每当开始新项目的时候，我们都得决定应该把最低系统版本设置为多少，此时，我们都希望能有个参考，市场上的系统版本的占比究竟是多少？
苹果官网有一个最近3个系统版本的占比统计，我们可以参考一下。</p><h2>官网占比统计</h2><p><a href="https://developer.apple.com/support/app-store/">官网统计页面</a></p><p><img src="./iOS_and_iPadOS_usage.png" alt="iOS_and_iPadOS_usage"/></p><p>可以看到统计时间是2021年6月3日，</p><p>iphone</p><ul><li><p>近四年的设备中已有98%到iOS13以上。</p></li><li><p>所有设备中93%已经到iOS13以上。</p></li></ul><p>iPad</p><ul><li>近四年的设备中已有99%到iOS13以上。</li><li>所有设备中88%已经到iOS13以上。</li></ul><h2>常用App的最低版本</h2><p>我们再去appstore中看下免费App排行榜设置的最低版本是多少。</p><table><thead><tr><th>App名称</th><th>兼容性</th></tr></thead><tbody><tr><td>国家反诈中心</td><td>iOS10</td></tr><tr><td>微信</td><td>iOS12</td></tr><tr><td>抖音</td><td>iOS10</td></tr><tr><td>QQ</td><td>iOS9</td></tr><tr><td>支付宝</td><td>iOS9</td></tr><tr><td>拼多多</td><td>iOS9</td></tr><tr><td>淘宝</td><td>iOS9</td></tr><tr><td>百度</td><td>iOS10</td></tr><tr><td>美团</td><td>iOS10</td></tr><tr><td>剪映</td><td>iOS11</td></tr><tr><td>高德地图</td><td>iOS10</td></tr><tr><td>小红书</td><td>iOS10</td></tr><tr><td>得物</td><td>iOS10</td></tr><tr><td>快手极速版</td><td>iOS9</td></tr><tr><td>快手</td><td>iOS10</td></tr><tr><td>抖音极速版</td><td>iOS10</td></tr><tr><td>腾讯视频</td><td>iOS10</td></tr><tr><td>咸鱼</td><td>iOS9</td></tr><tr><td>京东</td><td>iOS9</td></tr><tr><td>钉钉</td><td>iOS10</td></tr><tr><td>酷狗音乐</td><td>iOS9</td></tr><tr><td>优酷</td><td>iOS10</td></tr><tr><td>QQ音乐</td><td>iOS9</td></tr><tr><td>网易云音乐</td><td>iOS11</td></tr><tr><td>哔哩哔哩</td><td>iOS9</td></tr><tr><td>爱奇艺</td><td>iOS10</td></tr><tr><td>Soul</td><td>iOS11</td></tr><tr><td>知乎</td><td>iOS11</td></tr><tr><td>今日头条</td><td>iOS10</td></tr><tr><td>虎牙直播</td><td>iOS10</td></tr><tr><td>探探</td><td>iOS11</td></tr><tr><td>。。。</td><td></td></tr></tbody></table><p>可以看到主流是iOS10。iOS11也呈现出增多的趋势。微信竟然直接是iOS12。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Xcode13的Info.plist不见了?]]></title>
            <link>https://gouxin.fun/2021/10/31/Xcode13的Info.plist不见了</link>
            <guid>/2021/10/31/Xcode13的Info.plist不见了</guid>
            <pubDate>Sun, 31 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Header]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="Header"/>
创建新的SwiftUI项目，发现Info.plist不见了？</p><p>哦~~~，原来是Xcode13引起的。</p><p>查看<a href="https://developer.apple.com/documentation/xcode-release-notes/xcode-13-release-notes">Xcode13 Release Note</a>，可以看到</p><blockquote><p>Projects created from several templates no longer require configuration files such as entitlements and <code>Info.plist</code> files. Configure common fields in the target’s Info tab, and build settings in the project editor. These files are added to the project when additional fields are used. (68254857)</p></blockquote><p>原来新的模板不在创建Info.plist了，Info.plist的功能转移到<code>Target-&gt;Info</code>下了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3pltcx9j311o0oyjub.jpg" alt="image-20211124115621173"/></p><p>在Info中修改相关设置。如果你添加了一个自定义Key，那么系统会帮你创建一个Info.plist来包含你的自定义key-value。</p><p>你也可以自己直接新建。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3p3sf3lj319g05agm4.jpg" alt="image-20211124115550252"/></p><p>非SwiftUI项目中还是存在Info.plist，但是大部分内容还是都移动到了<code>Target-&gt;Info</code>中。Info.plist只保留了部分Key-Value。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwq3sea29cj316g0dcwg7.jpg" alt="image-20211124115901894"/></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[appstore截图尺寸规范设置]]></title>
            <link>https://gouxin.fun/2021/10/30/appstore截图尺寸规范</link>
            <guid>/2021/10/30/appstore截图尺寸规范</guid>
            <pubDate>Sat, 30 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[headerImg]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="headerImg"/></p><p>上架AppStore时需要传各种机型的预览图片。这里记录一下官方文档，方便UI问你尺寸时给出准确的尺寸。</p><h2>官方链接</h2><p><a href="https://help.apple.com/app-store-connect/#/devd274dd925">https://help.apple.com/app-store-connect/#/devd274dd925</a></p><h2>至少提供的尺寸</h2><p>至少需要提供6.5、5.5、12.9英寸的截图。</p><p>5.8的可以复用6.5的。</p><p>3.5、4、4.7的可以复用5.5的</p><p>ipad复用12.9的</p><h2>截屏规范</h2><table><thead><tr><th align="left">设备尺寸或平台</th><th align="left">截屏尺寸</th><th align="left">要求</th><th align="left">截屏源</th></tr></thead><tbody><tr><td align="left">6.5 英寸：iPhone 13 Pro Max、iPhone 12 Pro Max、iPhone 11 Pro Max，iPhone 11、iPhone XS Max、iPhone XR</td><td align="left">1284 x 2778 像素（竖屏）2778 x 1284 像素（横屏）1242 x 2688 像素（竖屏）2688 x 1242 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，则此项为必需项。</td><td align="left">上传 6.5 英寸截屏</td></tr><tr><td align="left">5.8 英寸：iPhone 13 Pro、iPhone 13、iPhone 13 mini、iPhone 12 Pro、iPhone 12、iPhone 12 mini、iPhone 11 Pro、iPhone XS、iPhone X</td><td align="left">1170 x 2532 像素（竖屏）2532 x 1170 像素（横屏）1125 x 2436 像素（竖屏）2436 x 1125 像素（横屏）1080 x 2340 像素（竖屏）2340 x 1080 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 6.5 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 6.5 英寸截屏可选：上传 5.8 英寸截屏</td></tr><tr><td align="left">5.5 英寸：iPhone 8 Plus、iPhone 7 Plus、iPhone 6s Plus</td><td align="left">1242 x 2208 像素（竖屏）2208 x 1242 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，则此项为必需项。</td><td align="left">上传 5.5 英寸截屏</td></tr><tr><td align="left">4.7 英寸：iPhone SE（第 2 代）、iPhone 8、iPhone 7、iPhone 6s、iPhone 6</td><td align="left">750 x 1334 像素（竖屏）1334 x 750 像素（横屏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸截屏可选：上传 4.7 英寸截屏</td></tr><tr><td align="left">4 英寸：iPhone SE（第 1 代）</td><td align="left">640 x 1096 像素（竖屏，不含状态栏）640 x 1136 像素（竖屏，含状态栏）1136 x 600 像素（横屏，不含状态栏）1136 x 640 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸或 4.7 英寸截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸或 4.7 英寸截屏可选：上传 4 英寸截屏</td></tr><tr><td align="left">3.5 英寸：iPhone 4s</td><td align="left">640 x 920 像素（竖屏，不含状态栏）640 x 960 像素（竖屏，含状态栏）960 x 600 像素（横屏，不含状态栏）960 x 640 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPhone 上运行，且未提供 5.5 英寸 iPhone 截屏，则此项为必需项。</td><td align="left">默认：缩小版 5.5 英寸、4.7 英寸或 4 英寸截屏可选：上传 3.5 英寸截屏</td></tr><tr><td align="left">12.9 英寸：iPad Pro（第 4 代、第 3 代）</td><td align="left">2048 x 2732 像素（竖屏）2732 x 2048 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，则此项为必需项。</td><td align="left">上传适用于 12.9 英寸 iPad Pro（第 3 代）的截屏</td></tr><tr><td align="left">12.9 英寸：iPad Pro（第 2 代）</td><td align="left">2048 x 2732 像素（竖屏）2732 x 2048 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，则此项为必需项。</td><td align="left">上传适用于 12.9 英寸 iPad Pro（第 2 代）的截屏</td></tr><tr><td align="left">11 英寸：iPad Pro、iPad Air（第 4 代）、iPad mini（第 6 代）</td><td align="left">1488 x 2266 像素（竖屏）2266 x 1488 像素（横屏）1668 x 2388 像素（竖屏）2388 x 1668 像素（横屏）1640 x 2360 像素（竖屏）2360 x 1640 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 3 代）的缩小版截屏可选：上传 11 英寸截屏</td></tr><tr><td align="left">10.5 英寸：iPad（第 9 代、第 8 代、第 7 代）、iPad Pro、iPad Air</td><td align="left">1668 x 2224 像素（竖屏）2224 x 1668 像素（横屏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 2 代）的缩小版截屏可选：上传 10.5 英寸截屏</td></tr><tr><td align="left">9.7 英寸：iPad、iPad mini</td><td align="left">1536 x 2008 像素（竖屏，不含状态栏）1536 x 2048 像素（竖屏，含状态栏）2048 x 1496 像素（横屏，不含状态栏）2048 x 1536 像素（横屏，含状态栏）768 x 1004 像素（竖屏，不含状态栏）768 x 1024 像素（竖屏，含状态栏）1024 x 748 像素（横屏，不含状态栏）1024 x 768 像素（横屏，含状态栏）</td><td align="left">若 App 在 iPad 上运行，且未提供适用于 12.9 英寸 iPad Pro（第 2 代）或 10.5 英寸的截屏，则此项为必需项。</td><td align="left">默认：适用于 12.9 英寸 iPad Pro（第 2 代）的缩小版截屏或缩小版 10.5 英寸截屏可选：上传 9.7 英寸截屏</td></tr><tr><td align="left">Mac</td><td align="left">宽高比须为 16:10，以下尺寸均可： 1280 x 800 像素1440 x 900 像素2560 x 1600 像素2880 x 1800 像素</td><td align="left">对于 Mac App 为必需项。</td><td align="left">以任一所列尺寸上传的 Mac 的截屏</td></tr><tr><td align="left">Apple TV</td><td align="left">1920 x 1080 像素3840 x 2160 像素</td><td align="left">对于 Apple TV App 为必需项。</td><td align="left">以任一所列尺寸上传的 Apple TV 截屏</td></tr><tr><td align="left">Apple Watch：Series 7、Series 6、Series 5、Series 4、Series 3、SE</td><td align="left">396 x 484 像素（Series 7）368 x 448 像素（Series 6、Series 5、Series 4、SE）312 x 390 像素（Series 3）</td><td align="left">对于 Apple Watch App 为必需项。</td><td align="left">以任一所列尺寸上传的 Apple Watch 截屏</td></tr></tbody></table><h2>App 内活动媒体素材规范</h2><table><thead><tr><th align="left">媒体类型</th><th align="left">支持的扩展名</th><th align="left">宽高比</th><th align="left">最小尺寸／分辨率</th><th align="left">最大尺寸／分辨率</th></tr></thead><tbody><tr><td align="left">活动卡片图像</td><td align="left">.jpg、.jpeg、.png</td><td align="left">16 : 9</td><td align="left">1920 x 1080 像素</td><td align="left">3840 x 2160 像素</td></tr><tr><td align="left">活动卡片视频</td><td align="left">.mov、.m4v、.mp4</td><td align="left">16 : 9</td><td align="left">1920 x 1080 像素 30 fps 或 60 fps</td><td align="left">3840 x 2160 像素 30 fps 或 60 fps</td></tr><tr><td align="left">活动详情页面图像</td><td align="left">.jpg、.jpeg、.png</td><td align="left">9 : 16</td><td align="left">1080 x 1920 像素</td><td align="left">2160 x 3840 像素</td></tr><tr><td align="left">活动详情页面视频</td><td align="left">.mov、.m4v、.mp4</td><td align="left">9 : 16</td><td align="left">1080 x 1920 像素 30 fps 或 60 fps</td><td align="left">2160 x 3840 像素 30 fps 或 60 fps</td></tr></tbody></table>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[推流分辨率码率设置]]></title>
            <link>https://gouxin.fun/2021/10/29/推流码率设置</link>
            <guid>/2021/10/29/推流码率设置</guid>
            <pubDate>Fri, 29 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[Header]]></description>
            <content:encoded><![CDATA[<p><img src="./Header.png" alt="Header"/></p><p>做直播始终离不开分辨率和码率的设置。</p><p>这里记录下腾讯音视频sdk中对推流参数的设置建议。</p><h3>分辨率码率对应表</h3><table><thead><tr><th>分辨率</th><th>码率范围</th></tr></thead><tbody><tr><td>160 * 160</td><td>100Kbps ~ 150Kbps</td></tr><tr><td>270*270</td><td>200Kbps ~ 300Kbps</td></tr><tr><td>480*480</td><td>350Kbps ~ 525Kbps</td></tr><tr><td>320*240</td><td>250Kbps ~ 375Kbps</td></tr><tr><td>480*360</td><td>400Kbps ~ 600Kbps</td></tr><tr><td>640*480</td><td>600Kbps ~ 900Kbps</td></tr><tr><td>320*180</td><td>250Kbps ~ 400Kbps</td></tr><tr><td>480*270</td><td>350Kbps ~ 550Kbps</td></tr><tr><td>640*360</td><td>500Kbps ~ 900Kbps</td></tr><tr><td>960*540</td><td>800Kbps ~ 1500Kbps</td></tr><tr><td>1280*720</td><td>1000Kbps ~ 1800Kbps</td></tr><tr><td>1920*1080</td><td>2500Kbps ~ 3000Kbps</td></tr></tbody></table>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[pod repo push使用总结]]></title>
            <link>https://gouxin.fun/2021/10/28/pod-repo-push使用总结</link>
            <guid>/2021/10/28/pod-repo-push使用总结</guid>
            <pubDate>Thu, 28 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[90088193-C7B8-4466-9DB9-DE681F7BF357]]></description>
            <content:encoded><![CDATA[<p><img src="./90088193-C7B8-4466-9DB9-DE681F7BF357.png" alt="90088193-C7B8-4466-9DB9-DE681F7BF357"/></p><p>我们在修改完lib库后的最后一步就是使用<code>pod repo push</code>，将新的版本推到仓库里。</p><p>可是有时候会遇到各种奇怪的问题，导致一直push不成功，这里总结下使用方式。</p><h3>使用方式</h3><pre><code class="language-shell">pod repo push &lt;仓库&gt; xxx.podspec
</code></pre><h3>使用pod lib lint检查</h3><p>在push前，我们最好使用<code>pod lib lint</code>检查一下，因为这个命令可以提前暴露出push时会遇到的问题。</p><h4>--allow-warnings</h4><p>最常用的选项，忽略警告</p><h4>--fail-fast</h4><p>建议加上，遇到error可以立马结束，这样就不用在很长很长的log里找到底是什么error。</p><h4>--no-subspecs</h4><p>如果有很多subspec，可以加上这个，能快点。</p><h4>--skip-import-validation</h4><p>跳过import校验。通常我们遇到下面的错误时，可以跳过对能否import的校验</p><pre><code class="language-shell"> - NOTE  | [iOS] xcodebuild:  ld: warning: ignoring file xxx/xx/x.a, missing required architecture x86_64 in file xxx/xx/
 - NOTE  | [iOS] xcodebuild:  ld: warning: ignoring file xxx/xx/x.a, missing required architecture i386 in file xxx/xx/
</code></pre><h4>--sources</h4><p>指定source，如果error是某个lib找不到，那么就通过这个指定这个lib的source, 可以指定多个，用逗号隔开。</p><pre><code class="language-shell">--sources=&quot;http://my-private/xxx/CocoapodsRepos.git,https://github.com/CocoaPods/Specs.git&quot;
</code></pre><h3>使用pod repo push</h3><p>一般能通过pod lib lint的，基本上push都没啥问题。不建议不lint直接push，因为push产生的Log会很长很长，如果遇到error将很难发现问题。一般常用的option：</p><h4>--allow-warnings</h4><p>最常用的选项，忽略警告</p><h4>--sources</h4><p>指定source，如果error是某个lib找不到，那么就通过这个指定这个lib的source, 可以指定多个，用逗号隔开。</p><h4>--skip-import-validation</h4><p>跳过import校验</p><h3>其他</h3><p>有时候还会遇到一些奇奇怪怪的问题。比如：能编译过，但是lint/push时都报compile Error，最后发现是RealReachability的header中会少一些宏定义，代码中又引用了这些宏，最终全部替换掉就能正常push。</p><p>总之，先lint，用<code>--fail-fast</code>尽快找到错误提示，完成修改。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Flex-Layout]]></title>
            <link>https://gouxin.fun/2021/10/27/Flex-Layout</link>
            <guid>/2021/10/27/Flex-Layout</guid>
            <pubDate>Wed, 27 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[193EADF1-38F8-4FAF-9335-A05209EC236A]]></description>
            <content:encoded><![CDATA[<p><img src="./193EADF1-38F8-4FAF-9335-A05209EC236A.png" alt="193EADF1-38F8-4FAF-9335-A05209EC236A"/></p><h2>flex布局</h2><p>flex布局由两部分组成：flex container(弹性容器)和flex item(弹性元素)组成。</p><h2>Flex container</h2><p>你可以通过<code>display:flex</code> 或者 <code>display:inline-flex</code>，来将一个元素变成弹性容器。<code>display:flex</code>声明的是块级框， <code>display:inline-flex</code>声明的是行内块级框。</p><p>当你声明一个元素是flex container时，他的每个直接子元素都变成了一个flex item。</p><h3>排版原则</h3><p>将item按照justifycontent的设置依次<strong>沿着主轴</strong>排列,默认不换行。</p><p>如果换行的话，那么<strong>沿着交叉轴</strong>方向排列下一行。</p><h3>flex container的轴</h3><p>弹性容器有2个轴：主轴 和 交叉轴。</p><p><code>flex-direction</code>定义了主轴的方向，他的取值如下：</p><pre><code class="language-css">row: 水平书写方向
row-reverse: 与row相反
coulm: 垂直于主轴的书写方向
coulm-reverse:与coulm相反
</code></pre><p>那么交叉轴呢？交叉轴始终和主轴垂直，方向是这个方向的书写方向。</p><p>这里都是用的书写方向，而不是水平向右这类词汇，因为对于不同的书写方向row的方向也不同，比如：对于从右到左书写方向的，他的row是，从右到左。</p><p>知道了主轴和交叉轴方向后，弹性元素将沿着主轴方向布局，如果允许换行，那么新的一行沿着交叉轴方向排列。</p><h3>换行flex-wrap</h3><p>如果弹性元素在主轴方向上排列不下。默认是不会换行的，如果设置了shrink，那就缩小尺寸，否则将从边框溢出。</p><p>我们可以使用flex-wrap控制换行。他的值如下：</p><pre><code>nowrap: 不换行
wrap: 沿着交叉轴方向换行
wrap-reverse: 沿着交叉轴的反方向换行
</code></pre><h3>flex-direction和flex-wrap的简写</h3><p><code>flex-flow</code>是flex-direction和flex-wrap的简写</p><h3>控制空白的位置</h3><p>目前为止，我们知道flex item会沿着主轴方向进行排列，如果有多行，那么行沿着交叉轴方向排列，这也意味着如果一行没占满，留有空白，那么这个空白始终出现在主轴+交叉轴的方向那。</p><p>我们可以控制这个行为，下面是相关属性：</p><pre><code class="language-css">justify-content ：控制一行中，item在主轴方向上的布局方式(我个人更喜欢理解为空白的处理方式)
flex-start: item沿着主轴依次布局，（空白全在末尾）
flex-end:item沿着主轴反方向依次布局，（空白全在开头）
center: 把所有item作为一个整体居中布局。 (空白两侧等分)
space-between: 把每行第一个元素放在主轴起边， 最后一个元素放在主轴终边。然后余下的item的两侧放置等量空白, 如果没有多余空白，那么会把最后一个元素撑到外面去。
space-around: item两侧有等量的不折叠的空白。
space-evenly: 把剩余空白等分，和item依次排列。这也意味着第一个元素到主轴起边和最后一个元素到主轴终边的距离是一样的。
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2tjs3h9ij31400sf4ci.jpg" alt="图像"/></p><p>如果没有多余空白，页不允许换行，那么将溢出，justify-content对溢出也有影响</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2tp24qdrj313x0ot134.jpg" alt="图像"/></p><h3>一行中如何对齐元素</h3><p>上面justify-content的例子有点特殊，因为他们的item的高度都是相等的，以至于我们忽略了，如果item也有不同高度时的情况。</p><p>如果item有不同的高度，那么item在交叉轴方向上应该如何布局嘞？</p><p>他受下面的属性控制：</p><pre><code class="language-css">align-items : 定义一行中，item在交叉轴上的布局方式
flex-start: 沿着交叉轴起边对其
flex-end: 沿着交叉轴终边对其
center: 在一行中垂直居中对其
stretch: 全部拉伸填满交叉轴方向
baseline: 各个item基线对其
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2u1epaxhj30dz12gq8x.jpg" alt="图像"/></p><h3>交叉轴对齐方式覆盖</h3><p>刚刚讲了align-items是item在一行中交叉轴上的布局方式。但有时我们可能存在特异化需求，比如奇数位置上的item是flex-start, 偶数位置上是flex-end。</p><p><code>align-self</code>便是用于覆盖align-items属性的值，和align-items不同的是，align-self是声明在flex item上的，覆盖了flex container上的align-items属性。</p><p>由于是覆盖align-items，所以他的取值和align-items是一样的，作用也是一样的。</p><h3>多个行的布局方式</h3><p>如果允许换行，那么久可能出现多个行的情况，默认情况下，多个行是沿着交叉轴方向依次排列。但我们可以改变这个行为。</p><p><code>align-content</code>属性指定了交叉轴方向上的额外空间如何分配到各个行之间。</p><p>他的取值和justify-content类似，多了个stretch。</p><pre><code class="language-css">align-content: 
flex-start : 沿着交叉轴起边依次排列行,(空白在末尾)
flex-end : 沿着交叉轴终边开始依次排列行，(空白在开头)
center: 把各个行作为一个整体，居中排列
space-between: 第一行放在交叉轴起边，最后一行放在交叉轴终边，剩余空间等分和item依次排列
space-around: item两边有等量的不折叠的空白
space-evenly: item两边有等量空白
stretch: 等分空白，每一行拉伸等量空白空间。
</code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2ujy594dj30u00zp1kx.jpg" alt="图像"/></p><h2>Flex item</h2><p>刚刚我们说的除了align-self，其他都是应用在container上的属性。接下来，我们再看看应用在item上的属性。</p><p>除了align-self，还有flex, flex-grow, flex-shrink, flex-basis, order。</p><p>其中flex是flex-grow flex-shrink flex-basis的缩写。</p><p>我们可能遇到出现的结果和想象的不一样的情况，这个大多数有2个原因：</p><ol><li>对属性含义的误解</li><li>忽略各个情况下的默认值</li></ol><p>弹性元素还有：外边距不折叠的特性。float和clear对弹性元素不起作用。</p><p>Vertical-align对弹性元素没有作用，vertical-align是文本属性中的一员，用于控制文本在文本行框中的垂直方向上的对其方式。所以你item指定了vertical-align:bottom，那么只是item中的文本在文本行框中底部对齐，而不是把item推向container的底部。</p><p>绝对定位对item也有影响。如果某个item使用了绝对定位，那么这个item将从文档流移除，不会参与弹性布局。虽然他从文档流中移除了，但是justify-content和align-self还是会影响绝对定位元素。比如：align-self:center，那么绝对定位item会在弹性容器中交叉轴方向居中。</p><h3>Flex-basis</h3><p>含义：根据增长因子或者缩减因子分配多余或者缺少空间之前，弹性元素的大小。</p><p>不鼓励：单独使用，建议用flex简写</p><pre><code class="language-css">flex-basis:
auto: width ==&gt; min-width =&gt; content
&lt;length&gt;: 指定长度,比如200px
&lt;percentage&gt;: 百分比，相对于弹性container
</code></pre><p>注意：flex-basis的默认值是auto，但是如果你指定了flex属性，省略了flex-basis，那么flex-basis是0%。</p><h3>Flex-grow</h3><p>含义：有多余空间时是否允许增大，以及如何分配剩余空间。</p><p>不鼓励：单独使用，建议用flex简写</p><p>负数无效。</p><p>下面看看container宽750，有3个100px的item：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2w7s8g6fj30w20u01bu.jpg" alt="图像"/></p><p>如果我们换成flex:1, flex:1, flex:3呢？我们看到又是分配的全部空间，而不是剩余空间。为什么呢？这就和默认值有关了。</p><p>如果我们单独设flex-grow，没有设置flex，和flex-basis，那么这个时候flex-basis是auto。也就是在分配剩余空间前，item占用width的空间，所以得到剩余空间是450px。</p><p>如果指定了flex:1， 但是省略了flex-basis，那么flex-basis是0，也就是说在分配剩余空间前，item不占空间，3个item都不占空间，那么剩余空间就是整个空间的大小，所以看到的是按比例分配。</p><h3>Flex-shrink</h3><p>翻译：空间不够放置所有弹性元素，而且弹性容器不能增加尺寸也不允许换行时，如何分配“缺少空间”。</p><p>不鼓励：单独使用，建议用flex简写</p><p>那么如何分配呢？首先得计算出缩减比例，缩减比例不仅和shrink有关，还和item宽度有关。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gr2x0tya2wj30zv07c408.jpg" alt="图像"/></p><p>最终item的宽度为</p><p>120/(150 <em> 1 + 250 </em> 1+ 200 <em>1) </em> 1 </p><p>Width = itemWidth <em> shrink </em> 缩小比例。</p><h3>flex</h3><p>之前说了flex是flex-grow flex-shrink flex-basis的简写，推荐使用这个。</p><p>唯一需要注意的是他的默认值。省略flex-basis的话是0 而不是auto。</p><h3>order</h3><p>定义item的顺序。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何为githubPage添加自定义域名]]></title>
            <link>https://gouxin.fun/2021/10/26/如何为githubPage添加自定义域名</link>
            <guid>/2021/10/26/如何为githubPage添加自定义域名</guid>
            <pubDate>Tue, 26 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD]]></description>
            <content:encoded><![CDATA[<p><img src="./68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD.png" alt="68CF50FD-8CA2-4A5B-9D3A-F1786775BDFD"/></p><p>当我们把blog托管在github page上后，就能得到一个<code>&lt;userName&gt;.github.io</code>的域名。不过有点丑，没关系我们还可以用自己的域名。</p><h3>第一步：购买域名</h3><p>我是在阿里云上买的一个域名，购买完成后，进入<code>解析设置</code>， 然后添加记录。</p><p><img src="./23A6A5C1-68E6-4B1C-B56F-C962C574E897.png" alt="23A6A5C1-68E6-4B1C-B56F-C962C574E897"/></p><h5>添加一个CNAME记录</h5><p>记录类型：CNAME</p><p>主机记录：www</p><p>记录值:  xxx.github.io</p><h5>添加多个A记录</h5><p>参考<a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">官方文档</a>, 添加多个A 和 AAAA</p><p>记录类型：A</p><p>主机记录：不填</p><p>记录值:  185.199.108.153</p><h3>第二步：修改仓库setting</h3><p><img src="./226E7E5E-6EE6-457B-85F9-CD1823B554ED.png" alt="226E7E5E-6EE6-457B-85F9-CD1823B554ED"/></p><p>Custom domain处填写你自己的域名，然后等一会github解析，成功后勾选<code>Enforce https</code>。</p><p>现在就可以访问新的。</p><h3>第三步：其他修改</h3><p>如果你使用像<code>docusaurus</code>这样的框架，那么还得修改config文件中的url和baseUrl。</p><pre><code class="language-json">{
  url: &#x27;https://gouxin.fun&#x27;,
  baseUrl: &#x27;/&#x27;,
}
</code></pre><p>然后你还会发现，每次deploy后custom domain都会被重置。我们还需要在static目录下加上CNAME文件，参考<a href="https://docusaurus.io/zh-CN/docs/deployment#docusaurusconfigjs-settings">https://docusaurus.io/zh-CN/docs/deployment#docusaurusconfigjs-settings</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[博客开张啦]]></title>
            <link>https://gouxin.fun/2021/10/25/博客开张啦</link>
            <guid>/2021/10/25/博客开张啦</guid>
            <pubDate>Mon, 25 Oct 2021 00:00:00 GMT</pubDate>
            <description><![CDATA[6DE1C549-029E-49E9-A79B-669B782FD675]]></description>
            <content:encoded><![CDATA[<p><img src="./6DE1C549-029E-49E9-A79B-669B782FD675.png" alt="6DE1C549-029E-49E9-A79B-669B782FD675"/></p><p> 之前的blog在老电脑上，现在已经找不到了，有段时间没有写博客了。现在用<a href="https://docusaurus.io/">docusaurus</a>重新搭建自己的博客。相比于hexo，docusaurus使用React更灵活。</p><p>加油！加油！加油</p>]]></content:encoded>
        </item>
    </channel>
</rss>
---
title: rust学习
description: "rustup用于更新rust。\ncargo是rust默认的包管理器。"
date: "2021-07-24"
---
# Chapter 2. A Tour of Rust

## rustup and Cargo

rustup用于更新rust。

~~~shell
rustup update
~~~

cargo是rust默认的包管理器。

```shell
cargo new project_name#新建一个项目
cargo run#编译，并运行
cargo build --release
cargo clean
...
```

## Rust Functions

```rust
fn gcd(mut n: u64, mut m: u64) ->u64 {
    assert!(n != 0 && m != 0);
    while m != 0 {
        if m < n {
            let t = m;
            m = n;
            n = t;
        }
        m = m % n;
    }
    n
}
```

## Writing and Running Unit Tests

```rust
#[test]
fn test_gcd() {
    assert_eq!(gcd(14, 15), 1);

    assert_eq!(gcd(2 * 3 * 5 * 11 * 17,
                   3 * 7 * 11 * 13 * 19),
               3 * 11);
}
```

```shell
cargo test
```

## Handling Command-Line Arguments

用env::args()获取参数

```rust
use std:: str:: FromStr;
use std:: env;

fn main() {
    let mut numbers = Vec:: new();

    for arg in env:: args().skip(1) {
        numbers.push(u64:: from_str(&arg)
                     .expect("error parsing argument"));
    }

    if numbers.len() == 0 {
        eprintln!("Usage: gcd NUMBER ...");
        std:: process::exit(1);
    }

    let mut d = numbers[0];
    for m in &numbers[1..] {
        d = gcd(d, *m);
    }

    println!("The greatest common divisor of {:?} is {}",
             numbers, d);
}
```

## Serving Pages to the Web

```rust
use actix_web::{web, App, HttpResponse, HttpServer};
use std::env;
use serde::{Deserialize};

async fn index() -> HttpResponse {
    HttpResponse::Ok().content_type("text/html")
        .body(r#"
                <title>GCD Calculator</title>
                <form action="/gcd" method="post">
                <input type="text" name="n"/>
                <input type="text" name="m"/>
                <button type="submit">Compute GCD</button>
                </form>
    "#)
}

#[derive(Deserialize)]
struct Info {
    m: u64,
    n: u64
}

async fn post_gcd(info: web::Form<Info>) -> HttpResponse {
    let result = gcd(info.n, info.m);
    let str = format!("The greatest common divisor of the numbers {} and {} \
                 is <b>{}</b>",info.n, info.m, result);
    HttpResponse::Ok().body(str)
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(||
        App::new()
            .route("/", web::get().to(index))
            .route("/gcd", web::post().to(post_gcd))
        )
        .bind("127.0.0.1:8080")?
        .run()
        .await
}

fn gcd(mut n: u64, mut m: u64) -> u64 {
    assert!(n != 0 && m != 0);
    while m != 0 {
        if m < n {
            let t = m;
            m = n;
            n = t;
        }
        m = m % n;
    }
    n
}

#[test]
fn test_gcd() {
    assert_eq!(gcd(14, 15), 1);

    assert_eq!(gcd(2 * 3 * 5 * 11 * 17, 3 * 7 * 11 * 13 * 19), 3 * 11);
}
```

## Command Line Tool

```rust
use text_colorizer::Colorize;
use regex::Regex;

#[derive(Debug)]
struct Argument {
    target: String,
    replacement: String,
    filename: String,
    output: String
}

fn print_usage() {
    eprintln!("{} - change occurrences of one string into another",
              "quickreplace".green());
    eprintln!("Usage: quickreplace <target> <replacement> <INPUT> <OUTPUT>");
}

fn parse_args() -> Argument {
    let args:Vec<String> = std::env::args().skip(1).collect();
    if args.len() != 4 {
        print_usage();
        eprintln!("{} wrong number of arg: expect 4, got {}", "Error".red().bold(), args.len());
        std::process::exit(1);
    }
    Argument {
        target: args[0].clone(),
        replacement: args[1].clone(),
        filename: args[2].clone(),
        output: args[3].clone()
    }
}


fn replace(target: &str, replacement: &str, text: &str) -> Result<String, regex::Error> {
    let regex = Regex::new(target)?;
    Ok(regex.replace_all(text, replacement).to_string())
}

fn main() {
    let arg = parse_args();
    let data = match std::fs::read_to_string(&arg.filename) {
        Ok(d) => d,
        Err(e) => {
            eprintln!("{} failed to read from file '{}': {:?}",
                      "Error:".red().bold(), arg.filename, e);
            std:: process:: exit(1);
        }
    };

    let result = match replace(&arg.target, &arg.replacement, &data)  {
        Ok(result) => result,
        Err(e) => {
            eprintln!("{} failed to replace text: {:?}",
                      "Error:".red().bold(), e);
            std:: process:: exit(1);
        }
    };

    match std::fs::write(&arg.output, &result) {
        Ok(_) => {},
        Err(e) => {
            eprintln!("{} failed to write to file '{}': {:?}",
                      "Error:".red().bold(), arg.filename, e);
            std:: process::exit(1);
        }
    }
}

```

# Chapter 3. Fundamental Types

## Fixed-Width Numeric Types

| 大小（位） | 无符号整数 | 有符号整数 | 浮点  |
| :--------- | :--------- | :--------- | :---- |
| 8          | `u8`       | `i8`       |       |
| 16         | `u16`      | `i16`      |       |
| 32         | `u32`      | `i32`      | `f32` |
| 64         | `u64`      | `i64`      | `f64` |
| 128        | `u128`     | `i128`     |       |
| 机器相关   | `usize`    | `isize`    |       |

| Literal       | Type     | Decimal value |
| :------------ | :------- | :------------ |
| `116i8`       | `i8`     | 116           |
| `0xcafeu32`   | `u32`    | 51966         |
| `0b0010_1010` | Inferred | 42            |
| `0o106`       | Inferred | 70            |

### Checked, Wrapping, Saturating, and Overflowing Arithmetic

Checked: 尝试，如果发生溢出panic

Wrapping: 溢出后值wrap

Saturating: 饱和，即使溢出了也只返回范围内的值(最大/最小值)

Overflowing: 返回元组(wrap后的值，是否溢出)

### 浮点数

f32, f64。

类型`f32`和`f64`具有 IEEE 要求的特殊值的关联常量，例如`INFINITY`, `NEG_INFINITY`（负无穷大）、`NAN`（非数字值）和`MIN`和`MAX`（最大和最小有限值）

`std::f32::consts`和`std::f64::consts`模块提供各种常用的数学常数等`E`，`PI`以及两种平方根

### Bool

true和false。

if的条件表达式必须是返回bool。

### Characters

rust的char是代表unicode字符，是4个字节。

### Tuple

```rust
let a =("Brazil", 1985);
a.0
a.1
```

### Pointer Types

Rust值默认是嵌套的，((1,2),(3,4))会在栈上连续分配4个int大小。

接下来我们讨论3种类型的指针：Reference, box, unsafe pointer。

#### Reference

&String代表对一个String类型的引用，&i32代表对一个i32类型的引用。

将引用视为Rust的基本指针是最容易上手的。

r:一个&i32只是包含i32地址的一个machine word。

*r: 代表i32的值。

#### Box

```rust
Box::new(123)//在堆上分配内存
```

#### Raw Pointer

```rust
*mut T
*const T
```

### Arrays, Vectors, and Slices

```rust
array: 数组，大小是编译时确定的不能更改
[T;N] 比如[i32;8]
```

```rust
vector: 在堆上，相同类型
Vec<T>
```

```rust
&[T], &mut [T] slice
```

hx_dayExam_share_friend



